<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>YiCloud-README</title>
      <link href="/2024/11/09/YiCloud-README/"/>
      <url>/2024/11/09/YiCloud-README/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Beatrueman/YiCloud">Beatrueman/YiCloud: A netdisk for everyone. It’s able to save everything.</a></p><p>一个简易的个人网盘系统</p><p><strong>技术栈</strong>：</p><p>前端：HTML + CSS + JavaScript</p><p>后端：Python Flask</p><p>数据库：MySQL</p><p><strong>持续开发…</strong></p><h2 id="页面展示">页面展示</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202402132235196.png" alt="image-20240213223544046"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202402132235140.png" alt="image-20240213223525005"></p><h2 id="功能介绍">功能介绍</h2><h3 id="注册与登录">注册与登录</h3><p>可完成基本的注册与登录功能。</p><p>当密码不正确时会出现提示：”用户名或密码错误，请重试！“</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202402132227510.png" alt="image-20240213222738338"></p><p>注册时会提示密码规范，不符合规范的密码无法进行注册。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202402132229882.png" alt="image-20240213222929577"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202402132229562.png" alt="image-20240213222956448"></p><h3 id="登出">登出</h3><p>点击红色按钮：<code>退出登录</code>即可登出当前用户。</p><h3 id="文件上传">文件上传</h3><p>用户登录后，点击蓝色按钮：<code>上传文件</code>即可选择本地文件进行上传。</p><p>上传成功与否都会出现弹窗反馈。</p><h3 id="文件下载">文件下载</h3><p>用户成功上传的文件都会生成一个超链接，只需点击超链接即可下载对应文件。</p><h3 id="文件删除">文件删除</h3><p>用户可点击每个文件后的红色删除按钮，即可删除对应文件。</p><h3 id="文件分页">文件分页</h3><p>每个页面固定展示7个文件，用户可点击右下角的分页按钮选择对应文件所在页面。</p><h2 id="如何安装？">如何安装？</h2><h3 id="本机部署">本机部署</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x install.sh</span><br><span class="line">./install.sh # 按要求填写数据库相关信息即可</span><br></pre></td></tr></table></figure><h3 id="Docker-Compose部署">Docker-Compose部署</h3><p>首先需要安装好docker和docker-compose</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>相关设置可在<code>docker-comppose.yml</code>中修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: mysql </span><br><span class="line">    environment: </span><br><span class="line">      MYSQL_ROOT_PASSWORD: YiCloud*123456</span><br><span class="line">      MYSQL_DATABASE: cloud</span><br><span class="line">      MYSQL_USER: cloud</span><br><span class="line">      MYSQL_PASSWORD: YiCloud*123456</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/data:/var/lib/mysql # 持久化mysql数据目录</span><br><span class="line">      - /root/init:/docker-entrypoint-initdb.d/ # 挂载init目录，需要包含init.sql保证数据库初始化</span><br><span class="line">  web:</span><br><span class="line">    image: beatrueman/yicloud:v1 </span><br><span class="line">    volumes:</span><br><span class="line">      - /root/cloud/data:/YiCloud/data # 持久化data目录（保存了每个用户的文件夹）</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8888:6666&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    environment: # 以下设置不要更改，否则数据库会出问题</span><br><span class="line">      - HOST=db:3306 </span><br><span class="line">      - USER=cloud </span><br><span class="line">      - PASSWORD=YiCloud*123456 </span><br><span class="line">      - DATABASE=cloud</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="目录文件夹介绍">目录文件夹介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree .</span><br><span class="line">.</span><br><span class="line">├── config.py # 数据库配置信息</span><br><span class="line">├── data # 每个用户的文件夹</span><br><span class="line">├── database # 用于建表</span><br><span class="line">│   └── cloud_user.sql</span><br><span class="line">├── database_init.py # 数据库初始化（用于检查表，执行建表语句）</span><br><span class="line">├── docker-compose.yml # docker-compose部署</span><br><span class="line">├── Dockerfile # 打包镜像</span><br><span class="line">├── init.sql # 数据库初始化（用于创建用户，database等）</span><br><span class="line">├── install.sh # 本机部署安装脚本</span><br><span class="line">├── main.py # 项目主文件</span><br><span class="line">├── main.sh # 脚本执行启动项目（先数据库初始化再启动本项目）</span><br><span class="line">├── README.md</span><br><span class="line">├── requirements.txt # 依赖文件</span><br><span class="line">├── routes # 路由</span><br><span class="line">│   ├── dashboard.py # 主功能路哟</span><br><span class="line">│   ├── index.py # 注册登录路由</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">├── static # 静态文件</span><br><span class="line">│   ├── 1.jpg # 图标文件</span><br><span class="line">│   ├── 1.svg</span><br><span class="line">│   ├── 2.png</span><br><span class="line">│   ├── blog.png</span><br><span class="line">│   ├── css # 样式文件</span><br><span class="line">│   │   └── index.css</span><br><span class="line">│   ├── disk.png</span><br><span class="line">│   └── github.png</span><br><span class="line">└── templates # 模板</span><br><span class="line">    ├── dashboard.html # 主页面</span><br><span class="line">    ├── index.html # 登录页面</span><br><span class="line">    └── regist.html # 注册页面</span><br><span class="line"></span><br><span class="line">9 directories, 32 files</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安全防范">安全防范</h2><h3 id="密码规范">密码规范</h3><p>采用正则匹配，对用户密码进行规范，避免弱口令。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202402132257400.png" alt="image-20240213225723349"></p><p>用户注册后的密码会经过<code>bcrypt</code>加密后存入数据库，即使被撞库也无法得知真实密码。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202402132259162.png" alt="image-20240213225938131"></p><h3 id="SQL注入防范">SQL注入防范</h3><p>使用<code>flask_sqlalchemy</code>进行参数化查询而不是字符串插值。参数化查询会将用户输入视为参数，而不是 SQL 代码的一部分，从而防止攻击者注入恶意代码。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202402132304036.png" alt="image-20240213230412984"></p><p>此处<code>.filter_by(username=username)</code>将username视为参数而不是直接拼接到SQL查询语句中。</p>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Achievements </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LarkBot-README</title>
      <link href="/2024/11/08/LarkBot-README/"/>
      <url>/2024/11/08/LarkBot-README/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Beatrueman/FeishuBot">Beatrueman/FeishuBot: 一个飞书机器人</a></p><h2 id="更新与修复">更新与修复</h2><h3 id="2023年9月1日更新">2023年9月1日更新</h3><p>更新了对话机器人返回帮助界面功能，用户发送“帮助”，返回机器人使用说明</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202309011614056.png" alt="image-20230901161429940"></p><h3 id="2023年8月30日更新">2023年8月30日更新</h3><p>更新了对话机器人返回微博热搜榜功能，用户发送“热搜”，返回即时热搜榜</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202309011552244.png" alt="image-20230901155214031"></p><h3 id="2023年8月28日更新">2023年8月28日更新</h3><p>1.将原先的<code>TestApi.py</code>整合进<code>ChatApi.py</code>中，省去了繁琐的目录与代码文件</p><p>2.更新了请求地址配置方法，只需要一个文件<code>ChatApi.py</code>即可</p><h2 id="飞书机器人介绍"><strong>飞书机器人介绍</strong></h2><blockquote><p><a href="https://open.feishu.cn/document/client-docs/bot-v3/bot-overview">机器人概述 - 开发指南 - 开发文档 - 飞书开放平台 (feishu.cn)</a></p></blockquote><p>飞书机器人分为两种，一种是<strong>自定义机器人</strong>，一种是<strong>应用机器人</strong>。</p><h3 id="自定义机器人">自定义机器人</h3><p>只能在群聊中使用，只能完成比较固定的消息推送。</p><p><strong><em>webhook</em>获取方法：</strong></p><p>1.进入目标群组，在群组右上角点击更多按钮，并点击 <strong>设置</strong>。</p><p><img src="https://sf3-cn.feishucdn.com/obj/open-platform-opendoc/3717a10d5e293fc80d296267478f4bb3_LREe0920Bf.png?height=1524&amp;lazyload=true&amp;maxWidth=600&amp;width=2020" alt="img"></p><p>2.在右侧 <strong>设置</strong> 界面，点击 <strong>群机器人</strong>。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311837969.png" alt="img"></p><p>3.在 <strong>群机器人</strong> 界面点击 <strong>添加机器人</strong>。</p><p>4.在 <strong>添加机器人</strong> 对话框，找到 <strong>自定义机器人</strong>，并 <strong>添加</strong>。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311838153.png" alt="img"></p><p>5.设置自定义机器人的名称与描述，并点击 <strong>添加</strong>。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311838285.png" alt="img"></p><p>6.获取自定义机器人的 <em>webhook</em> 地址，并点击 <strong>完成</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311840164.png" alt="img"></p><h3 id="应用机器人">应用机器人</h3><p>功能很多，开发性高，灵活性强。需要有企业账户，支持对话互动等多种功能。</p><h4 id="app-id与app-secret获取方法"><em>app_id</em>与<em>app_secret</em>获取方法</h4><p>1.用企业账户，在开发者后台中，<strong>创建企业自建应用</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311843815.png" alt="image-20230731184331697"></p><p>2.找到app_id与qpp_secret</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311845488.png" alt="image-20230731184507412"></p><p>3.添加应用能力，选择机器人</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311845159.png" alt="image-20230731184549009"></p><p>4.添加以下权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">im:message,im:message.group_at_msg,im:message.group_at_msg:readonly,im:message.group_msg,im:message.p2p_msg,im:message.p2p_msg:readonly,im:message:readonly,im:chat:readonly,im:chat,im:message:send_as_bot</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311846289.png" alt="image-20230731184637236"></p><p>开启<em><strong>事件订阅</strong></em>：</p><p>若要使机器人有互动对话功能，需要填写请求配置地址，并添加<strong>接收消息v2.0</strong>和<strong>消息已读v2.0</strong>事件</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308021656698.png" alt="image-20230802165643614"></p><h4 id="请求地址配置方法"><strong>请求地址配置</strong>方法</h4><p><strong>1.使用反向代理工具ngrok完成内网穿透</strong></p><p>使用docker启动ngrok</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -e NGROK_AUTHTOKEN=&lt;token&gt; ngrok/ngrok http 8080</span><br></pre></td></tr></table></figure><p><em><strong>NGROK_AUTHTOKEN</strong></em>获取方法：</p><p>1.1 进入ngrok官网<a href="https://link.zhihu.com/?target=https%3A//ngrok.com/">https://ngrok.com/</a>，注册ngrok账号并下载ngrok</p><p>1.2 获取Authtoken</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308031231178.png" alt="image-20230803123131090"></p><p>获取公网地址后，按下Ctrl + P，然后再按下Ctrl + Q，使容器后台运行。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308031236943.png" alt="image-20230803123606894"></p><p>1.3 在<code>FeishuBot/public/chat/conf.py</code>中填写相关信息</p><p>先运行<code>ChatApi.py</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 ChatApi.py</span><br></pre></td></tr></table></figure><p>到飞书后台填写请求配置地址，格式为<a href="https://123456.ngrok-free.app/query/message">https://123456.ngrok-free.app/query/message</a></p><p>期间保证ngrok在后台一直运行</p><p><strong>2.使用Kubernetes暴露公网</strong></p><p>2.1 在<code>FeishuBot/public/build-api</code>填好<code>conf.py</code>中的信息，然后自己制作docker镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t docker的用户名/镜像名:&lt;tag&gt; .</span><br><span class="line">docker push 做好的镜像</span><br></pre></td></tr></table></figure><p>2.2在<code>FeishuBot/public/build-api</code>下，修改<code>deploy.yaml</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: api</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: api</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: api</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: api</span><br><span class="line">        image:  # 在build-api目录下制作的镜像</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: api</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: api</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: http  </span><br><span class="line">    protocol: TCP</span><br><span class="line">    port: 80  # 对外暴露的端口</span><br><span class="line">    targetPort: 8080 # Flask应用容器监听的端口</span><br><span class="line">    nodePort: 39378</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后获取检验用的请求配置地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f deploy.yaml</span><br><span class="line">kubectl get svc # 获取端口为39378,记得在服务器开放</span><br></pre></td></tr></table></figure><p>地址示例：http://1.2.3.4:3XXXXX/query/message</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308031852674.png" alt="image-20230803185245586"></p><h2 id="功能"><strong>功能</strong></h2><ul><li>青年大学习提醒</li><li>天气通知</li><li>互动对话功能</li><li>ChatGPT—引用网上项目</li></ul><h3 id="青年大学习提醒">青年大学习提醒</h3><p>实现每周一早上九点，通知用户完成青年大学习</p><p>点击超链接跳转微信</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311808856.png" alt="image-20230731180846759"></p><p>使用方法</p><p><strong>自定义机器人</strong>：在<code>FeishuBot/personal/conf.py</code>中填写你的webhook</p><p><strong>应用机器人</strong>：在<code>FeishuBot/public/send/conf.py</code>中填写你的app_id和app_secret</p><p>开启服务：自定义机器人启动脚本<code>FeishuBot/personal/qndxx-remind/run1.sh</code></p><p>​                    应用机器人启动脚本<code>FeishuBot/public/send/qndxx-remind/run1.sh</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x run1.sh</span><br><span class="line">./run1.sh</span><br></pre></td></tr></table></figure><h3 id="天气通知">天气通知</h3><p>实现每天早上七点，向用户推送天气信息</p><p>普通天气</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311902236.png" alt="image-20230731190241182"></p><p>出现灾害天气时，推送气象台预警信息，并附带特殊天气图标</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311903116.png" alt="image-20230731190331070"></p><p>使用方法</p><p><strong>自定义机器人</strong>：在<code>FeishuBot/personal/conf.py</code>中填写你的webhook和指定城市</p><p><strong>应用机器人</strong>：在<code>FeishuBot/public/send/conf.py</code>中填写你的app_id和app_secret，指定城市</p><p>开启服务：自定义机器人启动脚本<code>FeishuBot/personal/weather-remind/run2.sh</code></p><p>​                    应用机器人启动脚本<code>FeishuBot/public/send/weather-remind/run2.sh</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x run1.sh</span><br><span class="line">./run2.sh</span><br></pre></td></tr></table></figure><h3 id="互动对话功能">互动对话功能</h3><p><strong>仅限应用机器人</strong></p><p><strong>互动对话逻辑</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308032313540.jpeg" alt="img"></p><p>实现向应用机器人发送特定信息，返回特定内容</p><p>1.用户发送”<strong>青年大学习</strong>“，机器人回复青年大学习通知内容</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308012231904.png" alt="image-20230801223157822"></p><p>2.用户发送&quot;<strong>查询天气：指定城市名</strong>&quot;后，机器人回复需要监测天气城市的天气信息。</p><p>城市名注意不要带市和区。 如: 北京、南岸</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308021105899.png" alt="image-20230802110517854"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308021204780.png" alt="image-20230802120451729"></p><p>3.用户发送“<strong>热搜</strong>”，机器人返回即时热搜榜</p><h3 id="ChatGPT"><img src="https://gitee.com/beatrueman/images/raw/master/img/202309011552244.png" alt="">ChatGPT</h3><p>参考网上的项目，建议使用新的应用机器人</p><blockquote><p><a href="https://aircode.cool/q4y1msdim4">飞书 ChatGPT 机器人 - 用 JavaScript 五分钟开发一个飞书 ChatGPT 机器人 (aircode.cool)</a></p></blockquote><h2 id="BUG">BUG</h2><p><s>1.用K8s配置请求地址时，用于检验时地址都是可用的，但是更改镜像后，无法使用互动对话功能</s></p><p>2.互动对话功能在服务器上使用ngrok有点问题，在windows下完全可以使用</p><p><s>3.因为配置请求地址时需要在固定地址的情况下改变镜像，所以GitLab中的CI只跑通用于检验的镜像并部署在K8s，详情请看.gitlab-ci.yaml</s></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308041856285.png" alt="image-20230804185615165"></p>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Achievements </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法记录</title>
      <link href="/2024/11/08/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/11/08/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="基于线性表的图书信息管理"><strong>基于线性表的图书信息管理</strong></h2><p>选用顺序表或链表实现线性表的的基本操作。</p><h3 id="图书信息表的创建和输出">图书信息表的创建和输出</h3><p><code>InitList()</code>用来初始化链表，<code>CreateList_R(LinkList *L)</code>利用后插法来创建链表链表。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化链表</span><br><span class="line">LinkList InitList()</span><br><span class="line">&#123;</span><br><span class="line">    LinkList L = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">    if(L == NULL) &#123;</span><br><span class="line">        printf(&quot;链表初始化失败！\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = NULL; // 头指针设置为空</span><br><span class="line">    printf(&quot;链表初始化成功！\n&quot;);</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 后插法创建链表</span><br><span class="line">int CreateList_R(LinkList *L)</span><br><span class="line">&#123;</span><br><span class="line">    *L = InitList();</span><br><span class="line">    LinkList r = *L; // 尾指针r指向头结点</span><br><span class="line"></span><br><span class="line">    Book book;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkList p = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">        if(p == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;创建链表时分配内存失败！\n&quot;);</span><br><span class="line">            return ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        scanf(&quot;%s %s %f&quot;, &amp;book.no, &amp;book.name, &amp;book.price);</span><br><span class="line">        // 吸收回车</span><br><span class="line">        getchar();</span><br><span class="line">        // 检查输入结束标志</span><br><span class="line">        if(strcmp(book.no, &quot;0&quot;) == 0 &amp;&amp;strcmp(book.name, &quot;0&quot;) == 0 &amp;&amp;book.price == 0) &#123;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = book;</span><br><span class="line">        p-&gt;next = NULL; // 新结点设置为尾结点，也就是新结点的指向NULL</span><br><span class="line">        r-&gt;next = p; // 原来的尾结点指向新结点</span><br><span class="line">        r = p; // 尾指针指向新结点</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试截图：</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411082310968.png" alt="img"></p><h3 id="图书信息表的修改">图书信息表的修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 修改</span><br><span class="line">void ChangePrice(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    float sum = 0, average = 0;</span><br><span class="line">    int length = GetLength(L);</span><br><span class="line">    LinkList p = L-&gt;next; // p指向首元节点</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += p-&gt;data.price;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    average = sum / length;</span><br><span class="line">    printf(&quot;平均价格: %.2f\n&quot;, average);</span><br><span class="line">    //printf(&quot;链表长度: %d&quot;, length);</span><br><span class="line"></span><br><span class="line">    // 重新将p指向头结点</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if( p-&gt;data.price &lt; average )</span><br><span class="line">            p-&gt;data.price *= 1.2;</span><br><span class="line">        else if( p-&gt;data.price &gt; average )</span><br><span class="line">            p-&gt;data.price *= 1.1;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    PrintList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试截图：</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411082311582.png" alt="img"></p><h3 id="查找最贵图书">查找最贵图书</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查找最贵图书</span><br><span class="line">void FindHighPrice(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    float max = 0;</span><br><span class="line">    int count = 0;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    // 找最大价格</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p-&gt;data.price &gt; max) &#123;</span><br><span class="line">            max = p-&gt;data.price;</span><br><span class="line">            count = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p-&gt;data.price == max)</span><br><span class="line">        &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d\n&quot;, count);</span><br><span class="line"></span><br><span class="line">    // 找最贵价格图书信息</span><br><span class="line">    p = L-&gt;next; // 重置p到首元节点</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p-&gt;data.price == max)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%s %s %.2f\n&quot;, p-&gt;data.no, p-&gt;data.name, p-&gt;data.price);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图书入库">图书入库</h3><p>这里涉及到插入链表操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 新图书入库(插入)</span><br><span class="line">int BookInsert(LinkList *L, int i, Book e)</span><br><span class="line">&#123;</span><br><span class="line">    // 头指针</span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    int j = 0;</span><br><span class="line">    // 找第i-1个位置</span><br><span class="line">    while(p &amp;&amp; (j &lt; i - 1))</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!p || j &gt; i - 1)</span><br><span class="line">        return ERROR;</span><br><span class="line">    LinkList s = (LinkList)malloc(sizeof(LNode)); // 创建新结点</span><br><span class="line">    if(s == NULL)</span><br><span class="line">        return ERROR;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411082312220.png" alt="img"></p><p>当插入位置不合法时会报错</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411082313053.png" alt="img"></p><h3 id="旧图书出库">旧图书出库</h3><p>这里涉及删除链表结点操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int BookDelete(LinkList *L, int i)</span><br><span class="line">&#123;</span><br><span class="line">    // 头指针</span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    int j = 0;</span><br><span class="line">    // 找第i-1位置</span><br><span class="line">    while( (p-&gt;next) &amp;&amp; (j &lt; i - 1) )</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当i大于链表长度或者i&lt;1时，位置不合理</span><br><span class="line">    if( !(p-&gt;next) || (j &gt; i - 1) )</span><br><span class="line">        return ERROR;</span><br><span class="line">    LNode *q = p-&gt;next; // 临时保存被删除结点的地址;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    free(q);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411082313782.png" alt="img"></p><p>同时删除位置不合法时也会报错</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411082314139.png" alt="img"></p><h3 id="图书去重">图书去重</h3><p>思路是用一个二维字符数组来保存不同图书的ISBN号，设置一个前驱指针pre指向头结点，p指针指向首元节点，count做不同图书的数量计数器。然后遍历链表，将每个结点图书的ISBN号与已经保存在字符数组里的ISBN号进行比对，利用flag来确定图书是否找到。如果找到，flag=1，用一个中间指针temp保存这个结点，然后前驱指针跳过当前节点，p指针后移，free掉temp结点。没找到的话就把ISBN保存在数组里，然后count自增，更新前驱结点为当前结点，最后p后移。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 根据ISBN对图书去重</span><br><span class="line">void BookDuplicateDeleteByISBN(LinkList *L)</span><br><span class="line">&#123;</span><br><span class="line">    char ISBNList[MAXSIZE][20]; // 存储ISBN</span><br><span class="line">    int count = 0;</span><br><span class="line">    // p指向首元节点</span><br><span class="line">    LinkList p = (*L)-&gt;next;</span><br><span class="line">    LinkList pre = *L; // 用来保存前驱结点</span><br><span class="line"></span><br><span class="line">    while( p != NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for(int i = 0; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(strcmp(p-&gt;data.no, ISBNList[i]) == 0) &#123;</span><br><span class="line">                flag = 1; // 找到，标志设置为1</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            LinkList temp = p;</span><br><span class="line">            pre-&gt;next = p-&gt;next; // 前驱指针跳过当前结点</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            free(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果当前书号没出现过，加入ISBN字符数组里</span><br><span class="line">            strcpy(ISBNList[count], p-&gt;data.no);</span><br><span class="line">            ++count; // 已访问书号数量增加</span><br><span class="line">            pre = p; // 更新前驱结点为当前结点</span><br><span class="line">            p = p-&gt;next; // 移动到下一个结点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411082314515.png" alt="img"></p><p>一些辅助函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取链表长度</span><br><span class="line">int GetLength(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    int length = 0;</span><br><span class="line">    while(p != NULL) &#123;</span><br><span class="line">        ++length;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br><span class="line">// 输出</span><br><span class="line">void PrintList(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    int length = GetLength(L);</span><br><span class="line">    printf(&quot;\n%d\n&quot;, length);</span><br><span class="line">    // p重新指向头结点</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s %s %.2f\n&quot;, p-&gt;data.no, p-&gt;data.name, p-&gt;data.price);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数调用：利用switch-case来让用户通过序号选择不同的操作，每个case的思路大致相同，都是先创建链表CreateList_R()，然后再执行对应的操作函数，最后调用PrintList()输出整个链表。</p><h3 id="Trouble-Shooting">Trouble Shooting</h3><p>**问题：**图书去重时，刚开始利用了删除函数<code>BookDelete()</code>对图书删除，并且没有使用temp指针来暂存被删除结点，而且指针 p 和前驱 pre 没有正确更新，执行程序时，程序发生阻塞。</p><p>**解决办法：**利用temp指针暂存被删除节点，然后<code>free(temp)</code>删除，删除节点后，立即更新 p 指向下一个未被删除的节点。</p><h2 id="基于栈的算术表达式求值"><strong>基于栈的算术表达式求值</strong></h2><p>输入一个中缀算术表达式，求解表达式的值。运算符包括“+”、“-”、“*”、“/”、 “(”、“)”、“=”，参加运算的数为整数。</p><h3 id="整体思路"><strong>整体思路</strong></h3><p>定义了两个类型的栈OpStack（用来存储运算符）（char）、NumStack（用来存储操作数）（int）</p><p><strong>基本操作有两套：</strong></p><p>对于运算符栈：初始化<code>InitOpStack()</code>、入栈<code>PushOp(opStack s, char e)</code> 、出栈<code>PopOp(opStack s, char *e)</code>、取栈顶元素<code>GetOpTop(opStack s)</code></p><p>对于操作数栈：初始化<code>InitNumStack()</code>、入栈<code>PushNum(numStack s, int e)</code>、出栈<code>PopNum(numStack s, int *e)</code>、取栈顶元素<code>GetOpTop(opStack s)</code></p><p>获取索引<code>getIndex(char theta)</code>、获取优先级<code>getPriority(char theta1, char theta2)</code>、计算函数<code>Operate(int a, int b, char op)</code></p><p><strong>核心是</strong></p><p>初始化两个栈OPND和OPTR，一个存操作数另一个运算符，运算符栈初始时先压入一个 #</p><p>然后要给字符数组e的结尾追加#作为表达式的结尾识别。</p><p>循环读入表达式每一个字符</p><p>一、如果是数字就进OPND栈</p><p>累加数字组合为一个多位数，标记一个多位数。然后压入OPND栈</p><p>二、如果是运算符就进OPTR栈</p><p>调用<code>getPriority()</code>，将此时的OPTR栈顶元素与表达式中读入的运算符ch进行优先级比较</p><ol><li>如果栈顶运算符优先级高于ch，循环执行以下操作：</li></ol><p>弹出OPTR运算符op<br>弹出OPND两个操作数a，b<br>调用Operate()函数，传入a，b，op三个元素进行计算，返回结果result<br>将结果result压入OPND栈</p><ol start="2"><li>如果栈顶运算符优先级低于ch，则ch入OPTR栈</li><li>如果栈顶运算符优先级等于ch，弹出OPTR的括号</li><li>最后弹出OPND的栈顶元素，即为运算结果</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 主计算函数</span><br><span class="line">int Calculate(char e[])</span><br><span class="line">&#123;</span><br><span class="line">    numStack OPND = InitNumStack();</span><br><span class="line">    opStack OPTR = InitOpStack();</span><br><span class="line">    PushOp(OPTR, &#x27;#&#x27;);  // 初始化运算符栈</span><br><span class="line"></span><br><span class="line">    char ch, op;</span><br><span class="line">    int a, b, result = 0;</span><br><span class="line">    int num = 0;</span><br><span class="line">    int flag = 0; // 检测是否为多位数</span><br><span class="line"></span><br><span class="line">    strcat(e, &quot;#&quot;);</span><br><span class="line"></span><br><span class="line">    for(int i = 0; e[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = e[i];</span><br><span class="line">        if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">            num = num * 10 + (ch - &#x27;0&#x27;); // 累加组合成多位数</span><br><span class="line">            flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if(flag) &#123;</span><br><span class="line">                PushNum(OPND, num);  // 压入操作数</span><br><span class="line">                num = 0;</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while(getPriority(GetOpTop(OPTR), ch) == &#x27;&gt;&#x27;) &#123;</span><br><span class="line">                PopOp(OPTR, &amp;op);</span><br><span class="line">                PopNum(OPND, &amp;b);</span><br><span class="line">                PopNum(OPND, &amp;a);</span><br><span class="line">                result = Operate(a, b, op);</span><br><span class="line">                PushNum(OPND, result);</span><br><span class="line">            &#125;</span><br><span class="line">            if (getPriority(GetOpTop(OPTR), ch) == &#x27;&lt;&#x27;) &#123;</span><br><span class="line">                PushOp(OPTR, ch);  // 压入当前运算符</span><br><span class="line">            &#125; else if (getPriority(GetOpTop(OPTR), ch) == &#x27;=&#x27;) &#123;</span><br><span class="line">                PopOp(OPTR, &amp;op); // 出栈匹配</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PopNum(OPND, &amp;result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主函数">主函数</h3><p>主函数定义一个字符数组e[]存储单条表达式，p[][]存储所有表达式<br>循环读入单条表达式，去除换行符，如果最终输入是单个=结束循环，然后将所有的单条表达式存储在二维字符数组p中</p><p>遍历p，调用<code>Calculate()</code>计算每条表达式的结果，最后输出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char e[MAXSIZE]; // 一条表达式 </span><br><span class="line">    char p[MAXSIZE][MAXSIZE]; // 所有表达式</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;输入表达式，每行一个，以\&quot;=\&quot;结束：\n&quot;);</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        gets(e); // 读取一行表达式</span><br><span class="line">        // 去除换行符</span><br><span class="line">        e[strcspn(e,&quot;\n&quot;)] = 0;</span><br><span class="line"></span><br><span class="line">        if(strcmp(e, &quot;=&quot;) == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        strcpy(p[count++], e);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;计算结果为：\n&quot;);</span><br><span class="line">    for(int i = 0; i &lt;count; i++) &#123;</span><br><span class="line">        int result = Calculate(p[i]);</span><br><span class="line">        printf(&quot;%d\n&quot;, result);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Trouble-Shooting-v2">Trouble Shooting</h3><h4 id="Q1">Q1</h4><p>问题： OPTR栈顶元素与表达式ch操作符优先级比较时，没有循环执行操作，而使用的是switch-case，导致输出结果总是表达式的最后一个数字</p><p>解决办法：需要循环执行操作</p><h4 id="Q2">Q2</h4><p>问题：刚开始只定义了一个栈的结构体，最后导致字符和数字的转换问题，使程序出现问题。</p><p>解决办法：分别定义两个栈的结构体，分别存储运算符（char）和操作数（int）</p><h4 id="Q3">Q3</h4><p>问题：表达式没有以#结尾，导致运算错误</p><p>解决办法：使用<code>strcat()</code>函数，将#放在字符数组的末尾。</p><h2 id="基于字符串模式匹配算法的病毒感染检测问题（KMP算法）"><strong>基于字符串模式匹配算法的病毒感染检测问题（KMP算法）</strong></h2><p>研究者将人的DNA和病毒DNA均表示成由一些字母组成的字符串序列，然后检测某种病毒DNA</p><p>序列是否在患者的DNA序列中出现过，如果出现过，则此人感染了该病毒，否则没有感染。例如，假设病毒的DNA序列为baa，患者1的DNA序列为aaabbba则感染;患者 2 的DNA序列为 babbba，则未感染。（注意，人的DNA序列是线性的，而病毒的DNA序列是环状的）</p><h3 id="预处理模式">预处理模式</h3><p>因为病毒的DNA是环状的，所以它会存在多种形式。比如病毒环状DNA为abb，则匹配人类DNA时，病毒会出现abb、bba、bab三种情况。这时可以把病毒的DNA扩充一倍，然后通过病毒DNA长度次循环，将环状DNA所有可能出现的形式通过<code>strncpy(patterns[i], v_double + i, *len_v)</code>;保存在一个二维数组里作为模式串。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 输入DNA序列，因为病毒为环状，所以病毒DNA需要拼接</span><br><span class="line">void PreProcess(char h[], char v[], int *len_h, int *len_v, int *num, char patterns[][200])</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    *len_v = strlen(v);</span><br><span class="line"></span><br><span class="line">    // 对病毒环状DNA拼接</span><br><span class="line">    char *v_double = (char *)malloc(strlen(v) * 2 + 1);</span><br><span class="line">    if (v_double == NULL) &#123;</span><br><span class="line">        printf(&quot;内存分配失败！\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    strcpy(v_double, v); // 病毒DNA复制到新数组</span><br><span class="line">    strcat(v_double, v); // 病毒DNA追加到末尾</span><br><span class="line"></span><br><span class="line">    *len_h = strlen(h);</span><br><span class="line"></span><br><span class="line">    // 生成所有可能的旋转形式</span><br><span class="line">    *num = *len_v;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i; i &lt; *num; i++) &#123;</span><br><span class="line">        strncpy(patterns[i], v_double + i, *len_v); // 从v_double第i个位置复制len_v个字符到patterns[]里</span><br><span class="line">        patterns[i][*len_v]= &#x27;\0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(v_double);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取next数组">获取next数组</h3><p>求next数组分为两种情况，一个是前后缀相同，另一种是前后缀不相同。</p><p>首先设置两个指针i和j，一个<code>next[]</code>数组。</p><p>next数组第0个元素初始化为-1（初始化-1，则kmp在匹配失败时，就会找匹配失败的字符对应的next数组中对应的值），i和j分别初始化为0和-1。</p><p>也就是i指向模式串第0个元素，j指向最前端。</p><p>对模式串进行遍历：</p><p>以aabaaf为例，求next数组的流程如下</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411082321454.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取next数组</span><br><span class="line">void GetNext(int next[], char v[], int len_v)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = -1;</span><br><span class="line">    next[0] = -1; // next初始化为-1</span><br><span class="line"></span><br><span class="line">    while (i &lt; len_v - 1) &#123;</span><br><span class="line">        if ((j == -1) || (v[i] == v[j])) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="KMP算法">KMP算法</h3><p>首先利用<code>GetNext()</code> 获取模式串的next[]数组。</p><p>然后根据<code>next[]</code>数组，模式串（<code>v[]</code>）匹配字符串（<code>h[]</code>）</p><p>j指向<code>v[]</code>模式串，i指向<code>h[]</code>字符串。然后循环匹配，当<code>h[i] != v[j]</code>时候，j根据next[]数组进行回退（<code>j = next[j]</code>）</p><p>以aabaaf匹配aabaabaaf为例：</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411082321238.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// KMP算法</span><br><span class="line">int kmp(char h[], char v[], int len_v)</span><br><span class="line">&#123;</span><br><span class="line">    int *next = (int *)malloc(len_v * sizeof(int));</span><br><span class="line">    if (next == NULL) &#123;</span><br><span class="line">        printf(&quot;next数组内存分配失败！&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    GetNext(next, v, len_v);</span><br><span class="line"></span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">    int len_h = strlen(h);</span><br><span class="line">    while (i &lt; len_h &amp;&amp; j &lt; len_v ) &#123;</span><br><span class="line">        if (j == -1 || h[i] == v[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j = next[j]; // 根据next数组回退</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(next);</span><br><span class="line"></span><br><span class="line">    return j == len_v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="主函数调用">主函数调用</h3><p>主函数定义 h[],v[]分别用来存储人类DNA和病毒DNA</p><p>patterns[][]用来保存环状病毒DNA的不同组合形式的模式串。</p><p>循环读入：</p><p>病毒DNA和人类DNA,以0，0结束输入。然后调用<code>PreProcess()</code>对病毒DNA进行处理，把所有的模式串情况保存在patterns[][]里。然后调用<code>kmp()</code>对模式串(<code>patterns[i]</code>)与人类DNA（<code>h[]</code>）进行匹配，如果匹配成功，<code>found=1</code></p><p>然后新定义一个<code>result</code>[][]用来批量保存匹配结果(YES/NO)，最后遍历<code>result</code>[][]。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char h[100], v[200];</span><br><span class="line">    char patterns[100][200];</span><br><span class="line">    int len_h, len_v, num;</span><br><span class="line">    int count = 0;</span><br><span class="line">    char result[100][10];</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        scanf(&quot;%s %s&quot;, v, h);</span><br><span class="line"></span><br><span class="line">        if(strcmp(v, &quot;0&quot;) == 0 &amp;&amp;strcmp(h, &quot;0&quot;) == 0 ) &#123;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PreProcess(h, v, &amp;len_h, &amp;len_v, &amp;num, patterns);</span><br><span class="line"></span><br><span class="line">        int i = 0, found = 0;</span><br><span class="line">        for (i; i &lt; num; i++) &#123;</span><br><span class="line">            if (kmp(h, patterns[i], len_v)) &#123;</span><br><span class="line">                found = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (found) &#123;</span><br><span class="line">            strcpy(result[count], &quot;YES&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            strcpy(result[count], &quot;NO&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int k = 0;</span><br><span class="line">    for(k; k &lt; count; k++)</span><br><span class="line">        puts(result[k]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411082322903.jpg" alt="img"></p><h3 id="Trouble-Shooting-v3">Trouble Shooting</h3><p>**问题：**在开始时仅仅对病毒DNA进行了扩充，但是没有找环状DNA所有可能出现的形式，导致KMP无法正确匹配。</p><p>**解决：**利用循环，寻找扩充后的病毒DNA的所有可能出现的形式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 生成所有可能的旋转形式</span><br><span class="line"></span><br><span class="line">  *num = *len_v;</span><br><span class="line"></span><br><span class="line">  int i = 0;</span><br><span class="line"></span><br><span class="line">  for(i; i &lt; *num; i++) &#123;</span><br><span class="line">     strncpy(patterns[i], v_double + i, *len_v); // 从v_double第i个位置复制len_v个字符到patterns[]里</span><br><span class="line">     patterns[i][*len_v]= &#x27;\0&#x27;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2024/11/08/Linux/"/>
      <url>/2024/11/08/Linux/</url>
      
        <content type="html"><![CDATA[<blockquote><p>鸟哥的Linux私房菜基础篇-第三版 人民邮电出版社</p></blockquote><h2 id="关系">关系</h2><h3 id="Unix与Linux的关系">Unix与Linux的关系</h3><p>Linux 是一个类似 Unix 的操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX（但并没有抄袭 UNIX 的源码），使得 Linux 在外观和交互上与 UNIX 非常类似。</p><h3 id="Linux、GNU、发行版的关系">Linux、GNU、发行版的关系</h3><p>打个比方操作系统就是一辆汽车。Linux是做汽车发动机的，也只生产发动机。有一家叫GNU的汽车零配件厂商，提供生产一整辆汽车的所有主要配件，只是它提供的发动机很差。各种发行版就是不同的汽车组装厂，它们自己不生主要的汽车配件，都是用GNU提供的配件——但发动机除外，发动机用的是Linux提供的。当然也有用其它发动机的，例如FreeBSD内核（kFreeBSD）。</p><p>GNU要求这些汽车组装厂，如果你除了内核以外其它配件基本都是用我生产的配件，你的名字中就应该带上我的标识。因此一些听话的厂商，例如Debian组装出来的用Linux发动机的汽车，就叫Debian GNU/Linux。事实上也有用FreeBSD发动机组装出来的Debian GNU/kFreeBSD——不过仅仅是6.0/7.0这两个版本提供过非官方的技术预览版，8.0开始就没再提供了。</p><p>当然，也有其它汽车厂商不用GNU的配件，自己生产配件自己组装汽车，但也用了Linux牌发动机的，例如安卓。根据GNU的这个命名方式，就应该叫Android/Linux。</p><p>GNU是一整个开源的操作系统，致力于以不含Unix代码的开源软件提供一个符合Unix标准的操作系统，所以GNU的全称是“GNU is Not Unix！”。</p><h2 id="Linux的规则与安装">Linux的规则与安装</h2><p>分时操作系统（Compatible Time-Sharing System，CTSS），可以让一台主机通过多个终端机（Terminal）连接进主机，利用主机的资源进行运算工作。</p><h3 id="Linux的主要安装流程">Linux的主要安装流程</h3><ol><li>调整启动媒体（BIOS）</li><li>选择安装结构与开机</li><li>选择语系数据</li><li>磁盘分区</li><li>引导装载程序、网络、时区设置与root密码</li><li>软件选择</li><li>安装后的首次设置</li></ol><p>linux rescue救援模式</p><h3 id="man-page">man page</h3><table><thead><tr><th>代号</th><th>代表内容</th></tr></thead><tbody><tr><td>1</td><td>用户在shell环境中可以操作的命令过可执行文件</td></tr><tr><td>5</td><td>配置文件或者是某些文件的格式</td></tr><tr><td>8</td><td>系统管理员可用的管理命令</td></tr></tbody></table><h3 id="忘记root密码">忘记root密码</h3><p>以单用户维护模式登录</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312112129015.jpg" alt="1702301348428"></p><h3 id="各硬件设备在Linux中的文件名">各硬件设备在Linux中的文件名</h3><table><thead><tr><th style="text-align:center">设备</th><th style="text-align:center">设备在Linux中的文件名</th></tr></thead><tbody><tr><td style="text-align:center">IDE硬盘</td><td style="text-align:center">/dev/hd[a-d]</td></tr><tr><td style="text-align:center">SCSI/SATA/USB硬盘</td><td style="text-align:center">/dev/sd[a-d]</td></tr><tr><td style="text-align:center">U盘</td><td style="text-align:center">与SATA相同</td></tr><tr><td style="text-align:center">软驱</td><td style="text-align:center">/dev/fd[0-1]</td></tr><tr><td style="text-align:center">打印机</td><td style="text-align:center">25针：/dev/lp[0-2]<br />USB: /dev/usb/lp[0-15]<br /></td></tr><tr><td style="text-align:center">鼠标</td><td style="text-align:center">/dev/usb/mouse[0-15]<br />PS2: /dev/psaux<br /></td></tr><tr><td style="text-align:center">当前鼠标</td><td style="text-align:center">/dev/mouse</td></tr><tr><td style="text-align:center">磁带机</td><td style="text-align:center">/dev/ht0<br />/dev/st0<br /></td></tr><tr><td style="text-align:center">CD ROM/DVD ROM</td><td style="text-align:center">/dev/cdrom</td></tr></tbody></table><h3 id="磁盘">磁盘</h3><p>Linux根据内核检测到的磁盘设备顺序进行命名</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312232020773.png" alt="image-20231223202023558"></p><p>磁盘的第一个扇区记录了两个重要的信息：</p><ul><li><strong>主引导分区（MBR）</strong>：可以安装引导加载程序的地方，由446bytes</li><li><strong>分区表（partition table）</strong>:记录整块硬盘分区的状态，有64bytes</li></ul><p>所谓的分区只是针对那个64bytes的分区表进行设置</p><p>磁盘默认的分区表只能写入四组分区信息</p><p>这四组分区信息称为主（Primary）或扩展分区</p><p>分区的最小单位为<strong>柱面（cylinder）</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312232021028.png" alt="image-20231223202125749"></p><p>扩展分区的目的是<strong>使用额外的扇区来记录分区信息</strong>，扩展分区本身不能被拿来格式化</p><p>由扩展分区继续切出来的分区称为<strong>逻辑分区</strong></p><ul><li>主分区与扩展分区最多只能有四个</li><li>扩展分区最多只能有一个（操作系统的限制）</li><li>逻辑分区是由扩展分区的持续切割出来的分区</li><li>能被格式化后作为数据访问的分区分为主分区与逻辑分区</li><li>在Linux中，IDE硬盘最多有59个逻辑分区（5号到63号，也就是/dev/hda5-63）,SATA有11个</li></ul><p>如果扩展分区被破坏，所有逻辑分区将会被删除，因为逻辑分区的信息都记录在扩展分区里</p><p>文件系统类型：</p><ul><li>ext2/ext3：是Linux使用的文件系统类型。因为ext3文件系统多了日志的记录，对于系统的恢复比较快速，建议使用</li><li>physical volume（LVM）：用来弹性调整文件系统大小的一种机制，可以让文件系统的大小改变而不改变原有的文件数据的内容</li><li>software RAID：利用软件仿真出磁盘阵列</li><li>swap：内存交换空间。由于swap并不会使用到目录树的挂载，所以swap不需要指定挂载点</li><li>vfat：同时被Linux和Windows支持的文件系统类型。</li></ul><p><strong>swap内存交换空间的功能</strong>：当有数据被存放在物理内存里面，但是这些数据又不是常被CPU所取用时，这些不常被使用的程序将会被放入硬盘的内存交换空间中，而将速度较快的物理内存空间释放出来给真正需要的程序使用。</p><h2 id="系统启动过程">系统启动过程</h2><p>计算机的开机流程</p><ul><li><p>BIOS：开机主动执行的韧体（写入到硬件上的一个软件程序），会认识第一个可开机的设备</p></li><li><p>MBR：第一个可开机设备的第一个扇区内的主引导分区快，内包含引导加载程序</p></li><li><p>Boot loader（引导加载程序）：一只可读取内核文件来执行的软件</p></li><li><p>内核文件：开始操作系统的功能</p></li><li><p>每个分区都拥有自己的启动扇区</p></li><li><p>实际可开机的内核文件是放置到各分区内的</p></li><li><p>loader可以直接指向或者是间接将管理权交给另一个管理程序</p></li><li><p>内核的引导。</p></li><li><p>运行 init。</p></li><li><p>系统初始化。</p></li><li><p>建立终端 。</p></li><li><p>用户登录系统。</p></li></ul><p><strong>整个启动流程图</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081707.png" alt="img"></p><h3 id="1-内核的引导">1.内核的引导</h3><p>打开电源后，首先进入BIOS开机自检，按照BIOS中设置的启动设备（通常为硬盘）来启动。</p><p>操作系统接管硬件后，首先读入<code>/boot</code>目录中的内核文件。</p><h3 id="2-运行init">2.运行init</h3><p>init 进程是系统所有进程的起点</p><p>没有这个进程，其他进程不能启动。</p><p>init 程序首先是需要读取配置文件 <code>/etc/inittab</code></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202310082326500.png" alt="image-20231008232657460"></p><h3 id="3-运行级别">3.运行级别</h3><p>程序的开机启动，在Windows中叫做<code>Service</code>(服务)，在Linux中叫做<code>daemon</code>(守护进程)</p><p>init的一大任务就是运行这些开机启动的程序。</p><p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做<code>runlevel</code>(<strong>运行级别</strong>)。</p><p>也就是说，启动时根据&quot;运行级别&quot;，确定要运行哪些程序。</p><p>7个运行级别</p><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录</li><li>运行级别2：多用户状态(没有NFS)</li><li>运行级别3：完全的多用户状态(有NFS)，登录后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登录后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init 6 # 让机器重启</span><br></pre></td></tr></table></figure><h3 id="4-系统初始化">4.系统初始化</h3><p><code>si::sysinit:/etc/rc.d/rc.sysinit</code>　它调用执行了<code>/etc/rc.d/rc.sysinit</code>，而rc.sysinit是一个bash shell的脚本</p><p><code>rc.sysinit</code>是每一个运行级别都要首先运行的重要脚本。</p><p>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l5:5:wait:/etc/rc.d/rc 5</span><br></pre></td></tr></table></figure><p>这一行表示以5为参数运行<code>/etc/rc.d/rc</code>，<code>/etc/rc.d/rc</code>是一个Shell脚本，它接受5作为参数，去执行<code>/etc/rc.d/rc5.d/</code>目录下的所有的rc启动脚本，<code>/etc/rc.d/rc5.d/</code>目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在<code>/etc/rc.d/init.d/</code>目录下。</p><p>而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p><h3 id="5-建立终端">5.建立终端</h3><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</p><p>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p><p>tty(Teletypes)，是Linux的终端</p><p>tty1-tty6文字界面登录，tty7图形界面登录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure><p>2、3、4、5的运行级别中都将以respawn方式运行mingetty程序</p><p>mingetty程序能打开终端、设置模式。</p><p>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p><p>action：表示对应登记项的process在一定条件下所要执行的动作。</p><p>具体动作有：</p><p>respawn：当process终止后马上启动一个新的</p><p>wait：当进入指定的runlevels后process才会启动一次，并且到离开这个runlevels终止</p><p>initdefault：设定默认的运行级别，即我们开机之后默认进入的运行级别，不能是0,6，你懂的</p><p>sysinit：系统初始化，只有系统开机或重新启动的时候，这个process才会被执行一次</p><p>powerwait：当init接收到电源失败信号的时候执行相应的process，并且如果init有进程在运行，会等待这个进程完成之后，再执行相应的process</p><p>powerfail：当init接收到电源失败信号的时候执行相应的process，并且如果init有进程在运行，不会等待这个进程完成，它会直接执行相应的process</p><p>powerokwait：电源已经故障，但是在等待执行对应操作的时候突然来电了就执行对应的process</p><p>powerfailnow：当电源故障并且init被通知UPS电源已经快耗尽执行相对应的process</p><p>ctrlaltdel：当用户按下ctrl+alt+del这个组合键的时候执行对应的process</p><p>boot：只有在引导过程中，才执行该进程，但不等待该进程的结束；当该进程死亡时，也不重新启动该进程</p><p>bootwait：只有在引导过程中，才执行该进程，并等待进程的结束；当该进程死亡时，也不重新启动该进程</p><p>off：如果process正在运行，那么就发出一个警告信号，等待20秒后，再通过杀死信号强行终止该process。如果process并不存在那么就忽略该登记项</p><p>once：启动相应的进程，但不等待该进程结束便继续处理/etc/inittab文件中的下一个登记项；当该进程死亡时，init也不重新启动该进程</p><p>process：表示启动哪个程序或脚本或执行哪个命令等</p><h3 id="6-用户登录系统">6.用户登录系统</h3><p>三种登录方式</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。</p><p>然后 login 会对用户名进行分析：如果用户名不是 root，且存在 <code>/etc/nologin</code> 文件，login 将输出 nologin 文件的内容，然后退出。</p><p>只有<code>/etc/securetty</code>中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。</p><p><code>/etc/usertty</code>文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p><h3 id="Linux关机">Linux关机</h3><p>正确的关机流程为：<code>sync &gt; shutdown &gt; reboot &gt; halt</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</span><br><span class="line"></span><br><span class="line">shutdown –h now 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt 关闭系统，等同于shutdown –h now 和 poweroff</span><br></pre></td></tr></table></figure><p>关机命令:</p><p><code>shutdown -h now</code></p><p><code>poweroff</code></p><p><code>init 0</code></p><p>重启命令：</p><p><code>shutdown -r now</code></p><p><code>reboot</code></p><p><code>init 6</code></p><h2 id="系统目录结构">系统目录结构</h2><h3 id="Linux安装模式下，磁盘分区的选择">Linux安装模式下，磁盘分区的选择</h3><p>目录树结构（directory tree）：整个目录树结构最重要的就是根目录”/“</p><p>文件系统与目录树的关系（挂载）</p><p><strong>挂载是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下。也就是说，进入该目录就可以读取该分区。</strong></p><p>主机硬盘的规划：</p><ol><li>最简单的分区法：仅分出根目录和内存交换空间(/&amp;swap),然后预留一些磁盘空间</li><li>根据用途，将需要较大容量，读写频繁的目录与根目录区分开</li></ol><h2 id="Linux的文件权限与目录配置">Linux的文件权限与目录配置</h2><ul><li>chown (change owner) ： 修改所属用户与组。</li><li>chmod (change mode) ： 修改用户的权限。</li><li>chgrp(change group)：修改文件所属组</li></ul><p>-R：进行递归的持续更改，即连同子目录下的所有文件都更改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-r--r--   1     root   root   1219     2月   5 2021    txcdn.sh</span><br></pre></td></tr></table></figure><p>​     文件权限     连接数    所有者  用户组   文件大小    最后修改日期               文件名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rwxrwx---</span><br></pre></td></tr></table></figure><p>文件类型：</p><ul><li>[d]代表目录</li><li>[-]文件</li><li>[l]连接文件</li><li>[b]设备文件里面的可供存储的接口设备</li><li>[c]设备文件里的串行端口设备</li></ul><p>第一组r(read可读)w(write可写)x(execute可执行)：文件所有者的权限</p><p>第二组rwx：文件所属用户组的权限</p><p>最后一组：其他人对此文件的权限</p><p>数字类型改变文件权限：</p><p>r:4</p><p>w:2</p><p>x:1</p><p>-rwxrwx—：[4+2+1] [4+2+1] [0+0+0]即770</p><p>符号类型改变文件权限：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：chmod u(ser)/g(roup)/o(thers)/a(ll) +(加入)/-(除去)/=(设置) r/w/x 文件或目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod a+w tesh.sh </span><br></pre></td></tr></table></figure><p>代表所有身份添加可写权限</p><h3 id="目录与文件的权限意义">目录与文件的权限意义</h3><ul><li>r（ead）：可读取此文件的实际内容，如读取文本文件的文字内容</li><li>w（rite）：可以编辑，新增或是修改文件的内容（但不含删除该文件）</li><li>e）x（ecute）：该文件具有可以被系统执行的权限</li></ul><p>要开放目录给任何人浏览，至少给予r和x的权限，但w权限不能随便赋予</p><p>权限对目录的重要性</p><ul><li>r：表示具有读取目录结构列表的权限</li><li>w：具有更改目录结构列表的权限，如新建或删除文件或目录，重命名目录或文件、转移文件目录位置</li><li>x：用户能否进入该目录成为工作目录</li></ul><h3 id="Linux文件种类与扩展名">Linux文件种类与扩展名</h3><p>普通文件（regular file）：</p><ul><li>纯文本文件（ASCII）：最多的一种文件类型，可用cat读取</li><li>二进制文件（binary）：执行的命令就是binary file</li><li>数据格式文件（data）：有些程序在运行的过程中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件</li></ul><p>目录（directory）</p><p>链接文件（link）：类似Windows系统下面的快捷方式</p><p>设备与设备文件（device）</p><ul><li>块（block）设备文件：就是一些存储数据，以提供系统随机访问的接口设备</li><li>字符（character）设备文件：一些串行端口的接口设备，如键盘鼠标等</li><li>套接字（sockets）：既然被称为数据接口文件，这种类型的文件通常被用在网络上的数据连接。我们可以启动一个程序来监听客户端，而客户端就可以通过socket来进行数据的通信。通常在/var/run下</li><li>管道（FIFO,pipe）：为了解决多个程序访问同一个文件所造成的错误类型。FIFO为first-in-first-out，第一个属性为[p]</li></ul><p>一个Linux文件能否被执行，与它的第一列的10个属性有关，和文件名无关。即只要具有x权限，文件就可以执行</p><p>但可以被执行和可以执行成功不同。比如一个.txt文件虽然具有x权限，但是它本身是无法执行的。</p><p>Linux文件长度限制：</p><p>使用默认的ext2/ext3文件系统时，针对文件的文件名长度限制：</p><ul><li>单一文件或目录的最大容许文件名为255字符</li><li>包含完整路径名称与目录（/）的完整文件名为4096个字符</li></ul><h3 id="Linux目录配置">Linux目录配置</h3><p>Linux目录标准配置：FHS（Filesystem Hierarchy Standard），其主要目的是为了希望用户可以了解到已安装的软件通常放在哪个目录下</p><p>FHS依据文件系统使用的频繁与是否允许用户随意改动，将目录定义成为四种交互作用的形态：</p><table><thead><tr><th></th><th>可分享的（shareable）</th><th>不可分享的（unshareable）</th></tr></thead><tbody><tr><td><strong>不变的（static）</strong></td><td>/usr</td><td>/etc</td></tr><tr><td></td><td>/opt</td><td>/boot</td></tr><tr><td><strong>可变动的（variable）</strong></td><td>/var/mail</td><td>/var/run</td></tr><tr><td></td><td>/var/spool/news</td><td>/var/lock</td></tr></tbody></table><ul><li>可分享的：可以分享给其它系统挂载使用的目录</li><li>不可分享的：自己机器上的设备文件或者是与程序有关的socket文件</li><li>不变的：有些数据是不会经常变动的，如函数库，文件说明文件等</li><li>可变动的：经常改变的数据，如登录文件、新闻组等</li></ul><p>FHS针对目录树架构仅仅定义出三层目录下面应该放置什么数据：</p><ul><li>root根目录：与开机系统有关</li><li>/usr：（UNIX software resource）：<strong>与软件安装/执行有关</strong></li><li>/var（variable）：与系统运行过程有关</li></ul><p>根目录的意义与内容：</p><p>所有的目录由根目录衍生而出，同时根目录也与开机、还原、系统修复等操作有关</p><p><strong>FHS定义根目录的子目录</strong></p><ul><li>/bin：放置了在单用户维护模式下还能够被操作的命令</li><li>/boot：放置开机会使用到的文件，包括Linux内核文件以及与开机所需配置文件等</li><li>/dev：任何设备与接口设备都是以文件形式存在于该目录下</li><li>/etc：系统主要的篇日志文件几乎都放置在这个目录</li></ul><p>FHS建议不要放置可执行文件在这个目录中</p><ul><li>/etc/init.d：所有服务的默认启动脚本都存放在这里</li><li>/etc/xinetd.d：super darmon管理的各项服务的配置文件目录</li><li>/etc/X11：于X Window有关的各种配置文件</li><li>/home：系统默认用户主文件夹。一般创建一个一般用户账号时，默认的用户主文件夹都会规范到这里<ul><li>~：代表目前这个用户的主文件夹</li><li>~abc：代表用户abc 的主文件夹</li></ul></li><li>/lib：放置开机时会使用的函数库，以及在/bin和/sbin下面的命令会调用的函数库</li><li>/media：放置可删除的设备</li><li>/mnt：需要挂载的设备</li><li>/opt：第三方软件放置目录</li><li>/root</li><li>/sbin：放置开机过程中所需要的，里面包括开机、修复、还原系统所需要的命令。<br>至于某些服务器软件程序，一般放置在/usr/sbin。<br>本机自行安装的软件所产生的系统执行文件，则放置在/usr/local/sbin</li><li>/srv：网络服务启动后，这些服务所需要取用的数据目录</li><li>/tmp：暂时放置文件的地方</li></ul><p><strong>其他重要的目录</strong></p><ul><li>/lost+found：使用标准ext2/ext3文件系统格式才会产生的目录，目的在于当文件系统发生错误时，将一些丢失的片段放置在这个目录下</li><li>/proc：该目录本身是一个虚拟文件系统，它放置的数据都在<strong>内存</strong>中，例如系统内核、进程（process）、外部设备的状态以及网络状态等，不占任何硬盘空间</li><li>/sys：于/proc相似，主要记录于内核相关的信息</li></ul><p>/usr的意义与内容：</p><ol><li>/usr可以分享给局域网内的其他主机使用</li><li>该目录放置”UNIX操作系统软件资源“的目录</li><li>所有系统默认的软件（distriburion发布者提供的软件）</li></ol><p>应放置的文件内容</p><ul><li>/usr/X11R6：为X Window 系统重要数据所放置的目录</li><li>/usr/bin：绝大部分用户可使用的命令都放置在这里</li><li>/usr/include：C/C++等程序语言的头文件与包含文件放置处</li><li>/usr/lib：包含个应用软件的函数库、目标文件，以及不被一般用户惯用的执行文件或脚本</li><li>/usr/local：系统管理员在本机自行安装自己下载的软件，建议安装到此目录</li><li>/usr/sbin：非系统正常运行所需要的系统命令。</li><li>/usr/share：放置共享文件的地方</li><li>/usr/src：一般源码建议放置在这里，src由source的意思，至于内核源码放在/usr/src/linux</li></ul><p>/var的意义与内容：</p><ol><li>主要针对常态性变动的文件，包括缓存（cache）、登录文件（log）以及某些软件运行所产生的文件</li></ol><p>应放置的文件内容：</p><ul><li>/var/cache：应用程序本身运行产生的缓存</li><li>/var/lib：程序本身执行的过程中，需要使用到的数据文件放置的目录。例如MySQL的数据库放置在/var/lib/mysql</li><li>/var/lock：某些设备或是文件资源一次只能被一个应用程序所占用。例如刻录机正在刻录一块光盘，只能确保一个人在这块光盘上写入数据，所以当第一个人使用刻录机时该刻录机就会被上锁</li><li>/var/log：登录文件放置的目录。如/var/log/wtmp（记录登录者的信息）</li><li>/var/mail：放置个人电子邮件信箱的地方</li><li>/var/run：某些程序启动后，会将他们的PID放置在此</li><li>/var/spool：通常放置一些队列数据</li></ul><p>目录树（directory tree）</p><p>特性：</p><ul><li>起始点为根目录’/，root‘</li><li>每一个目录不只能使用本地端的文件系统，也可以使用网络上的文件系统。例如NFS （Network File System）服务器挂载某特定目录</li><li>每一个文件在此目录树中的文件名时独一无二的</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312142132588.jpg" alt="1702560741113"></p><p><strong>绝对路径与相对路径</strong></p><ul><li>绝对路径（absolute）：由根目录开始写起的文件名或目录名称</li><li>相对路径（relative）：相对于目前路径的文件名写法。</li><li>.：代表当前目录，也可以使用./表示</li><li>…：代表上一层目录，也可以用…/表示</li><li>-：代表前一个工作目录</li><li>~：代表”目前用户身份“所在的主文件夹</li></ul><h2 id="Linux文件与目录管理">Linux文件与目录管理</h2><h3 id="关于执行文件路径的变量：-PATH">关于执行文件路径的变量：$PATH</h3><ul><li>不同身份与用户默认的PATH不同，默认能够随意执行的命令也不同</li><li>PATH可以修改，一般用户可以通过修改PATH来执行某些位于/sbin或/usr/bin下的命令来查询</li><li>使用绝对或相对历经直接执行某个命令的文件名来执行</li><li>命令应该放在正确的目录下，执行才会方便</li></ul><p>cp（复制）</p><p>-a：相当于pdr的意思</p><p>-p：连同文件的属性一起复制</p><p>-i：若目标文件已经存在，在覆盖时会先询问操作的进行</p><p>-r：递归持续复制</p><h3 id="文件内容查阅"><strong>文件内容查阅</strong></h3><ul><li>cat：从第一行开始显示文件内容</li><li>tac：从最后一行开始显示</li><li>nl：显示的时候顺便显示行号</li><li>more：一页一页地显示</li><li>less：与more类似，可以往前翻页</li><li>head：只看头几行</li><li>tail：只看结尾几行</li><li>od：以二进制方式读取内容</li></ul><p>cat（concatenate）：</p><p>-n：打印出行号，连同空白行也会有行号</p><p>-b：列出行号，仅仅针对非空白行</p><p>head：</p><p>-n：后面接数字，代表显示几行</p><p><strong>三个时间的意义</strong></p><ul><li>modification time（mtime）<br>当该文件的”内容数据“更改时，就会更新这个时间<br>内容数据指的是文件的内容，而不是文件的属性或权限</li><li>status time（ctime）<br>该文件的”状态（status）“改变。即权限与属性被更改，会更新这个时间</li><li>access time（atime）<br>该文件的内容被取用时。即用cat读取文件时，就会更新这个时间。</li></ul><h3 id="文件与目录的默认权限与隐藏权限-umask、chattr、lsttr">文件与目录的默认权限与隐藏权限 umask、chattr、lsttr</h3><p><strong>文件默认权限umask：目前用户在新建文件或目录时候的权限默认值</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@orangepizero3:~# umask</span><br><span class="line">0022</span><br><span class="line">root@orangepizero3:~# umask -S</span><br><span class="line">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure><p>默认情况如下：</p><ul><li>用户创建文件时默认没有x权限，为666</li><li>用户创建目录，由于x是与是否可以进入此目录有关，因此所有权限开放，为777</li></ul><p>umask的分数指“该默认值需要减掉的权限”，第一个0即第一组是特殊权限用，第三个2代表group被拿走了w权限</p><p>假设目前的umask为003，请问该umask下，新建的文件与目录权限是什么？</p><p>答：umask代表others被拿走了w和x权限</p><p>新建的文件：（-rw-rw-rw-）- (---------wx) = -rw-rw-r–</p><p>新建的目录：（drwxrwxrwx） -（---------wx） = drwxrwxr–</p><p><strong>文件隐藏属性chattr，lsattr</strong>（在Ext2/Ext3文件系统中使用）</p><ul><li><p>chattr（设置文件的隐藏属性）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chattr [+-=]参数 文件或目录名称</span><br></pre></td></tr></table></figure><p>a：文件只能增加数据，而不能删除也不能修改数据，只有root才可以设置</p><p>i：可以让一个文件不能被删除、改名、设置连接也无法写入或添加数据</p></li></ul><p><strong>文件特殊权限：SUID,SGID,SBIT</strong></p><ul><li>SUID：代表当用户执行此二进制程序时，在执行过程中用户会暂时具有程序所有者的权限</li><li>SGID：代表用户在这个目录下面新建的文件用户组都会与该目录组名相同</li><li>SBIT：代表在该目录下用户创建的文件只有自己和root能够删除</li></ul><p><a href="https://blog.csdn.net/csdn_leidada/article/details/122223958">linux 一文带你彻底搞懂特殊权限位suid，sgid，sticky_suid和sgid的作用分别是什么-CSDN博客</a></p><ul><li><p>SetUID（4）</p><ul><li>可以绕过基础权限体系，可以修改没有权限的文件</li><li>当s出现在x上时，代表具有SUID。例如-rwsx-xr-x</li><li>SUID权限仅对二进制程序有效，不能够用在shell script上</li><li>执行者对于该程序需要具有x的可执行权限</li><li>本权限仅在执行能否该程序的过程中有效</li><li>执行者将具有该程序所有者的权限</li><li><strong>理解：/etc/shadow保存了所有用户的账号和密码，user用户是无法访问这个文件的，但是user用户可以通过“passwd”更改自己的密码</strong></li><li>由此可知：user对于/usr/bin/passwd具有x权限，但passwd的拥有者是root，<strong>user在执行passwd的过程中，会暂时获得root的权限</strong>。/etc/shadow可以被user所执行的passwd所修改</li></ul></li><li><p>SetGID（2）</p><ul><li>SGID可以针对文件或目录设置</li><li>唯一区别是suid获得命令所属用户的身份和权限，而sgid是获得命令所属用户组的身份和权限</li><li>SGID对二进制程序有用</li><li>程序执行者对于该程序来说，需要具备x的权限</li><li>用户对于此目录具有r与x的权限时，该用户能够进入此目录</li><li>用户在此目录下的有效用户组（effective group）将会变成该目录的用户组</li><li>若用户在此目录下具有w权限，则用户所创建的新文件的用户组与此目录的用户组相同</li><li><strong>理解</strong>：locate命令通过读取<code>/var/lib/mlocate/mlocate.db</code>查询命令二进制文件位置，文件权限对其他用户来说是<code>---</code>按道理来说其他用户无法使用locate命令，事实上可以使用，原因是locate 被设置了sgid**</li></ul></li><li><p>Sticky Bit（1）</p><ul><li><p>只针对目录有效</p><p>SBIT对于目录的作用：</p></li><li><p>当用户对于此目录具有w，x权限，即具有写入的权限</p></li><li><p>当用户在该目录下创建文件或目录时，仅有自己与root才有权利删除该文件</p></li></ul></li></ul><h3 id="命令与文件的查询">命令与文件的查询</h3><p>查看文件类型：file</p><p><strong>脚本文件名的查询</strong></p><p>which（寻找”执行文件“）</p><p><strong>文件名的查找</strong></p><ul><li>whereis（寻找特定文件）<br>find直接查找硬盘，查找时间长<br>Linux系统会将系统内所有的文件都记录在一个数据库文件<code>/var/lib/mlocate</code>里面，whereis和locate从数据库文件里查找</li><li>locate</li></ul><p>​updatedb：根据/etc/updatedb.conf的设置区查找系统硬盘内的文件名，并更新/var/lib/mlocate内的数据库文件</p><p>​根据/var/lib/mlocate内的数据库记载，找出用户输入的关键字文件名</p><ul><li><p>find</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-mtime n代表在n天之前的”一天之内“被更改过的文件</span><br><span class="line">-mtime +n列出在n天之前（不含n天本身）被更改过的文件名</span><br><span class="line">-mtime -n列出在n天之内（含有n天本身）被更改过的文件名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -mtime 0</span><br><span class="line"># 代表从现在开始到24小时之前</span><br><span class="line">find / -mtime 3</span><br><span class="line"># 3天前的24小时内</span><br></pre></td></tr></table></figure><ul><li>+4代表大于等于5天前的文件名</li><li>-4代表小于等于4天内的文件名</li><li>4则代表4-5那一天的文件名</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-perm mode查找文件权限刚好等于mode的文件</span><br><span class="line">-perm -mode 必须要全部包含mode的文件</span><br><span class="line">-perm +mode 包含任意mode的权限</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-exec -command：-exec -it后边可以再接其他的命令来处理查找结果</span><br></pre></td></tr></table></figure><h3 id="权限与命令间的关系">权限与命令间的关系</h3><p>命令在什么样的权限下才能够执行：</p><ul><li><p>让用户**能够进入某目录成为”可工作目录”**的基本权限是什么</p><ul><li>可使用的命令：cd</li><li>目录所需权限：用户对于这个目录至少需要具有x的权限</li><li>额外需求：如果用户想要在这个目录内利用ls查阅文件名，则此用户还需要r的权限</li></ul></li><li><p>用户<strong>在某个目录读取一个文件</strong>的基本权限是什么</p><ul><li>可使用的命令：例如cat、more</li><li>目录所需要权限：至少就有x权限</li><li>文件所需权限：用户对文件至少具有r权限</li></ul></li><li><p>用户<strong>可以修改一个文件</strong>的基本权限</p><ul><li>可使用的命令：vim、nano</li><li>目录所需权限：x</li><li>文件所需权限：r、w</li></ul></li><li><p><strong>创建一个文件</strong>的基本权限</p><p>目录所需权限：w，x重点是w</p></li><li><p><strong>进入目录并执行该目录下的某个命令</strong></p><ul><li>目录所需权限：x</li><li>文件：x</li></ul></li></ul><h2 id="Linux磁盘与文件系统管理">Linux磁盘与文件系统管理</h2><h3 id="认识EXT2文件系统">认识EXT2文件系统</h3><p>因为每种操作系统发所设置的文件属性和权限不同，所以需要“格式化”</p><p>通常我们把一个可挂载的数据为一个文件系统而不是一个分区</p><p>Linux的正规文件系统为Ext2（Linux second extended file system）</p><p>文件系统如何运行：Linux操作系统会把数据放在不同的块中，如下</p><ul><li><strong>super block：记录此文件系统的整体信息，包括inode/block的总量、使用量、剩余量</strong></li><li><strong>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码</strong></li><li><strong>block：实际记录文件的内容，若文件太大时会占用多个block</strong></li></ul><p><strong>索引式文件系统（indexed allocation）</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312191853599.png" alt="image-20231219185344417"></p><p>inode向下寻找对应的block</p><p><strong>FAT格式</strong></p><p>一般用于U盘（闪存）</p><p>这种文件格式没有inde存在，每个block号码都记录在前一个block中。这种文件系统没办法一口气就知道四个block号码，需要一个一个地将block读出后，才会知道下一个block在何处</p><p><strong>碎片整理</strong></p><p>需要碎片整理的原因就是block太过于离散，此时文件读取的性能就会变得很差。这个时候可以通过碎片整理将同一个文件所属的block汇合在一起，这样数据的读取会比较容易。FAT的文件系统需要经常碎片整理一下。</p><p>由于Ext2是索引式文件系统，基本上不太需要进行碎片整理的。但如果文件系统使用太久，经常删除、编辑、新增文件时，那么还是可能会造成文件数据太过于离散的问题。</p><h4 id="inode">inode</h4><p>文件系统一开始就将inode与block规划好，除非重新格式化（或者利用resize2fs）等命令更改文件系统大小，否则inode与block固定后就不再变动</p><p>如果文件系统太大，inode与block放在一起不容易管理</p><p>所以Ext2文件系统在格式化的时候基本上是区分为**多个块组（block group）**的，每个块组都有独立的inode/block/superblock系统。</p><p>在整体的规划当中，<strong>文件系统最前面有一个启动扇区（boot sector）</strong>，这个启动扇区可以安装引导装载程序。这样我们就可以将不同的boot loader安装到个别的文件系统最前端，而不用覆盖整块硬盘唯一的MBR，这样也能制作出多重引导的环境。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312191858739.png" alt="image-20231219185816632"></p><p>每一块组的六个主要内容：</p><ul><li><p>data block（数据块）</p><p>用来放置文件的内容。在Ext2文件系统中所支持的block大小由1KB,2KB以及4KB三种而已。由于block大小的区别导致该文件系统能够支持的最大磁盘容量与单一文件容量并不相同。因为block大小而产生的Ext2文件系统限制如下表、</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312191904468.png" alt="image-20231219190408362"></p><ul><li>原则上，block的大小与数量在格式化完就不能够再改变了（除非重新格式化）</li><li>每个block内最多只能够放置一个文件的数据</li><li>如果文件大于block的大小，则一个文件会占用多个block数量</li><li>若小于，则该block的剩余空间就不能被使用了</li><li>所以进行文件系统格式化前，需要想好文件系统预计使用的情况</li></ul></li><li><p>inodetable（inode表格）</p><ul><li>inode包含下列文件数据：</li><li>该文件的访问模式（r/w/x）</li><li>该文件的所有者与组（o/g）</li><li>该文件的大小</li><li>该文件创建或状态改变的时间（ctime）、最近一次的读取时间（atime）、最近修改时间（mtime）</li><li>定义文件特性的标志（flag），如SetUID</li><li>该文件真正内容的指向（pointer）</li><li>inode的特色：</li><li>每个inode大小固定为128bytes</li><li>每个文件仅仅会占用一个inode</li><li><strong>文件系统能够创建的文件数量于inode的数量有关</strong></li><li>系统读取文件时先找到inode，并分析inode所记录的权限与用户是否符合，若符合才能够开始实际读取block的内容</li><li>为了让inode能记录更多的信息，系统经inode记录block号码的区域定义为12个直接、一个间接、一个双间接与一个三间接记录区</li><li>所谓的间接就是再拿一个block来当作记录block号码的记录区，如果文件太大，就会使用间接的block来记录编号。如果文件持续长大，那么就会利用所谓的双间接。</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312192032879.png" alt="image-20231219203242788"></p></li><li><p>Superblock（超级块）</p><ul><li>Superblock是记录整个文件系统相关信息的地方</li><li>主要记录的信息：</li><li>block与inode的总量</li><li>未使用与已使用的inode/block数量</li><li>block与inode的大小（block为1K,2K,4K，inode为128bytes）</li><li>文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘（fsck）的时间等文件系统的相关信息</li><li>一个valid bit的数值，若文件系统已被挂载，则valid bit为0。若未被挂载，则valid bit为1</li><li>文件系统的基本信息都写在这里</li><li>每个block group可能都由superblock。但是我们也说一个文件系统应该仅有一个superblock，后续的block group中的superblock可以用作第一个block group内superblock的备份</li></ul></li><li><p>File system Description（文件系统描述说明）</p><ul><li>可以描述每个block group开始与结束的block号码，以及说明每个区段分别介于哪一个block号码之间。可以使用dumpe2fs来查看</li></ul></li><li><p>block bitmap（块对照表）</p><ul><li>从block bitmap中可以知道哪些block是空的</li><li>如果要删除某些文件时，那么那些文件原本占用的block号码就要释放出来，此时在block bitmap当中相对应到该block号码的标志就得要修改称为“未使用中”</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos ~]# dumpe2fs /dev/vda1</span><br><span class="line">dumpe2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line">Last mounted on:          /</span><br><span class="line">Filesystem UUID:          4b499d76-769a-40a0-93dc-4a31a59add28</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash </span><br><span class="line">Default mount options:    user_xattr acl#默认挂载的参数</span><br><span class="line">Filesystem state:         clean#代表文件系统没有问题</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS type:       Linux</span><br><span class="line">Inode count:              3276800#inode的总数</span><br><span class="line">Block count:              13106939</span><br><span class="line">Reserved block count:     545205</span><br><span class="line">Free blocks:              4098#还有多少block可用</span><br><span class="line">Free inodes:              2536065</span><br><span class="line">First block:              0</span><br><span class="line">Block size:               4096</span><br><span class="line">Fragment size:            4096</span><br><span class="line">Group descriptor size:    64</span><br><span class="line">Reserved GDT blocks:      1017</span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line">Inodes per group:         8192</span><br><span class="line">Inode blocks per group:   512</span><br><span class="line">Flex block group size:    16</span><br><span class="line">Filesystem created:       Thu Mar  7 14:38:36 2019</span><br><span class="line">Last mount time:          Thu Nov 23 20:59:28 2023</span><br><span class="line">Last write time:          Thu Nov 23 20:59:25 2023</span><br><span class="line">Mount count:              66</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Thu Mar  7 14:38:36 2019</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          1653 GB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line">Inode size:               256</span><br><span class="line">Required extra isize:     28</span><br><span class="line">Desired extra isize:      28</span><br><span class="line">Journal inode:            8</span><br><span class="line">First orphan inode:       4077</span><br><span class="line">Default directory hash:   half_md4</span><br><span class="line">Directory Hash Seed:      58cbc593-e8e9-4c19-9dcf-645326b54c80</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Journal features:         journal_incompat_revoke journal_64bit</span><br><span class="line">日志大小:             128M</span><br><span class="line">Journal length:           32768</span><br><span class="line">Journal sequence:         0x01d170a5</span><br><span class="line">Journal start:            21328</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Group 0: (Blocks 0-32767) [ITABLE_ZEROED]</span><br><span class="line">  Checksum 0x2c51, unused inodes 0</span><br><span class="line">  主 superblock at 0, Group descriptors at 1-7</span><br><span class="line">  保留的GDT块位于 8-1024</span><br><span class="line">  Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041)</span><br><span class="line">  Inode表位于 1057-1568 (+1057)</span><br><span class="line">  20230 free blocks, 0 free inodes, 1011 directories</span><br><span class="line">  可用块数: 11776-11903, 11959-13311, 13648-14005, 14016-14254, 14336-16062, 16087-16127, 16384-32767</span><br><span class="line">  可用inode数: </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上部分是superblock，下部分是blockgroup</p></li></ul><p>​Group0所占用的block号码从0到32767，第0号里存放superblock</p><ul><li><p>inode bitmap （inode对照表）</p><p>与block bitmap类似，用来记录使用与未使用的inode号码</p></li></ul><h4 id="与目录树的关系">与目录树的关系</h4><p>目录与文件在Ext2文件系统当中记录数据的方式</p><ul><li><p>目录</p><p>新建目录时，Ext2会分配一个inode与至少一块block给该目录。</p><p>inode记录该目录的相关权限与属性，并可以记录分配到的那块block号码</p><p>block记录在这个目录下的文件名与该文件名占用的inode号码数据。</p><p>使用<code>ls -i</code>查看目录内文件所占用的inode号码</p><p>目录并不会只占用一个block，如果文件太多导致一个block无法容纳下所有文件名与inode对照表时，Linux会给予该目录多一个block来继续记录相关的数据</p></li><li><p>文件</p><ul><li>新建文件时，ext2会分配一个inode与相对于该文件大小的block数量给该文件</li></ul><p>例如：我的一个block为4KB，新建一个100KB的文件时，Linux将分配一个inode与25个block来存储该文件。由于inode仅有12个直接指向，因此还要多一个block来作为块号码的记录</p></li><li><p>目录树的读取</p><p>目录树从根目录读起，因此系统通过挂载的信息可以找到挂载点的inode号码（通常一个文件系统的最顶层inode号码会由2号开始），此时就能够得到根目录的inode内容，并依据该inode读取根目录的block内的文件名数据，再一层一层地往下读到正确地文件名。</p></li></ul><p>​</p><pre><code>[root@www ~]# ll -di / /etc /etc/passwd 2 drwxr-xr-x 23 root root 4096 Sep 22 12:09 /1912545 drwxr-xr-x 105 root root 12288 Oct 14 04:02 /etc1914888 -rw-r--r-- 1 root root 1945 Sep 29 02:21 /etc/passwd</code></pre><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312192154072.png" alt="image-20231219215456906"></p><ul><li>文件系统大小与磁盘读取性能<ul><li>当一个文件系统规划的很大时，由于硬盘上面的数据经常变动，所以整个文件系统上面的文件通常无法连续到一起（block号码不会连续的意思），而是填入式地将数据填入没有被使用的block当中。如果文件写入的block真的分的很散，此时就会有所谓的文件数据离散问题发生</li><li>数据离散时，磁头得在整个文件系统中来来回回地频繁读取。可以将整个文件系统内的数据全部复制出来，将该文件系统重新格式化后再将数据复制回去</li><li>如果文件系统真的特别大，那么当一个文件分别记录在这个文件系统的最前面与最后面的block号码中，此时会造成硬盘的机械手臂移动幅度过大，也会造成数据读取性能低。而且磁头在搜寻整个文件系统中，也会花费比较多的时间。</li></ul></li></ul><h4 id="Ext2-Ext3文件的访问与日志文件系统的功能">Ext2/Ext3文件的访问与日志文件系统的功能</h4><p>新增一个文件的系统的行为：</p><ul><li>先确定用户对于与添加文件的目录是否具有w与x权限，有的话才能添加</li><li>根据inode bitmap找到没有使用的inode号码，并将新文件的权限/属性写入</li><li>根据block bitmap找到没有使用中的block号码，并将实际的数据写入block中，并且更新inode的block指向数据</li><li>将刚才写入的inode与block数据同步更新inode bitmap与block bitmap，并更新superblock的内容</li></ul><p><strong>一般把inode table与data block称为数据存放区域，至于其他例如super block、block bitmap与inode bitmap等区段就被称为meta data（中间数据）</strong></p><p><strong>数据的不一致（Inconsistent）状态</strong></p><ul><li>当出现不明原因导致系统中断时，写入的数据仅有inode table和data block，最后一个同步更新中间数据的步骤并没有做完，此时meta data的内容与实际数据存放不一致</li></ul><p><strong>日志文件系统（Journaling file system）</strong> Ext3后的文件系统才加入</p><ul><li>为解决数据不一致状态，文件系统划分出专门的一个块用来记录写入或修订文件时的步骤</li><li>预备：当系统写入文件时，会现在日志记录块中记录某个文件准备要写入的信息</li><li>实际写入：开始写入文件的权限和数据，开始更新metea data</li><li>结束：完成数据与meta data的更新后，在日志记录块当中完成该文件的记录</li></ul><p>Ext3较于Ext2的优化</p><ul><li>可利用性高：可以让系统中止到快速重新复原而不是持续地让e2fsck执行长时间的修复</li><li>数据完整性：Ext3的日志式条件可以避免数据损毁的可能</li><li>速度：因为3的日志使硬盘磁头的移动能够更有效地进行</li></ul><h4 id="Linux文件系统的操作">Linux文件系统的操作</h4><p>Linux使用<strong>异步处理</strong>来解决编辑大文件频繁操作硬盘导致的低效率问题</p><p>当系统加载一个文件到内存后，如果文件未被改动，则内存区段的文件数据会被设置为clean。当内存中的文件数据被更改过，此时会被设置为Dirty。此时所有的操作还都在内存中执行，并没有写入到磁盘中。系统会不定时地将内存中设置为Dirty地数据写回磁盘，以保持磁盘与内存数据的一致性。</p><p><strong>Linux文件系统与内存的关系</strong></p><ul><li>系统会将常用的文件数据放置在主存储器的缓冲区，以加速文件系统的读写</li><li>Linux的物理内存最后都会被用光</li><li>可以使用sync来强迫内存中设置为Dirty的文件回写到磁盘中</li><li>正常关机时，关机命令会主动调用sync来将内存的数据回写入磁盘内</li><li>不正常关机时，由于数据未回写到磁盘中，因此重新启动后会花费大量时间进行磁盘检验，甚至导致文件系统的损坏</li></ul><h4 id="挂载点（mount-point）的意义">挂载点（mount point）的意义</h4><p>将文件系统与目录树结合的操作称为挂载</p><p>同一个文件系统的某个inode只会对应到一个文件内容而已（因此一个文件占用一个inode），因此可以通过判断inode号码来确认不同文件名是否为相同的文件</p><h4 id="其他Linux支持的文件系统与VFS">其他Linux支持的文件系统与VFS</h4><ul><li>传统文件系统：ext2/minix/MS-DOS微软磁盘操作系统/FAT（用vfat模块）/iso9660（光盘）等</li><li>日志文件系统：ext3/ReiserFS（适用于更小型文件）/Windows‘NTFS/IBM’sJFS/SGI’sXFS</li><li>网络文件系统：NFS/SMBFS</li></ul><p><strong>Linux VFS</strong></p><p>整个Linux的系统都是通过一个名为Virtual Filesystem Switch（虚拟文件系统VFS）的内核功能去读取文件系统的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看目前系统已经加载到内存中支持的文件系统</span><br><span class="line">cat /proc/filesystems </span><br></pre></td></tr></table></figure><p>整个Linux认识的文件系统其实都是VFS在进行管理，用户并不需要知道每个分区上头的文件系统是什么，VFS会主动帮助我们做好读取的操作</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312222056389.png" alt="image-20231222205613229"></p><h3 id="文件系统的简单操作">文件系统的简单操作</h3><h4 id="磁盘与目录的容量：df，du">磁盘与目录的容量：df，du</h4><ul><li>df：列出文件系统的整体磁盘使用量</li><li>du：评估文件系统的磁盘使用量（常常用于评估目录所占容量）</li></ul><p><strong>df</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h：以易读的GB，MB，KB格式显示</span><br><span class="line">-i：不用硬盘容量，而以inode的数量显示</span><br><span class="line">-a：列出所有的文件系统</span><br></pre></td></tr></table></figure><p>df的读取范围在Super block内</p><p>/dev/shm目录，其实是利用内存虚拟出来的磁盘空间</p><p><strong>du</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s：列出总量，而不列出每个个别的目录占用容量</span><br><span class="line">-S：不包括子目录下的总计</span><br></pre></td></tr></table></figure><h4 id="连接文件：ln">连接文件：ln</h4><p>一种是类似Windows的快捷方式功能的文件，可以快速连接到目标文件或目录。另一种是通过inode连接来产生新文件名，而不是产生新文件</p><h5 id="硬链接（hard-link）"><strong>硬链接（hard link）</strong></h5><ul><li>每个文件都会占用一个inode，文件内容由inode的记录来指向</li><li>想要读取该文件，必须要经过目录记录的文件名来指向到正确的inode号码才能读取</li><li>文件名只与目录有关，文件内容与inode有关</li><li>hard link只是在某个目录下新建一条文件名连接到某inode号码的关联记录</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312222133663.png" alt="image-20231222213320531"></p><p>上图表示用户可以通过1或2的目录inode指定的block找到两个不同的文件名，而不管是用哪个文件名都可以指到real那个inode去读取最终数据。</p><p>这两个文件虽然文件名不同，但是他们的inode号码相同，其实是“一模一样”的文件</p><p><strong>如果将任何一个文件名删除，其实inode与block都还是存在的。此时访问另外一个文件名也能读取到正确文件内容。不论用哪个文件名编辑，最终的结果都会写入到相同的inode与block中</strong></p><p>hard link设置连接文件时，磁盘的空间与inode数目都不会改变。它只是在某个目录下的block中多写入了一个关联数据，不增加inode也不耗用block</p><p><strong>限制</strong></p><ul><li>不能跨文件系统</li><li>不能连接到目录</li></ul><h5 id="符号连接sysbolic-link">符号连接sysbolic link</h5><p>就是在创建一个独立的文件，而这个文件会让数据的读取指向它连接的那个文件的文件名。相当于一种“快捷方式”</p><p><strong>只是利用了文件来作为指向的操作。所以当源文件删除后，快捷方式自然会打不开</strong></p><p>inode号码不同，这两个文件是完全独立存在的。而且连接文件的重要内容就是它会写上目标文件的文件名</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312222152209.png" alt="image-20231222215243148"></p><p>由symbolic link所创建的文件为一个独立的新的文件，所以会占用掉inode与block</p><p>软连接可以连接目录</p><p><strong>ln</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s：如果不加任何参数就进行连接，那就是hard link，加-s就是sysbolic link</span><br></pre></td></tr></table></figure><p>软连接改连接文件，源文件也会跟着变动。当软连接连接到目录时，删除目录会影响源目录。</p><p><strong>关于目录的连接数量</strong></p><p>当我们新建一个目录时，新的目录的连接数为2，而上层目录的连接数则会增加1.</p><h4 id="磁盘的分区、格式化、检验与挂载">磁盘的分区、格式化、检验与挂载</h4><h5 id="磁盘分区：fdisk">磁盘分区：fdisk</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l：输出后面接的设备的所有分区内容</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@test:~# fdisk /dev/sda</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.37.2).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">This disk is currently in use - repartitioning is probably a bad idea.</span><br><span class="line">It&#x27;s recommended to umount all file systems, and swapoff all swap</span><br><span class="line">partitions on this disk.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help): m</span><br><span class="line"></span><br><span class="line">Help:</span><br><span class="line"></span><br><span class="line">  GPT</span><br><span class="line">   M   enter protective/hybrid MBR </span><br><span class="line"></span><br><span class="line">  Generic</span><br><span class="line">   d   delete a partition # 删除一个分区</span><br><span class="line">   F   list free unpartitioned space</span><br><span class="line">   l   list known partition types</span><br><span class="line">   n   add a new partition # 新增分区</span><br><span class="line">   p   print the partition table # 在屏幕显示</span><br><span class="line">   t   change a partition type</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   i   print information about a partition</span><br><span class="line"></span><br><span class="line">  Misc</span><br><span class="line">   m   print this menu</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">  Script</span><br><span class="line">   I   load disk layout from sfdisk script file</span><br><span class="line">   O   dump disk layout to sfdisk script file</span><br><span class="line"></span><br><span class="line">  Save &amp; Exit</span><br><span class="line">   w   write table to disk and exit # 将操作写入分区表</span><br><span class="line">   q   quit without saving changes # 不存储离开</span><br><span class="line"></span><br><span class="line">  Create a new label</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create a new empty SGI (IRIX) partition table</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   s   create a new empty Sun partition table</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sda1: 465.76 GiB, 500105217024 bytes, 976768002 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x69205244</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">Device      Boot      Start        End    Sectors   Size Id Type</span><br><span class="line">/dev/sda1p1       218129509 1920119918 1701990410 811.6G 72 unknown</span><br><span class="line">/dev/sda1p2       729050177 1273024900  543974724 259.4G 74 unknown</span><br><span class="line">/dev/sda1p3       168653938  168653938          0     0B 65 Novell Netware 386</span><br><span class="line">/dev/sda1p4      2692939776 2692991410      51635  25.2M  0 Empty</span><br><span class="line"></span><br><span class="line">Partition table entries are not in disk order.</span><br></pre></td></tr></table></figure><ul><li><p>boot：是否为开机引导模块</p></li><li><p>Start，End：表示这个分区在哪个柱面号码之间，决定分区大小</p></li><li><p>Type：文件系统类型</p></li></ul><p><strong>删除磁盘分区</strong></p><ol><li>fdisk目标磁盘</li><li>p：查看分区信息</li><li>d：删除指定分区</li><li>w写入并离开，q直接离开，不保存操作</li></ol><p><strong>新增磁盘分区</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sda1: 465.76 GiB, 500105217024 bytes, 976768002 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x69205244</span><br><span class="line"></span><br><span class="line">Device      Boot     Start       End Sectors Size Id Type</span><br><span class="line">/dev/sda1p3      168653938 168653938       0   0B 65 Novell Netware 386 # Novell Netware 386是一种网络操作系统，不是文件系统</span><br><span class="line"></span><br><span class="line">Command (m for help): n</span><br><span class="line">Partition type</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended (container for logical partitions)</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (1,2,4, default 1): 5</span><br><span class="line">Value out of range.</span><br><span class="line">Partition number (1,2,4, default 1): 4</span><br><span class="line">First sector (2048-976768001, default 2048): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-168653937, default 168653937): +512M</span><br><span class="line"># 方式一：直接输入扇区的号码，但是需要计算柱面/分区的大小。方式二：使用+XXM来输入分区的大小？</span><br><span class="line"># 偏移量是指新分区相对于当前扇区的位置差异。每个扇区在硬盘中都有一个唯一的编号，偏移量就是用来指定在哪个扇区之后或之前创建新分区。</span><br><span class="line"></span><br><span class="line">例如，如果当前扇的编号是1000，如果你选择偏移量为100个扇区，那么新分区将从扇区号1100开始创建。同样地，如果选择偏移量为-100个扇区，新分区将从扇区号900开始创建。</span><br><span class="line"></span><br><span class="line">Created a new partition 4 of type &#x27;Linux&#x27; and of size 512 MiB.</span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sda1: 465.76 GiB, 500105217024 bytes, 976768002 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x69205244</span><br><span class="line"></span><br><span class="line">Device      Boot     Start       End Sectors  Size Id Type</span><br><span class="line">/dev/sda1p3      168653938 168653938       0    0B 65 Novell Netware 386</span><br><span class="line">/dev/sda1p4           2048   1050623 1048576  512M 83 Linux</span><br><span class="line"></span><br><span class="line">Partition table entries are not in disk order.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SATA硬盘最多支持到15号的分区，IDE支持63号。所以不要让SATA磁盘的分区超过15号，否则即使有剩余的柱面容量，但还是无法继续分区</p><p><strong>fdisk无法处理2T以上的磁盘分区，尤其在应用在磁盘阵列（RAID）时，可能需要用到parted</strong></p><h5 id="磁盘格式化：mkfs，mke2fs">磁盘格式化：mkfs，mke2fs</h5><p><strong>mkfs</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-t：可以接受文件系统格式，后面接文件格式，如ext3等</span><br></pre></td></tr></table></figure><p><strong>mke2fs</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b：可以设置每个block的大小</span><br><span class="line">-i：多少容量给予一个inode</span><br><span class="line">-c：检查磁盘错误。两次-c会检测读写</span><br><span class="line">-L：后面可以接卷标名称</span><br><span class="line">-j：mke2fs是Ext2，加上-j后会自动加入journal而称为ext3</span><br></pre></td></tr></table></figure><h5 id="磁盘检验：fsck，badblocks">磁盘检验：fsck，badblocks</h5><p><strong>fsck</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-t：指定文件系统</span><br><span class="line">-A：依据/etc/fstab依次扫描</span><br><span class="line">-a：自动修复有问题的扇区</span><br><span class="line">-y：与-a类似</span><br><span class="line">-C：可以在检测的过程中显示进度</span><br></pre></td></tr></table></figure><p>执行fsck时，被检查分区务必不可挂载到系统上，需要在卸载的状态</p><p>fsck检查后，有问题的数据会被放置到lost+found中</p><p>使用fsck其实是在调用e2fsck</p><p><strong>badblocks</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s：屏幕列出进度</span><br><span class="line">-v：可以在屏幕看进度</span><br><span class="line">-w：使用写入的方式来测试</span><br></pre></td></tr></table></figure><h5 id="磁盘挂载与卸载：mount">磁盘挂载与卸载：mount</h5><ul><li>单一文件系统不应该被重复挂载在不同的挂载点（目录）中</li><li>单一目录不应该重复挂载多个文件系统</li><li>作为挂载点的目录理论上应该都是空目录，否则目录会暂时消失</li></ul><p><strong>mount</strong></p><p>Linux可以通过分析super block搭配Linux的驱动程序去测试挂载，从而不需要-t就能自动挂载</p><p>系统根据下面两个文件判定那些文件类型需要进行挂载测试</p><ul><li>/etc/filesystems：系统指定的测试挂载文件系统类型</li><li>/proc/filesystems：Linux系统已经加载的文件类型</li><li>Linux的文件系统的驱动程序写在/lib/moudules/$ (username -r) /kernel/fs/</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -l</span><br><span class="line">/dev/mmcblk0p1 on / type ext4 (rw,noatime,errors=remount-ro,commit=600) [opi_root]</span><br></pre></td></tr></table></figure><p>表示/dev/mmcblkp1挂载到/，文件类型为ext4，且挂载为可读写rw，</p><p><strong>挂载CD或DVD</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t iso9660 /dev/cdrom /mnt/cdrom</span><br></pre></td></tr></table></figure><p>光驱一旦挂载后就无法退出光盘</p><p><strong>格式化与挂载软盘</strong></p><p>挂载U盘</p><p>因为挂载在Linux上，所以不能用NTFS文件系统</p><p>如果是需要安装驱动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t vfat -iocharset=cp950 /dev/sda1 /mnt/flash</span><br><span class="line"># vfat为同时被win和linux支持的文件系统，iocharset指定语系，中文系统为cp950</span><br></pre></td></tr></table></figure><p><strong>重新挂载根目录与不特定目录</strong></p><p>如挂载参数需要改变，或者根目录出现只读状态。需要重新挂载根目录</p><p>一种方法是重新启动</p><p>或者执行命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw,auto/</span><br></pre></td></tr></table></figure><p>也可以使用mount将一个目录挂载到另外一个目录，这样不会挂载整块文件系统，而是额外挂载某个目录的方法。相当于软连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount --bind /home /mnt/home</span><br><span class="line"># 这样进入/mnt/home就相当于进入/home目录</span><br></pre></td></tr></table></figure><p><strong>umount</strong></p><p>如果出现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www cdrom]# umount /media/cdrom</span><br><span class="line">umount: /media/cdrom: device is busy</span><br></pre></td></tr></table></figure><p>由于你现在正在该目录下，所以需要退出才能卸载</p><p>也可以使用Label name进行挂载</p><p>使用<code>dumpe2fs</code>查看卷标名称</p><p>然后<code>mount -L ”卷标名“ 挂载点</code></p><p>优点：可以不用知道该文件系统所在的接口与磁盘文件名</p><h5 id="磁盘参数的修改：mknod，e2label，tune2fs">磁盘参数的修改：mknod，e2label，tune2fs</h5><p><strong>mknod</strong></p><p>Linux内核通过文件的major和minor数值来识别设备数据，也就是通过这两个值来认设备</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312262133417.png" alt="image-20231226213357289"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b：设置设备名称成为一个外部存储设备文件，如硬盘</span><br><span class="line">c：设置为外部输入设备文件，如键盘</span><br><span class="line">p：设置为一个FIFO文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">范例：/dev/hdc10设备代码为22，10，建立此设备</span><br><span class="line">mknod /dev/hdc10 b 22 10</span><br></pre></td></tr></table></figure><p><strong>e2label</strong></p><p>卷标在Windows里就是C/D盘的名称C/D</p><p>e2label可以用来修改卷标</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e2label 设备名称 新的label名称</span><br></pre></td></tr></table></figure><p><strong>tune2fs</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l：类似dumpe2fs -h的功能</span><br><span class="line">-j：将ext2转为ext3</span><br><span class="line">-L：类似于e2label，可以改写label</span><br></pre></td></tr></table></figure><p><strong>hdparm</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-T：测试暂存区cache的访问性能</span><br><span class="line">-t：测试硬盘的实际访问性能</span><br></pre></td></tr></table></figure><p>用来设置IDE硬盘的一些高级参数</p><p>对于SATA硬盘，最多用来测试性能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos rpm]# hdparm -Tt /dev/vda1</span><br><span class="line"></span><br><span class="line">/dev/vda1:</span><br><span class="line"> Timing cached reads:   15432 MB in  1.99 seconds = 7749.28 MB/sec</span><br><span class="line"> Timing buffered disk reads: 440 MB in  3.02 seconds = 145.49 MB/sec</span><br></pre></td></tr></table></figure><h3 id="设置开机挂载">设置开机挂载</h3><h4 id="开机挂载-etc-fstab与-etc-mtab">开机挂载/etc/fstab与/etc/mtab</h4><p>系统挂载的限制</p><ol><li>根目录必须挂载，而且先于其他挂载点被挂载进来</li><li>其他挂载点必须为已经新建的目录，可以任意指定，但一定要遵守必须的系统目录结构原则</li><li>所有挂载点在同一时间内，只能挂载一次</li><li>所有分区在同一时间内只能挂载一次</li><li>若进行卸载，需要先将工作目录转移到挂载点及其子目录之外</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cat /etc/fstab</span><br><span class="line"># Device        Mount point       filesystem      parameters     dump  fsck</span><br><span class="line">LABEL=/1              /              ext3           defaults       1     1</span><br><span class="line">LABEL=/home           /home          ext3           defaults       1     2</span><br><span class="line">LABEL=/boot           /boot          ext3           defaults       1     2</span><br><span class="line">tmpfs                 /dev/shm       tmpfs          defaults       0     0</span><br><span class="line">devpts                /dev/pts       devpts         gid=5,mode=620 0     0</span><br><span class="line">sysfs                 /sys           sysfs          defaults       0     0</span><br><span class="line">proc                  /proc          proc           defaults       0     0</span><br><span class="line">LABEL=SWAP-hdc5       swap           swap           defaults       0     0</span><br><span class="line"># 上述特殊字体癿部分不实际磁盘有关！其他则是虚拝文件系统戒</span><br><span class="line"># 不内存置换空间 (swap) 有关。</span><br></pre></td></tr></table></figure><ul><li><p>第一列：磁盘设备文件名或该设备的label</p><p>用dumpe2fs查询卷标名，填写卷标名使用”LABEL=…&quot;的方法填写</p><p>利用设备名称来挂载分区时，硬盘就不能随便插在任意的插槽了<br>新增硬盘时要注意卷标名</p></li><li><p>第二列：挂载点</p></li><li><p>第三列：磁盘分区的文件系统</p><p>需要手动写入文件系统类型</p></li><li><p>第四列：文件系统参数</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312262232670.png" alt="image-20231226223239538"></p></li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312262232190.png" alt="image-20231226223249008"></p><ul><li><p>第五列：能否被dump备份命令作用</p><p>0表示不要做dump备份，1表示每天进行dump操作，2表示其他不定日期的dump备份操作</p><p>通常这个数值不是0就是1</p></li><li><p>第六列：是否以fsck检验扇区</p><p>开机过程中，系统会默认以fsck检验我们的文件系统是否完整，而某些文件系统不需要检验，如swap<br>0表示不检验，1表示最早检验（一般根目录），2也是要检验，不过1先检验</p></li></ul><p>/etc/fstab是开机时的配置文件，实际文件系统的挂载会记录在**/etc/mtab和/proc/mounts**中<br>每次改动文件系统的挂载时会同时更新这两个文件<br>如果/etc/fstab文件有误，导致无法开机成功，而进入到单用户模式，根目录只有readonly，从而无法修改/etc/fstab</p><p>使用如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -n -o remount,rw /</span><br></pre></td></tr></table></figure><h4 id="特殊设备loop挂载（镜像文件不刻录就挂载使用）">特殊设备loop挂载（镜像文件不刻录就挂载使用）</h4><ul><li><p>挂载光盘/DVD镜像文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o loop /root/xxx.iso /mnt/dvd</span><br></pre></td></tr></table></figure></li><li><p>创建大型文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用dd命令新建一个空的文件</span><br><span class="line">dd if=/dev/zero of=/home/loopdev bs=1M count=512</span><br><span class="line"># if是input file，输入文件，/dev/zero可以一直输入0</span><br><span class="line"># of是out file，将输出的0写入/home/loopdev中</span><br><span class="line"># bs是每个block大小</span><br><span class="line"># count是总共几个bs</span><br><span class="line"></span><br><span class="line">#dd就好像堆砖块一样 ，将512块，每块1M的砖块堆成一个大文件</span><br></pre></td></tr></table></figure><p>然后格式化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfs -t ext3 /home/loopdev</span><br></pre></td></tr></table></figure><p>挂载</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o loop /home/loopdev /media/cdrom</span><br></pre></td></tr></table></figure></li></ul><h3 id="内存交换空间swap创建">内存交换空间swap创建</h3><p>当内存不足时，内存中暂不使用的程序和数据会被移动到swap中</p><h4 id="使用物理分区构建swap">使用物理分区构建swap</h4><p>步骤</p><ol><li>分区：<code>fdisk</code>，主要是修改system ID为82对应Linux swap，分完区后<code>partprobe</code>让内核更新分区</li><li>格式化：<code>mkswap 设备文件名</code></li><li>使用：<code>swapon 设备文件名</code></li><li>查看：<code>free</code>查看内存情况</li></ol><h4 id="使用文件构建swap">使用文件构建swap</h4><ol><li><p>使用dd新建一个大文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/tmp/swap bs=1M count=128</span><br></pre></td></tr></table></figure></li></ol><p>​    2.使用mkswap将/tmp/swap格式化为swap文件格式</p><p>​    3.使用swapon来将/tmp/swap启动</p><p>​    4.使用swapoff关闭swap</p><h4 id="swap使用上的限制">swap使用上的限制</h4><ul><li>在内核2.4.10版本以后，单一swap已经没有2GB限制</li><li>最多仅能创建32个swap</li><li>目前64位最大内存寻址到64GB，因此swap总量最大也是仅能达到64GB</li></ul><h3 id="文件系统的特殊查看与操作">文件系统的特殊查看与操作</h3><h4 id="boot-sector与super-block的关系">boot sector与super block的关系</h4><p>可安装开机信息的boot sector（启动扇区）独立出来的，并非放置到superblock中</p><ul><li><p>superblock的大小为1024bytes</p></li><li><p>superblock前面需要保留1024bytes下来，来让引导装载程序可以安装</p></li><li><p>block为1024bytes时，boot sector和superblock各会占用一个blcok，则整个文件系统图如下</p><p>Group 0的superblock是由1号block开始的，0号block留给了boot sector</p></li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401012127268.png" alt="image-20240101212734158"></p><ul><li>block大于1024bytes时，那么superblock会在0号。<br>但superbolck其实只有1024nytes，为了怕浪费空间，因此第一个block内就含有boot sector和superblock</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401012134861.png" alt="image-20240101213459748"></p><h4 id="磁盘空间的浪费问题">磁盘空间的浪费问题</h4><p>一个block只能放置一个文件，因此太多的小文件将会浪费非常多的磁盘空间。并且整个文件系统中包括superblock、inode table与其他数据等，其实都会浪费磁盘空间（意思是有些磁盘空间没用来记录数据，而是被superblock这些东西占用了），所以当我们新建文件系统时，一挂载后就会立刻有很多空间被浪费掉了</p><p>当我们使用ll查询目录时，第一行的total代表该目录下的所有数据所占用的<strong>实际block数量×block大小</strong>的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总用量 626780</span><br><span class="line">     0 -rw-r--r--  1 root root         0 8月   2 20:27 --add-repo</span><br><span class="line">     4 drwxr-xr-x  3 root root      4096 6月   3 2023 bilibiliTool</span><br><span class="line">     4 drwxr-xr-x  3 root root      4096 6月   5 2023 bot</span><br><span class="line">     4 drwxr-xr-x  2 root root      4096 12月 30 23:39 cert</span><br><span class="line">     4 -rw-r--r--  1 root root      1781 4月   8 2021 cosfs.sh</span><br><span class="line">     4 drwxr-xr-x  3 root root      4096 11月 10 07:50 ctf</span><br><span class="line">     4 -rw-r--r--  1 root root      1237 1月  28 2021 dnspod.sh</span><br><span class="line">     4 drwxr-xr-x  6 root root      4096 8月   7 17:15 feishubot</span><br><span class="line">     4 drwxr-xr-x  6 root root      4096 11月  5 20:19 frp-all</span><br><span class="line">     4 drwxr-xr-x  3 root root      4096 12月 31 00:26 harbor</span><br><span class="line">626716 -rw-r--r--  1 root root 641749145 12月 30 12:50 harbor-offline-installer-v2.10.0.tgz</span><br><span class="line">     4 drwxr-xr-x  4 root root      4096 10月 17 20:45 helmetci-builder</span><br><span class="line">     4 drwxr-xr-x  2 root root      4096 10月 15 17:00 package</span><br><span class="line">     4 drwxr-xr-x  4 root root      4096 10月 23 16:57 print</span><br><span class="line">     4 drwxr-xr-x  2 root root      4096 7月   5 23:30 qndxx</span><br><span class="line">     4 drwxr-xr-x  3 root root      4096 9月   1 16:19 test-feishubot</span><br><span class="line">     4 -rw-r--r--  1 root root      1219 2月   5 2021 txcdn.sh</span><br><span class="line">     4 drwxr-xr-x 12 root root      4096 11月 20 22:13 yolo</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cosfs.sh虽然只有1781bytes，但它却占用了4个block，浪费掉了（4096-1781）bytes，所有的block汇总后为626780KB，但实际比这个小</p><h4 id="利用GNU的parted进行分区行为">利用GNU的parted进行分区行为</h4><p>fdisk无法支持高于2TB以上的分区，因此需要parted来进行分区</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parted [device] [command [option]]</span><br><span class="line"></span><br><span class="line">command：</span><br><span class="line">新增分区：mkpart [primary|logical|extended] [ext3|vfat] 开始 结束</span><br><span class="line">分区表：print</span><br><span class="line">删除分区：rm [partition]</span><br></pre></td></tr></table></figure><h2 id="文件与文件系统的压缩与打包">文件与文件系统的压缩与打包</h2><h3 id="压缩的原理">压缩的原理</h3><p>其实文件里面有相当多的”空间“存在，并不是完全填满的，压缩技术可以将这些空间填满，以让整个文件占用的容量下降。</p><p>不过压缩过的文件是无法被操作系统使用的，因此需要解压缩</p><h3 id="Linux常见的压缩命令">Linux常见的压缩命令</h3><p>扩展名，方便对照解压缩</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.Zcompress程序压缩的文件</span><br><span class="line">*.gz gzip</span><br><span class="line">*.bz2 bzip2</span><br><span class="line">*.tar tar打包的数据，没有被压缩过</span><br><span class="line">*.tar.gz tar打包的文件，经过gzip的压缩</span><br><span class="line">*.tar.bz2 tar打包的文件，经过bzip2的压缩</span><br></pre></td></tr></table></figure><h4 id="Compress">Compress</h4><p>非常老的一款压缩命令，gzip已经可以解开它压缩的文件了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解压缩用uncompress</span><br><span class="line"></span><br><span class="line">-r：可以连同目录下的文件一起压缩</span><br><span class="line">-c：将压缩数据输出到屏幕</span><br><span class="line">-v：显示压缩后文件信息和压缩过程文件名的变化</span><br></pre></td></tr></table></figure><h4 id="gzip，zcat">gzip，zcat</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c：将压缩数据输出到屏幕上</span><br><span class="line">-d：解压缩</span><br><span class="line">-t：检验压缩一致性，看文件是否有错</span><br><span class="line">-v：显示源文件/压缩文件的压缩比</span><br><span class="line">-#：压缩等级，-1最快，压缩比最差，-9最慢，压缩比最好，默认是-6</span><br></pre></td></tr></table></figure><p>当使用gzip进行压缩时，原本的文件被压缩为.gz后，源文件就不存在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zcat man.canfig.gz</span><br><span class="line"># man.config原本是文本文件，zcat可以直接显示man.config.gz解压缩后的文件内容</span><br></pre></td></tr></table></figure><h4 id="bzip2，bzcat">bzip2，bzcat</h4><p>bzip2是为了取代gzip并提供更佳的压缩比</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c</span><br><span class="line">-d：解压缩</span><br><span class="line">-k：保留源文件</span><br><span class="line">-z：压缩</span><br><span class="line">-v：显示压缩比</span><br><span class="line">-#</span><br></pre></td></tr></table></figure><p>bzcat可以不解压缩就可以直接读取压缩文件的内容</p><h3 id="打包命令：tar">打包命令：tar</h3><p>打包是将多个文件或目录组合成一个文件，而压缩是对文件或目录进行算法压缩，以减小文件大小。</p><h4 id="常用参数">常用参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar [-j][-z] [cv] [-f 新建的文件名] filename #打包与压缩</span><br><span class="line">tar [-j|-z] [tv] [-f 新键的文件名] # 查看文件名</span><br><span class="line">tar [-j|-z] [xv] [-f 新建的文件名] [-C 目录]    # 解压缩</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c：新建打包文件</span><br><span class="line">-t：查看打包文件的内容有哪些文件名</span><br><span class="line">-x：解打包或解压缩，可以搭配-C在特定目录解开</span><br><span class="line">-c，-t，-x不可同时出现在一串命令行中</span><br><span class="line">-j：通过bzip2的支持进行压缩/解压缩，此时文件名为*.tar.bz2</span><br><span class="line">-z：通过gzip的支持进行压缩/解压缩，此时文件名为*.tar.gz</span><br><span class="line">-v：将过程中正在处理的文件名显示出来</span><br><span class="line">-f filename：-f后接需要处理的文件名</span><br><span class="line">-C 目录：用在解压缩</span><br><span class="line"></span><br><span class="line">-p：保留备份数据的原本权限与属性</span><br><span class="line">-p：保留绝对路径，即允许备份数据中存在根目录</span><br><span class="line">--exclude=FILE：不要将某个文件打包进去</span><br></pre></td></tr></table></figure><p>最常用的：</p><ul><li><strong>压缩</strong>：tar -zcv -f filename.tar.gz 要被压缩的文件或目录</li><li><strong>查询</strong>：tar -ztv -f filename.tar.gz</li><li><strong>解压缩</strong>：tar -zxv -f filename.tar.gz -C 要解压缩的目录</li></ul><p>被压缩的文件都被去掉了根目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos ~]# tar -ztv -f harbor-offline-installer-v2.10.0.tgz </span><br><span class="line">-rw-r--r-- root/root 646285764 2023-12-14 14:39 harbor/harbor.v2.10.0.tar.gz</span><br><span class="line">-rwxr-xr-x root/root      1882 2023-12-14 14:39 harbor/prepare</span><br><span class="line">-rw-r--r-- root/root     11347 2023-12-14 14:39 harbor/LICENSE</span><br><span class="line">-rwxr-xr-x root/root      1975 2023-12-14 14:39 harbor/install.sh</span><br><span class="line">-rw-r--r-- root/root      3643 2023-12-14 14:39 harbor/common.sh</span><br><span class="line">-rw-r--r-- root/root     13761 2023-12-14 14:39 harbor/harbor.yml.tmpl</span><br></pre></td></tr></table></figure><p>主要是为了安全</p><p>如果压缩的是/etc/xxx，在/tmp下解压时，不带根目录解开，解压的文件名就会变成/tem/etc/xxx，如果带根目录，解压后就会是绝对路径，一定会覆盖原有的/etc/xxx</p><p>1.解开单个文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxv -f harbor-offline-installer-v2.10.0.tgz harbor/install.sh</span><br></pre></td></tr></table></figure><p>2.打包某个目录，但不含该目录下的某些文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -jcv -f /root/test.tar.bz2 --exclude=/root/etc* \</span><br><span class="line">&gt; --exclude=/root/test.tar.bz2 /etc /root</span><br><span class="line"># 打包/root和/etc但不含/root下以etc开头的文件和打包后的文件</span><br></pre></td></tr></table></figure><p>3.仅备份某个时刻还要新的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--newer-mtime=</span><br></pre></td></tr></table></figure><p>tarfile：直接打包文件的称呼</p><p>tarball：打包后且被压缩的称呼</p><p>特殊应用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line"># 将/etc整个目录边打包，边在/tmp中解开</span><br><span class="line">tar -cvf - /etc | tar -xvf -</span><br><span class="line"># 输出文件（standard output）与输入文件（standed input）都为-，又有一个 | 存在</span><br><span class="line"># 可以把 - 看作是内存中的一个设备（缓冲区）</span><br></pre></td></tr></table></figure><h3 id="完整备份工具：dump">完整备份工具：dump</h3><h4 id="简单操作">简单操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-S：仅列出后面的待备份数据需要多少磁盘空间才能够完成备份</span><br><span class="line">-u：将这次dump的时间记录到/etc/dumpdates</span><br><span class="line">-v：将dump的文件过程显示出来</span><br><span class="line">-level：一共-0 到 -9十个等级</span><br><span class="line">-j：加入bzip2压缩</span><br><span class="line">-f：类似tar，后面接产生的文件</span><br><span class="line">-W：列出在/etc/fstab里面的具有dump设置的分区是否有备份过</span><br></pre></td></tr></table></figure><p>当第一次进行dump后，再进行第二次dump，可以指定不同的备份等级。假如指定等级为1，此时新备份的数据只会记录与第一次备份所有差异的文件而已</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401022105908.png" alt="image-20240102210549773"></p><p>虽然dump支持整个文件系统或者是单一目录，但是对于目录的支持比较不足。</p><ul><li><p>当待备份的数据为单一文件系统</p><p>可以使用完整的dump功能，备份时可以使用挂载点或者是设备文件名</p></li><li><p>带备份的数据只是目录，并非单一文件系统</p><p>例如你想备份/home/123，但是该目录并非独立的文件系统</p><p>此时备份的限制有</p><ol><li>所有的备份数据都必须要在目录下</li><li>并且仅能使用level 0，即仅支持完整备份而已</li><li>不支持-u参数，即无法创建/etc/dumpdates这个level备份的时间记录文件</li></ol></li></ul><p><strong>用dump备份完整的文件系统</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.找出需要备份的文件系统</span><br><span class="line">2.测试如果要备份此文件系统需要多少容量</span><br><span class="line">dump -S /dev/sda1</span><br><span class="line">3.将完整备份的文件名记录成为/root/boot.dump/boot</span><br><span class="line">dump -0u -f /root/boot.dump/boot</span><br><span class="line"># level 0级别完整备份，将备份文件输出到/root/boot.dump下，命名为boot</span><br><span class="line">4.可以查看系统自动新建的记录文件</span><br><span class="line">cat /etc/dumpdates</span><br></pre></td></tr></table></figure><p><strong>用dump备份非文件系统，即单一目录</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dump -0j -f /root/etc.dump.bz2 /etc</span><br><span class="line"># 备份单一整个目录/etc，并压缩</span><br></pre></td></tr></table></figure><h4 id="restore">restore</h4><p>用来恢复.dump文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">restore -t [-f dumpfile] [-h]# 查看dump文件</span><br><span class="line">restore -C [-f dumpfile] [-D 挂载点] # 比较dump和实际文件</span><br><span class="line">restore -r [-f dumpfile] # 还原整个文件系统</span><br><span class="line"></span><br><span class="line">模式不混用，意思是参数不能写一起</span><br><span class="line"></span><br><span class="line">-t：此模式查看dump起来的备份文件有什么重要的数据</span><br><span class="line">-C：可以将dump内的数据拿出来跟实际的文件系统比较</span><br><span class="line">最终会列出”在dump文件内有记录，且目前文件系统不一样“的文件</span><br><span class="line">-i：进入互动模式，可以仅还原部分文件，用在dump目录时的还原</span><br><span class="line">-r：将整个文件系统还原</span><br></pre></td></tr></table></figure><p>仅还原部分文件可以使用restore的互动模式</p><h3 id="光盘写入工具">光盘写入工具</h3><h4 id="mkisofs：新建镜像文件">mkisofs：新建镜像文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-o：接要产生的镜像文件名</span><br><span class="line">-r：通过Rock Ridge产生支持Unix/Linux的文件数据，可以记录较多的信息</span><br><span class="line">-v：显示构建ISO文件的过程</span><br><span class="line">-m file：排除某个文件不到iso中</span><br><span class="line">-V vol：新建Volume</span><br><span class="line">-graft-point：可以定义位于镜像文件中的目录</span><br></pre></td></tr></table></figure><p>光盘的格式一般称为ISO9660，这种格式一般仅支持旧版的DOS文件名，即文件名只能以8.3（文件名8个字符，扩展名3个字符）的方式存在，-r后可以记录较多信息</p><p>默认情况下，所有要被加到镜像文件中的文件都会被放置到镜像文件中的根目录，想要更改的话可以使用-graft-point参数，例如：</p><p><strong>镜像文件中的目录所在=实际Linux文件系统的目录所在</strong></p><p>/linux/etc=/etc（将Linux中的/etc内的所有数据备份到镜像文件中的/linux/etc目录中）</p><p>范例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkisofs -r -V &#x27;Linux_file&#x27; -o /tmp/system.img \ -m /home/loopdev -graft-point /root=/root /home=/home # 等号左边是镜像中的目录，右边是实际目录</span><br><span class="line"># 备份输出文件命名为system.img</span><br><span class="line"># 排除/home/loopdev</span><br></pre></td></tr></table></figure><h4 id="cdrecord：光盘刻录工具">cdrecord：光盘刻录工具</h4><ol><li><p>检测刻录机所在位置</p><p><code>cdrecord -scanbus dev=ATA</code>,ATA是一种接口类型</p></li><li><p>进行CD的刻录</p><ol><li><p>先抹除光盘原有的内容</p><p><code>cdrecord -v dev=ATA:1,1,0 blank=fast</code>（ATA:1,1,0是刻录机的位置,blank为抹除可重复写入的CD/DVD-RW)</p></li><li><p>开始刻录</p><p><code>cdrecord -v dev=ATA:1,1,0 fs=8m -dummy -data \ /temp/system.img</code>（fs指定多少缓存器，一般为8M）</p><p>DVD的为<code>cdrecord -v dev=ATA:1,1,0 fs=8m -dummy -data -sao \ driveropts=burnfree /tmp/system.img</code></p></li><li><p>测试挂载</p><p><code>mount -t ios9660 /dev/cdrom /mnt</code></p></li></ol></li></ol><h3 id="其他常见的压缩与备份工具">其他常见的压缩与备份工具</h3><h4 id="dd">dd</h4><p>dd可以读取磁盘设备的内容（几乎是读取扇区），然后将整个设备备份成一个文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用dd命令新建一个空的文件</span><br><span class="line">dd if=/dev/zero of=/home/loopdev bs=1M count=512</span><br><span class="line"># if是input file，输入文件，/dev/zero可以一直输入0</span><br><span class="line"># of是out file，将输出的0写入/home/loopdev中</span><br><span class="line"># bs是每个block大小</span><br><span class="line"># count是总共几个bs</span><br><span class="line"></span><br><span class="line">#dd就好像堆砖块一样 ，将512块，每块1M的砖块堆成一个大文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将/etc/passwd备份到/tmp/passwd.back当中</span><br><span class="line">dd if=/etc/passwd of=/tmp/passwd.back</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将磁盘的第一个扇区备份</span><br><span class="line">dd if=/dev/hdc of=/tmp/mbr.back bs=512 count=1</span><br></pre></td></tr></table></figure><p><strong>tar可以用来备份关键数据，而dd则可以用来备份整块分区或整块磁盘</strong></p><p>你可以通过<code>dd if=/dev/sda of=/dev/sdb</code>来构建两块一模一样的磁盘，因为dd可以将/dev/sda内的所有数据，包括MBR和分区表一起复制到/dev/sdb中</p><h4 id="cpio">cpio</h4><p><strong>cpio可以备份任何东西，包括设备文件</strong>。不过它不会主动去找文件备份，需要配合类似find等可以找到文件名的命令来cpio需要备份的数据在哪里</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">备份：cpio -ovcB &gt; [file]</span><br><span class="line">还原：cpio -ivcdu &lt; [file]</span><br><span class="line">查看：cpio -ivct &lt; [file]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">备份参数：</span><br><span class="line">-o：将数据copy到file</span><br><span class="line">-B：让默认的blocks增加至5120bytes</span><br><span class="line">还原参数：</span><br><span class="line">-i：将数据从文件复制到系统中</span><br><span class="line">-d：自动新建目录</span><br><span class="line">-u：自动将新文件覆盖到旧文件</span><br><span class="line">-t：配合-i参数，可以在查看以cpio新建的文件或设备的内容</span><br><span class="line">-v：让存储的过程中文件名可以在屏幕显示</span><br><span class="line">0c：一种较新的portable format方式存储</span><br></pre></td></tr></table></figure><h2 id="Vim程序编辑器">Vim程序编辑器</h2><h3 id="按键说明">按键说明</h3><p><strong>一般模式可用的按钮说明</strong></p><table><thead><tr><th style="text-align:center"><strong>光标移动</strong></th><th></th></tr></thead><tbody><tr><td style="text-align:center">[Crtl]+[f] / [Crtl]+[b]或[Page Down/Up]</td><td>屏幕向下（上）移动</td></tr><tr><td style="text-align:center">0或[Home]</td><td>移动到这一行的最前面字符</td></tr><tr><td style="text-align:center">$或[End]</td><td>移动到这一行的最后面的字符</td></tr><tr><td style="text-align:center">G</td><td>移动到文件的最后一行</td></tr><tr><td style="text-align:center">gg</td><td>移动到文件的第一行，相当于1G</td></tr><tr><td style="text-align:center">N</td><td>向下移动n行</td></tr></tbody></table><table><thead><tr><th style="text-align:center"><strong>查找与替换</strong></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">/word</td><td style="text-align:center">向下查询word字符</td></tr><tr><td style="text-align:center">?word</td><td style="text-align:center">向上查询word</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">重复前一个查找的操作</td></tr><tr><td style="text-align:center">:n1,n2s/word1/word2/gc</td><td style="text-align:center">在n1行到n2行之间寻找word1并替换为word2，加c开启询问</td></tr></tbody></table><table><thead><tr><th style="text-align:center"><strong>删除、复制与粘贴</strong></th><th></th></tr></thead><tbody><tr><td style="text-align:center">x</td><td>删除，相当于[Backspace]</td></tr><tr><td style="text-align:center">nx</td><td>向后连续删除n个字符</td></tr><tr><td style="text-align:center">dd</td><td>删除光标所在的整行</td></tr><tr><td style="text-align:center">ndd</td><td>向下连续删除n行</td></tr><tr><td style="text-align:center">dG</td><td>删除从光标所在到最后一行的所有数据</td></tr><tr><td style="text-align:center">yy</td><td>复制光标所在的那一行</td></tr><tr><td style="text-align:center">p，P</td><td>p将已复制的数据在光标下一行粘贴，P在上一行粘贴</td></tr><tr><td style="text-align:center"><strong>u</strong></td><td><strong>复原上一个操作</strong></td></tr><tr><td style="text-align:center"><strong>[Crtl]+r</strong></td><td><strong>重复上一个操作</strong></td></tr></tbody></table><table><thead><tr><th style="text-align:center"><strong>一般模式切换到编辑模式的可用的按钮说明</strong></th><th></th></tr></thead><tbody><tr><td style="text-align:center">a,A</td><td>a从目前光标所在下一个字符插入，A为从光标所在行的最后一个字符插入</td></tr><tr><td style="text-align:center">o,O</td><td>o为目前所在光标的下一行处插入新的一行，O为上一行</td></tr><tr><td style="text-align:center">r,R</td><td>r只会替换光标所在的字符一次，R会一直替换光标所在的文字，直到[Esc]为止</td></tr></tbody></table><table><thead><tr><th style="text-align:center"><strong>一般模式切换到命令行模式的可用的按钮说明</strong></th><th></th></tr></thead><tbody><tr><td style="text-align:center">ZZ</td><td>若文件没有变动，则不保存离开。如果变动，则保存离开</td></tr><tr><td style="text-align:center">:[filename]</td><td>另存文件</td></tr><tr><td style="text-align:center">:r[filename]</td><td>即将filename这个文件内容加到光标后面</td></tr><tr><td style="text-align:center">:n1,n2 w [filename]</td><td>将n1到n2的内容保存为新的文件</td></tr><tr><td style="text-align:center">:! command</td><td>暂时离开vi执行命令</td></tr><tr><td style="text-align:center">:set nu</td><td>显示行号</td></tr><tr><td style="text-align:center">:set nonu</td><td>取消行号</td></tr></tbody></table><h3 id="vim的保存文件、恢复与打开时的警告信息">vim的保存文件、恢复与打开时的警告信息</h3><p>当我们在使用vim编辑时，vim会在被编辑文件的目录下再新建一个名为.filename.swp的文件</p><p>用户对filename的操作会被记录在.filename.swp中，当vim意外中断时，可以通过这个swp文件恢复</p><h3 id="vim的功能">vim的功能</h3><h4 id="块选择（Visual-Block）">块选择（Visual Block）</h4><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401052321283.png" alt="image-20240105232110137"></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>v</td><td>字符选择，会将光标经过的地方反白选择</td></tr><tr><td>V</td><td>行选择</td></tr><tr><td>[Ctrl]+v</td><td>块选择</td></tr><tr><td>y</td><td>反白部分复制</td></tr><tr><td>d</td><td>反白部分删除</td></tr></tbody></table><h4 id="多文件编辑">多文件编辑</h4><table><thead><tr><th>按钮</th><th></th></tr></thead><tbody><tr><td>:n</td><td>编辑下一个文件</td></tr><tr><td>:N</td><td>编辑上一个文件</td></tr><tr><td>:files</td><td>列出目前这个vim的打开的所有文件</td></tr></tbody></table><h4 id="多窗口功能">多窗口功能</h4><p><strong>:sp{filename}窗口切割</strong></p><p>使用[Ctrl]+w+上箭头可以切换窗口</p><h4 id="vim环境设置与记录-vimrc，-viminfo">vim环境设置与记录:<sub>/.vimrc，</sub>/.viminfo</h4><p>vim会将你曾经做过的行为记录在./.viminfo</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401052348470.png" alt="image-20240105234840281"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401052348882.png" alt="image-20240105234857741"></p><h4 id="vim常用命令简图">vim常用命令简图</h4><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401052349595.png" alt="image-20240105234959424"></p><h3 id="其他vim使用注意事项">其他vim使用注意事项</h3><h4 id="中文编码问题">中文编码问题</h4><ol><li>Linux默认支持的语系：与/etc/sysconfig/i8n有关</li><li>bash的语系：与LANG变量有关</li><li>文件的原本编码</li><li>打开终端机的软件，如GNOME</li></ol><p>最重要的是第三点与第四点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=zh_CN.utf-8</span><br></pre></td></tr></table></figure><h4 id="语系编码转换">语系编码转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iconv -f 原本编码 -t 新编码 filename [-o newfile]</span><br></pre></td></tr></table></figure><h2 id="认识和学习bash">认识和学习bash</h2><p>操作系统的内核（kernel）管理整个计算机硬件，而内核是需要被保护的，所以一般用户只能通过shell来跟内核进行通信</p><h3 id="认识bash">认识bash</h3><h4 id="硬件、内核与shell">硬件、内核与shell</h4><p>我们必须通过shell将我们输入的命令与内核通信，好让内核可以控制硬件正确无误地工作</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401062343296.png" alt="image-20240106234320111"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401062349721.png" alt="image-20240106234948535"></p><p>用户可以通过应用程序来指挥内核，让内核达到我们需要的硬件任务。因为应用程序其实在整个操作系统的最外层，像鸡蛋壳一样，所以叫做shell</p><p>也就是说，只要能够操作应用程序的接口都能够称为shell</p><p>狭义的shell指的是命令行方面的软件，广义的shell则包括图形界面的软件</p><h4 id="系统的合法shell与-etc-shells功能">系统的合法shell与/etc/shells功能</h4><p>早年Unix使用的shell种类很多，有Bourne SHell（sh）、Sun的C SHell，商业上常用的K SHell</p><p>Linux使用的版本叫做“Bourne Again SHell（简称bash）”，它是sh的升级版，基于GNU架构下发展出来的</p><p>系统某些服务在运行过程中，会检查用户能够使用的shell，而这些shell的查询就是借助/etc/shells</p><h4 id="bash-shell的功能">bash shell的功能</h4><ol><li><p>命令记忆功能（history）</p><p>通过上下键查询，记录在~/.bash_history中（前一次登录以前所执行过的命令）</p></li><li><p>命令与文件补全功能（[Tab]）</p></li><li><p>命令别名（alias）</p></li><li><p>作业控制、前台、后台控制</p></li><li><p>程序脚本（shell script）</p></li><li><p>通配符</p></li></ol><h4 id="bash-shell的内置命令：type">bash shell的内置命令：type</h4><p>可以通过type命令知道该命令是否来自于外部（非bash提供的命令）</p><blockquote><p>为什么cd是内置命令，而常用的ls不是内置的？</p></blockquote><p>ChatGPT:</p><p><code>cd</code>是<code>bash</code>的内置命令，而不是一个独立的可执行文件，因为它的功能是改变当前工作目录，这涉及到修改<code>bash</code>的运行环境。</p><ol><li><p>修改当前工目录：<code>cd</code>命令的作用是改变<code>bash</code>的运行环境，将当前目录更改为指定的目录。这个操作需要直接访问和修改<code>bash</code>的内部状态，而不是简单地执行一个独立程序。</p></li><li><p>. 跨进程：<code>cd</code>命令是用于改变<code>bash</code>的当前工作目录，这个状态是在<strong>进程级别</strong>上的。如果<code>cd</code>是一个独立的可执行文件，它只会在执行该可执行文件的子程中更改目录，而不会影响到父进程或其他进程。但是，由于<code>cd</code>是<code>bash</code>的内置命令，它可以直接修改<code>bash</code>的当前工作目录，使得这个状态在整个<code>bash会话中生效。</code></p></li><li><p>快速执行：作为内置命令，<code>cd</code>命令可以直接由<code>bash</code>解释器执行，而不需要启动一个新的进程来执行可执行文件。这样可以提高执行<code>cd</code>命令的速和效率。</p></li><li><p>与环境变量的交互：<code>cd</code>命令不仅可以改变当前目录，还可以与环境变量进行交互，如<code>CDPATH</code>环境变量。这种交互需要直接访问和修改<code>bash</code>的内部环境，因此将<code>cd</code>作为内置命令更加方便。</p><p>综上所述，<code>cd</code>作为<code>bash</code>的内置命令，可以更方便、快速地修改<code>bash</code>的当前工作目录，与<code>bash的内部环境进行交互，并在整个</code>bash`会话中生效。</p><p>待理解：（涉及操作系统的底层）</p></li></ol><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401072251361.png" alt="image-20240107225155215"></p><h3 id="shell的变量功能">shell的变量功能</h3><h4 id="什么是变量？">什么是变量？</h4><p>简单地说就是让某一个特定字符串代表不固定的内容。我们可以用一个简单的“字眼”来替代另一个比较复杂或者容易变动的数据。</p><p>变量就是以一组文字或符号等，来替代一些设置或者是一串保留的数据</p><ul><li><p>变量的可变性与方便性</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401072302354.png" alt="image-20240107230255157"></p></li></ul><p>​不同用户取得的变量名都叫MAIL，但每个MAIL对应的值不一样</p><ul><li><p>影响bash环境操作的变量</p><p>某些特定变量会影响到bash的环境，例如PATH、HOME、MAIL等</p></li><li><p>脚本程序的帮手</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401072317517.png" alt="image-20240107231731347"></p></li></ul><h4 id="变量的显示与设置：echo，unset">变量的显示与设置：echo，unset</h4><p>在变量显示之前，变量的前面必须加上字符“$”</p><ul><li><p>变量的显示echo</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">echo $&#123;PATH&#125;</span><br><span class="line"># 两种方式都可以</span><br><span class="line"></span><br><span class="line"># 变量的修改</span><br><span class="line">echo $myname</span><br><span class="line"></span><br><span class="line">myname=yourname</span><br><span class="line">echo $myname</span><br><span class="line">yourname</span><br></pre></td></tr></table></figure></li><li><p>变量的设置规则</p><ol><li><p>变量与变量内容以一个等号连接</p></li><li><p>等号两边<strong>不能接空格符</strong>。myname=hello world也是错误的</p></li><li><p>变量名称只能是英文字母与数字，但是开头字符<strong>不能是数字</strong></p></li><li><p>变量内容如果有空格，则使用双引号或单引号将变量内容结合起来</p><p>双引号可以保持变量的内容，但单引号仅能是一般字符，不会有特殊符号</p><ul><li><p>双引号内的特殊字符如$等，可以保持原本的特性</p><p>如果<code>var=&quot;lang is $LANG&quot;</code>，则<code>echo $var</code>可得<code>lang is en_US</code></p></li><li><p>单引号内特殊字符则仅为一般字符（纯文本）</p><p>若<code>ar='lang is $LANG'</code>，则<code>echo $var</code>可得<code>lang is $LANG</code></p></li></ul></li><li><p>可用转义字符&quot;\&quot;将特殊符号（如回车键、$，\、空格符、!等）变成一般字符</p></li><li><p>在一串命令中，还需要通过其他的命令提供的信息，可以使用反单引号**`命令`或$(命令)**</p><p><code>version=$(uname -r)</code>后再<code>echo $version</code></p><p>在一串命令中，反单引号的命令会首先被执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /lib/modules/`uname -r`/kernel</span><br><span class="line"># 先执行uname -r，再执行cd</span><br></pre></td></tr></table></figure></li><li><p>如果该变量增加了变量内容时，则可用**$变量名称<strong>或</strong>${变量}**来累加内容</p><p><code>PATH=&quot;$PATH&quot;:/home/bin</code></p></li><li><p>若该变量需要在其他子进程执行，则需要以<strong>export</strong>来使变量变成环境变量</p><p><code>export PATH</code></p></li><li><p>通常大写字符为系统默认变量，自行设置的变量可以使用小写字符</p></li><li><p>取消变量的方法是通过<code>unset 变量名称</code></p></li></ol></li></ul><p>什么是子进程？在目前的shell下，去打开另一个新的shell，新的shell就是子进程</p><p>在一般状态下，父进程的自定义变量是无法在子进程内使用，通过export可以让变量成为环境变量。</p><h4 id="环境变量的功能">环境变量的功能</h4><p><strong>使用env查看环境变量与常见环境变量说明</strong></p><ul><li><p>HOME</p><p>代表用户的主文件夹。cd~就是使用了这个变量</p></li><li><p>SHELL</p><p>告知我们目前这个环境使用的shell是哪个程序</p></li><li><p>HISTSIZE</p><p>与历史命令有关。即我们曾经执行过的命令可以被系统记录下来，而记录的条数则与这个变量有关</p></li><li><p>MAIL</p><p>当我们使用mail命令在收信时系统会去读取的邮件信箱文件（mailbox）</p></li><li><p>PATH</p><p>就是执行文件查找的路径，目录与目录之间以冒号分隔</p></li><li><p>LANG</p><p>语系数据。一般来说中文编码zh_CN.gb2312或zh_CN</p></li><li><p>RANDOM</p><p>随机数变量。一般系统会给出0-32767之间的数值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用0-9之间的数值，利用declare -i number=$RANDOM*10/32768 ; echo $number</span><br></pre></td></tr></table></figure></li></ul><p><strong>使用set查看所有变量（含环境变量与自定义变量）</strong></p><p><strong>PS1（提示符的设置）</strong></p><p>命令提示符，也就是我们常见的<code>[root@www ~]#</code>或<code>[user ~]$</code>的设置值</p><ul><li>\d：可显示星期月日的日期格式</li><li>\H：完整的主机名</li><li>\h：仅取主机名在第一个小数点之前的名字</li><li>\t：显示时间，为24小时制&quot;HH:MM:SS&quot;</li><li>\T：12小时格式”HH:MM:SS&quot;</li><li>\A：24小时“HH:MM&quot;</li><li>@：12&quot;am/pm&quot;</li><li>\u：目前用户的账号名称</li><li>\v：BASH的版本信息</li><li>\w：完整的工作目录名称，由根目录写起</li><li>\W：利用basename函数取得工作目录名称，所以仅仅会列出最后一个目录名</li><li>\#：执行的第几个命令</li><li>\$：提示符，如果是root就是#</li></ul><p>[root@www /home/user 22:45 #12]#</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS1=`[\U@\h \w \A #\#]\$`</span><br></pre></td></tr></table></figure><p><strong>$（关于本shell的PID）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos ~]# echo $$</span><br><span class="line">23365</span><br></pre></td></tr></table></figure><p><strong>？（关于上个执行命令的回传码）</strong></p><p>这个变量是上一个执行的命令所回传的值</p><p>当我们执行某些命令时，这些命令都会回传一个执行后的代码。一般来说，如果执行成功该命令，则会回传一个0值，如果执行过程发生错误，就会回传错误代码。一般就是以非0的数字来代替</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hpBook:~ # echo $HOME</span><br><span class="line">/root</span><br><span class="line">hpBook:~ # echo $?</span><br><span class="line">0</span><br><span class="line">hpBook:~ # mail </span><br><span class="line">If &#x27;mail&#x27; is not a typo you can use command-not-found to lookup the package that contains it, like this:</span><br><span class="line">    cnf mail</span><br><span class="line">hpBook:~ # echo $? # mail命令发生错误，返回错误码127</span><br><span class="line">127</span><br><span class="line">hpBook:~ # echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>OSTYPE、HOSTTYPE、MACHTYPE（主机硬件与内核的等级）</strong></p><p>个人计算机的CPU主要分为32位和64位，其中32位分为i386、i586、i686。64位称为x86_64</p><p>较高级的硬件通常会向下兼容旧有的软件，但较高级的软件可能无法安装在旧机器上安装。</p><p><strong>export：自定义变量转成环境变量</strong></p><p>环境变量与自定义变量的主要区别在于<strong>该变量是否会被子进程所继续引用</strong></p><p>当登录Linux并取得一个bash后，此时的这个bash就是一个独立的进程，被称为PID，接下来在这个bash下执行的任何命令都是由这个bash所衍生出来的，那些被执行的命令就成为子进程</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401082314280.png" alt="image-20240108231445143"></p><p>我们在原本的bash下面再执行一个bash，结果操作的环境接口就会跑到第二个bash（子进程），原本的bash就会处于暂停的状态（sleep）。想要回到原本的bash去，就只有将第二个bash结束掉（exit或logout）</p><p>子进程仅会继承父进程的环境变量，不会继承父进程的自定义变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export 变量名称 # 使该变量成为环境变量</span><br></pre></td></tr></table></figure><h4 id="影响显示结果的语系变量（locale）">影响显示结果的语系变量（locale）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locale -a # 查看Linux支持的所有语系</span><br><span class="line"></span><br><span class="line">/etc/sysconfig/i8n # 整体系统默认的语系定义</span><br></pre></td></tr></table></figure><p>无论如何，如果发生一些乱码问题，那么设置系统里面保有的语系编码，例如en_US</p><h4 id="变量的有效范围">变量的有效范围</h4><p>为什么环境变量的数据可以被子进程所引用呢？这是因为与内存配置有关</p><ul><li>当启动一个shell，操作系统会分配一记忆块给shell用，此内存内的变量可以让子进程取用</li><li>若在父进程使用export，可以让自定义变量的内容写入到上述的记忆块中（环境变量）</li><li>当加载另一个shell时，即启动子进程离开父进程，子shell可以将父sehll的环境变量所在的记忆块导入到自己的环境变量块当中</li></ul><p>要注意的是，这个”环境变量“与”bash的操作环境“意思不太一样，举例来说，PS1并不是环境变量，但PS1会影响到bash的接口（提示符）</p><h4 id="变量键盘读取、数组与声明：read、array、declare">变量键盘读取、数组与声明：read、array、declare</h4><p><strong>read</strong></p><p>读取来自键盘的输入量。就比如某些程序执行的过程当中，会等待用户输入yes/no之类的信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p：后面接提示符</span><br><span class="line">-t：可以接等待的秒数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hpBook:~ # read -p &quot;Please enter your name:&quot; -t 30 named</span><br><span class="line">Please enter your name:123</span><br><span class="line">hpBook:~ # echo $named</span><br><span class="line">123</span><br><span class="line"># 提示用户30秒内输入name，让后将name的内容保存在named变量中</span><br></pre></td></tr></table></figure><p><strong>declare/typeset</strong></p><p>声明变量的类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare [] var</span><br><span class="line">-a：将var定义为数组</span><br><span class="line">-i：定义为整数数字</span><br><span class="line">-x：用法与export一样，将var变为环境变量</span><br><span class="line">-r：将var设置为readonly类型，该变量不可以被更改，也不能被重设</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hpBook:~ # num=1+2</span><br><span class="line">hpBook:~ # echo $num</span><br><span class="line">1+2 # 此时num为文字类型</span><br><span class="line">hpBook:~ # declare -i num=1+2</span><br><span class="line">hpBook:~ # echo $num</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>变量类型默认为字符串</p><p>bash环境中的数值运算，默认最多仅能到达整数类型，所以三分之一结果为0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare +x num # 将-变为+可以进行取消操作，即原本为整数数字类型的num取消为字符串</span><br><span class="line">declare -p num # 列出num的变量类型</span><br></pre></td></tr></table></figure><p>如果不小心把变量设置为只读，通常需要注销再登录才可以复原该变量的类型</p><p><strong>数组（array）变量类型</strong></p><p>数组的设置方式：</p><p><code>var[index]=content</code></p><p>意思是，我有一个名为var的数组，这个数组的内容为var[1]=“one”，var[2]=&quot;two&quot;等等，index就是一些数字，重点使用[]来设置的</p><h4 id="与文件系统及程序的限制关系：ulimit">与文件系统及程序的限制关系：ulimit</h4><p>为了防止多用户同时占用过多资源，bash可以通过ulimit来限制用户的某些系统资源，包括可以打开的文件数量、可以使用的CPU时间、可以使用的内存总量等</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-H：必不能超过这个数值</span><br><span class="line">-s：警告设置，超过后会有警告提示</span><br><span class="line">-a：后面不接任何参数，可以列出所有的限制额度</span><br><span class="line">-c：当某些进程发生错误时，系统可能会将该进程在内存中的信息写成文件（内核文件）</span><br><span class="line">-f：此shell可以创建的最大文件容量（一般为2GB）</span><br><span class="line">-d：进程可使用的最大断裂内存容量</span><br><span class="line">-l：可用于锁定的内存量</span><br><span class="line">-t：可使用的最大CPU时间（单位为秒）</span><br><span class="line">-u：单一用户可以使用的最大进程数量</span><br></pre></td></tr></table></figure><p>要想复原ulimit的设置最简单的方法就是注销再登陆，否则就得重新设置ulimit</p><h4 id="变量内容的删除、替代与替换">变量内容的删除、替代与替换</h4><p><strong>变量内容的删除与替换</strong></p><p>例子</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401092124835.png" alt="image-20240109212428755"></p><p><s>/usr/kerberos/sbin:/usr/kerberos/bin:</s>/usr/local/sbin:/usr/local/bin:/sbin:/bin: /usr/sbin:/usr/bin:/root/bin</p><p>说明</p><p><strong>$</strong>{path#/*kerberos/bin:}</p><p>$是关键字，用在这种删除模式中</p><p>${<strong>path</strong>#/*kerberos/bin:}</p><p>path是原本的变量名称</p><p>${path**#**/*kerberos/bin:}</p><p>#代表<strong>从变量内容的最前面开始向右删除，仅删除最短的那个</strong></p><p>${path#<strong>/*kerberos/bin:</strong>}</p><p>代表要被删除部分，由于# 代表由前面开始删除，所以这里便由开始的 / 写起。</p><p>需要注意的是，我们还可以通过通配符 * 来替代 0 到无穷多个任意字符</p><p>2.删除前面所有的目录，仅保留最后一个目录</p><p>${path**#**/*:}</p><p>删除从第一个/到<strong>最短匹配</strong>到:之间的所有内容</p><p><s>/usr/kerberos/sbin:</s>/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</p><p>${path**##**/*:}</p><p>删除从第一个/到<strong>最长匹配</strong>到:之间的所有内容</p><p><s>/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:</s>/root/bin</p><p>3.从后面向前删除变量内容</p><p>${path%:*bin}</p><p>删除从最后的:到bin为止最短匹配的bin</p><p>/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:<s>/root/bin</s></p><p>${path%%:*bin}</p><p>/usr/kerberos/sbin~~:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin~~</p><p>替换</p><p>${path/sbin/SBIN} 两个斜线之间的是旧字符串</p><p>/usr/kerberos/<strong>SBIN</strong>:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</p><p>${path//sbin/SBIN}</p><p>/usr/kerberos/<strong>SBIN</strong>:/usr/kerberos/bin:/usr/local/<strong>SBIN</strong>:/usr/local/bin:/<strong>SBIN</strong>:/bin:/usr/<strong>SBIN</strong>:/usr/bin:/root/bin</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401102252934.png" alt="image-20240110225155712"></p><p><strong>变量的测试与内容替换</strong></p><p>在某些时刻我们需要判断某个变量是否存在。若变量存在则使用现有的变量，若不存在则给予一个常用的设置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hpBook:~ # echo $username</span><br><span class="line"></span><br><span class="line">hpBook:~ # username=$&#123;username-root&#125;</span><br><span class="line">hpBook:~ # echo $username # 此时username可能不存在，也可能为空字符串。此时主动给予root的内容</span><br><span class="line">root</span><br><span class="line">hpBook:~ # username=&#x27;123&#x27;</span><br><span class="line">hpBook:~ # username=$&#123;usrname-root&#125;</span><br><span class="line">hpBook:~ # echo $username # username被设置了123值，所以不给予值</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>格式：<code>new_var=$&#123;old_var-content&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hpBook:~ # username=&#x27;&#x27;</span><br><span class="line">hpBook:~ # username=$&#123;username-root&#125;</span><br><span class="line">hpBook:~ # echo $username</span><br><span class="line"></span><br><span class="line">hpBook:~ # username=$&#123;username:-root&#125; # 加上:后若变量内容为空或者是未设置，都能够以后面的内容替换</span><br><span class="line">hpBook:~ # echo $username</span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>加上冒号后，被测试的变量未被设置或者已被设置为空字符串时，都能够用后面的内容来替换与设置</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401102326550.png" alt="image-20240110232633342"></p><h3 id="命令别名与历史命令">命令别名与历史命令</h3><h4 id="命令别名设置：alias，unalias">命令别名设置：alias，unalias</h4><p>alias的定义规则几乎与变量定义规则相同</p><p><strong>alias command1=‘command2’</strong></p><p>取消的话就用<strong>unalias command2</strong></p><h4 id="历史命令：history">历史命令：history</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n：列出最近的n条命令</span><br><span class="line">-C：将目前shell中的所有history内容全部删除</span><br><span class="line">-a：将目前新增的history命令新增入hisfiles中，默认写入~/.bash_history</span><br><span class="line">-r：将 histfiles 的内容读取目前这个 shell 的 history 记忆中</span><br><span class="line">-w：将目前的 history 记忆内容写入 histfiles 中</span><br></pre></td></tr></table></figure><p>~/.bash_history中记录的条数由HISTSIZE决定，旧的信息会被主动去掉，仅保留最新的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 执行历史命令</span><br><span class="line">!number</span><br><span class="line">!command # 由最近的命令向前搜寻命令为command的命令</span><br><span class="line">!! # 执行上一个命令</span><br></pre></td></tr></table></figure><h3 id="Bash-Shell的操作环境">Bash Shell的操作环境</h3><h4 id="路径与命令查找顺序">路径与命令查找顺序</h4><p>我们的系统里面其实有不少的ls命令，如果一个命令（如ls）被执行时，到底是哪一个ls被执行了呢</p><p>基本上，命令运行有这样的顺序：</p><ol><li>以相对/绝对路径执行命令，如/bin/ls或./ls</li><li>由alias找到该命令</li><li>由bash内置的（builtin）命令执行</li><li>通过$PATH的顺序来找到第一个命令执行</li></ol><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401110000323.png" alt="image-20240111000017194"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@Redrock-ButterBeer:~# type -a rm</span><br><span class="line">rm is aliased to `rm -i&#x27;</span><br><span class="line">rm is /usr/bin/rm</span><br><span class="line">rm is /bin/rm</span><br><span class="line"># 可以通过type -a查询命令查找的顺序</span><br></pre></td></tr></table></figure><h4 id="bash的登陆与欢迎信息：-etc-issue，-etc-motd">bash的登陆与欢迎信息：/etc/issue，/etc/motd</h4><p>登陆界面，保存在/etc/issue</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@Redrock-ButterBeer:~# cat /etc/issue</span><br><span class="line">Debian GNU/Linux 12 \n \l</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401112112346.png" alt="image-20240111211216275"></p><p>如果你想让用户登陆后取得一些信息，可以将信息加入到/etc/mtod</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接主机...</span><br><span class="line">连接主机成功</span><br><span class="line">Linux Redrock-ButterBeer 6.1.0-13-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.55-1 (2023-09-29) x86_64</span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU/Linux system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line"> ___        _             _       ___      _   _           ___</span><br><span class="line">| _ \___ __| |_ _ ___  __| |_____| _ )_  _| |_| |_ ___ _ _| _ ) ___ ___ _ _</span><br><span class="line">|   / -_) _` | &#x27;_/ _ \/ _| / /___| _ \ || |  _|  _/ -_) &#x27;_| _ \/ -_) -_) &#x27;_|</span><br><span class="line">|_|_\___\__,_|_| \___/\__|_\_\   |___/\_,_|\__|\__\___|_| |___/\___\___|_|</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们使用telnet连接到主机时，显示的是/etc/issue.net的内容</p><h4 id="bash的环境配置文件">bash的环境配置文件</h4><ul><li><p>login与non-login shell</p><p>login shell：取得bash时需要完整的登录流程，就称为login shell。<br>举例来说，你要由tty1-tty6登录，需要输入用户的账号与密码，此时取得的bash就成为”login shell“</p></li><li><p>non-login shell</p><p>取得bash接口的方法不需要重复登录的操作。在原本的bash下再次执行bash这个命令，再次取得的bash就称为non-login shell</p></li></ul><p>这两个取得的bash，各自读取的配置文件数据是不一致的</p><p><strong>login shell只会读取这两个配置文件</strong></p><ul><li><p>/etc/profile：这是系统整体的设置</p><p>这个文件可以利用用户的标识符UID来决定很多重要的变量数据，这个文件中设置的变量有</p><ul><li>PATH：会依据UID决定PATH变量要不要含有sbin的系统命令目录</li><li>MAIL：依据账号设置好用户的mailbox到/var/spool/mail/账号名</li><li>USER：根据用户的账号设置此变量内容</li><li>HOSTSIZE：历史命令条数</li><li>它还会调用外部的设置数据，在CentOS 5.x中，以下数据会依照顺序被调用进来<ul><li>/etc/inputrc：这个文件并没有被执行，这个文件会主动判断用户有没有自定义输入的按键功能，如果没有的话，/etc/profile就设置”INPUTRC=/etc/inputrc“这个变量</li><li>/etc/profile.d/*sh：只要在profile.d这个目录内且扩展名为sh，另外用户能够具有r的权限，那么文件就会被/etc/profile调用。在CentOS 5.x中，这个目录下面的文件规定了bash操作接口的颜色、语系、ll与ls命令的命令别名、vi的命令别名等，如果需要帮所有用户设置一些共享的命令别名时，可以在这个目录下面自行创建扩展名为.sh文件</li><li>/etc/sysconfig/i18n：这个文件是由/etc/profile.d/lang.sh调用的。这是决定bash默认使用何种语系的重要配置文件，文件里最重要的就是LANG这个变量的设置。</li></ul></li></ul></li><li><p>个人偏好设置文件：~/.bash_profile</p><p>bash在读完/etc/profile后并借此调用其他配置文件后，接下来则会读取用户的个人配置文件。</p><p>在login shell的bash环境中，所读取的个人偏好配置文件其实主要有三个：</p><ul><li>~/.bash_profile</li><li>~/.bash_login</li><li>~/.profile</li></ul><p>bash的login shell设置只会读取上面三个文件的其中一个，而读取的顺序则是依照是上面的顺序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos ~]# cat ~/.bash_profile</span><br><span class="line"># .bash_profile</span><br><span class="line"></span><br><span class="line"># Get the aliases and functions</span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">        . ~/.bashrc</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># User specific environment and startup programs</span><br><span class="line"></span><br><span class="line">PATH=$PATH:$HOME/bin</span><br><span class="line"></span><br><span class="line">export PATH # 这里使用累加的方式增加用户主文件夹下的~/bin/为额外的执行文件放置目录</span><br><span class="line"></span><br><span class="line"># 判断主文件夹下的~/.bashrc是否存在，如果存在则读入~/.bahsrc的设置</span><br></pre></td></tr></table></figure><p>整个login shell的读取流程</p></li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401112217022.png" alt="image-20240111221747850"></p><p><strong>source：读取环境配置文件的命令</strong></p><p>当改动配置文件后，通常需要注销后再登录才能生效。source可以直接读取配置文件而不注销登录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br><span class="line">. ~/.bashrc</span><br><span class="line"># 两种效果相同</span><br></pre></td></tr></table></figure><p><strong>~/.bashrc（non-login shell会读）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos ~]# cat ~/.bashrc</span><br><span class="line"># .bashrc</span><br><span class="line"></span><br><span class="line"># User specific aliases and functions</span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line"></span><br><span class="line"># Source global definitions</span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br><span class="line">export NSS_STRICT_NOFORK=DISABLED</span><br><span class="line">alias php74=&#x27;php74 -c /www/server/php/74/etc/php-cli.ini&#x27;</span><br></pre></td></tr></table></figure><p>此外CentOS 5.x会主动调用/etc/bashrc这个文件，因为该文件为bash定义下面的数据</p><ul><li>依据不同的UID规定umask的值</li><li>依据不同的UID规定提示符（就是PS1）</li><li>调用/etc/profile.d/*.sh的设置</li></ul><p><strong>其他相关配置文件</strong></p><ul><li><p>/etc/man.config：规定了使用man的时候man page的路径到哪里去寻找。其实就是执行man的时候该去哪里查看数据的路径设置</p><p>我们在查找man page时，会依据MANPATH的路径去分别查找</p></li><li><p>~/.bash_history：默认情况下，历史命令会被记录在这里。而这个文件可以记录多少命令由HISTSIZE决定</p></li><li><p>~/.bash_logout：记录当我注销bash后系统再帮我做完什么操作后再离开。默认情况下，bash只是帮我们清理掉屏幕的信息而已。</p></li></ul><h4 id="终端机的环境设置：stty，set">终端机的环境设置：stty，set</h4><p><strong>stty</strong></p><p>在登录时我们可以取得一些字符设置的功能，比如我们可以使用退格键来删除命令行的字符，也可以使用ctrl+c来强制终止一个命令的运行等。我们可以通过stty来设置一些按键功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a：将所有stty参数列出来</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hpBook:~ # stty -a</span><br><span class="line">speed 38400 baud; rows 29; columns 112; line = 0;</span><br><span class="line">intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;;</span><br><span class="line">start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;</span><br><span class="line">-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts</span><br><span class="line">-ignbrk brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany imaxbel -iutf8</span><br><span class="line">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class="line">isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc</span><br></pre></td></tr></table></figure><p>^代表Ctrl的意思</p><ul><li>eof：end of file，代表结束输入</li><li>erase：向后删除字符</li><li>intr：送出一个interrupt中断信号给目前正在运行的程序</li><li>kill：删除目前命令行上的所有文字</li><li>quit：送出一个quit信号给目前正在运行的进程</li><li>start：在某个进程停止后，重新启动它的输出</li><li>stop：停止目前屏幕的输出</li><li>susp：送出一个terminal stop的信号给正在运行的进程</li></ul><p><strong>set</strong></p><p>set除了可以查看变量内容外，还可以帮我们设置整个命令输入/输出的和环境，如历史命令、显示错误内容等</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401131631589.png" alt="image-20240113163134080"></p><p>想取消参数的话，前面加+</p><p>另外，其他的按键设置功能放置在/etc/inputrc中</p><p>还有例如/etc/DIR_COLORS*与/etc/termcap等</p><p>bash默认的组合键</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401131635679.png" alt="image-20240113163526581"></p><h4 id="通配符与特殊符号">通配符与特殊符号</h4><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>*</td><td>代表0到无穷多个任意字符</td></tr><tr><td>?</td><td>代表一定有一个任意字符</td></tr><tr><td>[]</td><td>代表一定有一个在中括号内的字符（非任意字符）。例如[abcd]一定有abcd的其中一个</td></tr><tr><td>[-]</td><td>代表在编码顺序内的所有字符。例如[0-9]代表0到9之间的所有数字</td></tr><tr><td>[^]</td><td>表示原向选择，例如[^abc]表示一定有一个字符，只要是非abc就接受</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出/etc下面文件名刚好是5个字符的文件名</span><br><span class="line">ls /etc/?????</span><br><span class="line"></span><br><span class="line"># 找出/etc下文件名含有数字的文件名</span><br><span class="line">ls /etc/*[0-9]* # 注意要加*</span><br><span class="line"></span><br><span class="line"># 找出/etc下文件名开头非为小写字母的文件名</span><br><span class="line">ls /etc/*[^a-z]*</span><br></pre></td></tr></table></figure><p>其他的特殊符号</p><table><thead><tr><th>符号</th><th>内容</th></tr></thead><tbody><tr><td>#</td><td>注释</td></tr><tr><td>\</td><td>转义</td></tr><tr><td>|</td><td>管道（pipe），分割两个管道命令的界定</td></tr><tr><td>;</td><td>连续命令执行分隔符</td></tr><tr><td>~</td><td>用户的主文件夹</td></tr><tr><td>$</td><td>使用变量前导符</td></tr><tr><td>&amp;</td><td>作业控制，将命令变成背景下工作</td></tr><tr><td>!</td><td>逻辑运算&quot;非&quot;</td></tr><tr><td>/</td><td>目录符号，路径分隔</td></tr><tr><td>&gt;,&gt;&gt;</td><td>数据流重定向，输出导向，分别是“替换”与“累加&quot;</td></tr><tr><td>&lt;,&lt;&lt;</td><td>输入导向</td></tr><tr><td>‘’</td><td>不具有变量置换功能</td></tr><tr><td>“”</td><td>具有变量置换功能</td></tr><tr><td>``</td><td>两个“`”中间为可以先执行的命令，也可以使用$()</td></tr><tr><td>()</td><td>中间为子shell的起始与结束</td></tr><tr><td>{}</td><td>在中间为命令块的组合</td></tr></tbody></table><h3 id="数据流重定向">数据流重定向</h3><p>就是将某个命令执行后应该要出现在屏幕上的数据传输到其他地方，例如文件或者设备等</p><h4 id="什么是数据流重定向">什么是数据流重定向</h4><p>命令的执行过程</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401131704131.png" alt="image-20240113170445932"></p><p>我们在执行一个命令时，这个命令可能会由文件读入数据，经过处理后，再将数据输出到屏幕上</p><ul><li><p>standard output与standard error output（标准输出与标准错误输出）</p><p>标准输出指的是命令执行所后回传的正确的信息，而标准错误输出可理解为命令执行失败后，所回传的错误信息。</p></li><li><p>我们的系统中有a.sh这个文件，<a href="http://xn--b-m66a737ew9e.sh">但没有b.sh</a>。当执行cat <a href="http://a.sh">a.sh</a> b.sh时，cat会进行标准输出和标准错误输出，此时不管正确还是错误的数据都是默认输出到屏幕上，而数据流重定向功能就可以将standard output（stdout）与standard error output（stderr）分别传送到其他的文件或设备去，而分别传送所用的特殊字符则如下所示：</p><ol><li>标准输入（stdin）：代码为0，使用&lt;或&lt;&lt;</li><li>标准输出（stdout）：代码为1，使用&gt;或&gt;&gt;</li><li>标准错误输出（stderr）：代码为2，使用2&gt;或2&gt;&gt;</li></ol></li></ul><p>重定向文件的创建方式</p><p>cat test1.txt &gt; test2.txt</p><p>当test2.txt不存在时，系统会自动创建。如果存在，则会先将test2.txt的内容清空后，再将数据写入。如果不想清空数据，使用&gt;&gt;累加内容就好</p><p>通过2&gt;或2&gt;&gt;可以将错误的数据输出到指定的文件或设备</p><p><a href="http://xn--abc-y28dj40fdsknqjxwu.sh">目录下没有abc.sh</a>，<a href="http://xn--abcd-ft4gw5t.sh">存在abcd.sh</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hpBook:~/.ssh # vim abcd.sh</span><br><span class="line">hpBook:~/.ssh # cat abc.sh &gt; abcd.sh</span><br><span class="line">cat: abc.sh: No such file or directory</span><br><span class="line"></span><br><span class="line"># 错误信息并没有输入到abcd.sh中</span><br><span class="line"># 改成2&gt;就可以了</span><br><span class="line">hpBook:~/.ssh # cat abc.sh 2&gt; abcd.sh</span><br><span class="line">hpBook:~/.ssh # more abcd.sh</span><br><span class="line">cat: abc.sh: No such file or directory</span><br><span class="line"># 可以看到错误信息被记录在了abcd.sh中</span><br><span class="line"></span><br><span class="line"># 还可以把正确与错误的数据分别存入不同的文件中</span><br><span class="line">ls abc.sh &gt; list_right.txt 2&gt; list_error.txt</span><br></pre></td></tr></table></figure><p><strong>/dev/null 垃圾桶黑洞设备与特殊写法</strong></p><p>/dev/null可以吃掉任何导向这个设备的信息，我们可以把错误信息导向这里，从而达到忽略而不占内存的效果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hpBook:~/.ssh # cat abc.sh abcd.sh</span><br><span class="line">cat: abc.sh: No such file or directory</span><br><span class="line">This is a existed file.</span><br><span class="line">Redirect:cat: abc.sh: No such file or directory</span><br><span class="line">hpBook:~/.ssh # cat abc.sh abcd.sh 2&gt; /dev/null</span><br><span class="line">This is a existed file.</span><br><span class="line">Redirect:cat: abc.sh: No such file or directory # 只显示stdout，而stderr被抛弃了</span><br></pre></td></tr></table></figure><p>如果想将正确与错误的数据通通写入同一个文件中，这时候需要使用特殊的写法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /home -name .bashrc &gt; list 2&gt; list # 错误的</span><br><span class="line">find /home -name .bashrc &gt; list 2&gt;1&amp;</span><br><span class="line">find /home -name .bashrc &amp;&gt; list </span><br></pre></td></tr></table></figure><p>第一条错误的原因是由于两条数据同时写入一个文件，但没有使用特殊语法，此时两条数据可能会交叉写入该文件内，造成次序的错乱。里面的数据排列是混乱的。</p><p>一般常用第二种写法，即2&gt;1&amp;</p><p><strong>standard input，&lt;与&lt;&lt;</strong></p><p>将原本需要由键盘输入的数据改由文件内容来替代</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@orangepizero3:~# cat &gt; catfile</span><br><span class="line">this is a catfile. # 此时用户使用键盘在屏幕上输入的信息会被直接写入catfile中</span><br><span class="line">root@orangepizero3:~# cat catfile</span><br><span class="line">this is a catfile.</span><br></pre></td></tr></table></figure><p>也可以用某个文件的内容来替代键盘的敲击</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@orangepizero3:~# cat catfile</span><br><span class="line">hello</span><br><span class="line">root@orangepizero3:~# cat catfile2</span><br><span class="line">world</span><br><span class="line">root@orangepizero3:~# cat &gt; catfile2 &lt; catfile # 替代内容</span><br><span class="line">root@orangepizero3:~# cat catfile2</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>&lt;&lt; 代表结束输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 我想用cat直接将输入的信息输出到catfile中，且当有键盘输入eof时，本次输入就结束</span><br><span class="line">root@orangepizero3:~# cat &gt; catfile &lt;&lt; &quot;eof&quot;</span><br><span class="line">&gt; this is a test.</span><br><span class="line">&gt; now stop</span><br><span class="line">&gt; eof</span><br><span class="line">root@orangepizero3:~# cat catfile</span><br><span class="line">this is a test.</span><br><span class="line">now stop # 可以看到eof没有被输入进文件中</span><br></pre></td></tr></table></figure><h4 id="用途">用途</h4><ol><li>屏幕输出的信息需要保存</li><li>后台执行中的程序，不希望它干扰屏幕的正常输出结果</li><li>一些系统的例行命令的执行结果希望保存下来</li><li>一些执行命令的可能已知错误信息，想以2&gt;/dev/null将它丢掉</li><li>错误信息与正确信息需要分别输出</li></ol><h3 id="命令执行的判断依据：">命令执行的判断依据：;,&amp;&amp;||</h3><ul><li><p>cmd ; cmd</p><p>命令连续执行，前后命令可以没有相关性</p></li><li><p>$?(命令回传码)与&amp;&amp;或||</p><p>若前一个命令执行的结果正确，在Linux下会回传一个$?=0的值。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401241654910.png" alt="image-20240124165450709"></p><p><code>ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe</code></p><p>Linux下面的命令都是从左往右执行的</p><ol><li>当/tmp/abc存在时，不执行mkdir，此时继续向后执行命令touch</li><li>当/tmp/abc不存在，执行mkdir，第二条命令被成功执行，然后执行touch</li></ol></li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401241703416.png" alt="image-20240124170341333"></p><p>一般的假设判断式</p><p><strong>cmd1 &amp;&amp; cmd2 || cmd3</strong></p><p>比如ls /tmp/test &amp;&amp; echo “exist” || echo “no exist”</p><p>判断/tem/test是否存在，存在显示exist，不存在就显示no exist</p><h3 id="管道命令（pipe）">管道命令（pipe）</h3><p>&quot;|&quot;仅能处理由前面一个命令传来的正确信息，而错误信息没有直接处理的能力。</p><p>管道命令必须要能够接收来自前一个命令的数据成为standard input继续处理才行。</p><p>管道命令必须要能够接收standard input的数据才行，比如less，more，head等。</p><h4 id="选取命令：cut，grep">选取命令：cut，grep</h4><p>通常针对”行”来分析的，而不是整篇分析</p><p><strong>cut</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut -d&#x27;分隔字符&#x27; -f fields</span><br><span class="line">cut -c 字符范围</span><br><span class="line"></span><br><span class="line">-d：</span><br><span class="line">-f：依据-d的分隔字符将一段信息切割成为数段，用-f取出第几段</span><br><span class="line">-c：以字符的单位取出固定字符区间</span><br><span class="line"></span><br><span class="line"># 将PATH变量的第3个路径取出</span><br><span class="line">root@orangepizero3:~# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">root@orangepizero3:~# echo $PATH | cut -d &#x27;:&#x27; -f 3</span><br><span class="line">/usr/sbin</span><br><span class="line"></span><br><span class="line"># 输出export的第12个字符以后的字符串</span><br><span class="line">root@orangepizero3:~# export</span><br><span class="line">declare -x HOME=&quot;/root&quot;</span><br><span class="line">declare -x LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">declare -x LANGUAGE=&quot;en_US.UTF-8&quot;</span><br><span class="line">root@orangepizero3:~# export | cut -c 12-</span><br><span class="line">HOME=&quot;/root&quot;</span><br><span class="line">LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">LANGUAGE=&quot;en_US.UTF-8&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要用于将同一行里面的数据进行分解，最常使用在分析一些数据或文字数据的时候。使用时要注意空格也要算入。</p><p><strong>grep</strong></p><p>用来分析一行信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -参数 &#x27;查找字符串&#x27; filename</span><br><span class="line">-a：将二进制文件以text文件的方式查找数据</span><br><span class="line">-c：计算找到查找字符串的次数</span><br><span class="line">-i：忽略大小写的不同</span><br><span class="line">-n：顺便输出行号</span><br><span class="line">-v：反向选择。即选出没有&#x27;查找字符串&#x27;的那一行</span><br><span class="line">--color=auto</span><br></pre></td></tr></table></figure><h4 id="排序命令：sort，wc，uniq">排序命令：sort，wc，uniq</h4><p><strong>sort</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort -参数 [file or stdin]</span><br><span class="line">-f：忽略大小写</span><br><span class="line">-b：忽略最前面的空格</span><br><span class="line">-M：以月份的名字来排序</span><br><span class="line">-n：使用纯数字排序</span><br><span class="line">-r：反向排序</span><br><span class="line">-u：就是uniq，相同的数据仅输出一行代表</span><br><span class="line">-t：分隔符</span><br><span class="line">-k：以那个区间来排序</span><br><span class="line"></span><br><span class="line"># 在/etc/passwd中，以:为分隔，以第三列排序</span><br><span class="line">root@orangepizero3:~# cat /etc/passwd | sort -t &#x27;:&#x27; -k 3</span><br></pre></td></tr></table></figure><p><strong>uniq</strong></p><p>排序完成后，将重复的数据仅列出一个显示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-i：忽略大小写</span><br><span class="line">-c：进行计数</span><br><span class="line"></span><br><span class="line"># 使用last将账号列出，仅取出账号列，并输出每个人的登录总次数</span><br><span class="line">root@Redrock-ButterBeer:~# last | cut -d &#x27; &#x27; -f1 | sort | uniq -c # f1表示指定要提取的是每行的第一个字段</span><br><span class="line">      1</span><br><span class="line">     12 reboot</span><br><span class="line">   1278 root</span><br><span class="line">      1 wtmp</span><br></pre></td></tr></table></figure><p><strong>wc</strong></p><p>可以帮我们知道某个文件里有多少字，多少行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l：仅列出行</span><br><span class="line">-w：仅列出多少字</span><br><span class="line">-m：多少字符</span><br><span class="line"></span><br><span class="line">root@orangepizero3:~# cat /etc/passwd | wc</span><br><span class="line">     33      43    1747</span><br><span class="line"># 有33行，43个字数，1747个字符数</span><br></pre></td></tr></table></figure><h4 id="双向重定向：tee">双向重定向：tee</h4><p>如果想要将某个数据流的处理过程中将某段信息存下来，可以利用tee</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a：累加数据到file中</span><br><span class="line"></span><br><span class="line">ls -l | tee -a ~/homefile | more</span><br><span class="line"># 将ls的输出累加到homefile中，同时屏幕也有输出信息</span><br></pre></td></tr></table></figure><h4 id="字符转换命令：tr，col，join，paste，expand">字符转换命令：tr，col，join，paste，expand</h4><p><strong>tr</strong></p><p>用来删除一段信息中的文字，或者替换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tr [-ds] SET1 ...</span><br><span class="line"></span><br><span class="line">-d；删除信息中的SET1字符串</span><br><span class="line">-s：替换重复的字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 将last输出中所有的小写字符变成大写字符</span><br><span class="line">last | tr [a-z] [A-Z]</span><br><span class="line"></span><br><span class="line"># 删除/etc/password输出中的冒号</span><br><span class="line">cat /etc/password | tr -d &#x27;:&#x27;</span><br></pre></td></tr></table></figure><p><strong>col</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-x：将tab转换成对等的空格</span><br><span class="line">-b：在文字内有反斜杠&#x27;\&#x27;时，仅保留反斜杠最后接的那个字符</span><br><span class="line"></span><br><span class="line"># 一种是用来将tab转换为对等的空格键</span><br><span class="line">cat /etc/man.config | col -x | cat -A | more</span><br><span class="line"></span><br><span class="line"># 另一种是用来将man page转成纯文本文件方便查阅</span><br><span class="line">man col | col -b &gt; /root/col.man</span><br></pre></td></tr></table></figure><p><strong>join</strong></p><p>处理两个文件之间的数据，主要是将两个文件中相同数据的那一行加在一起。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-t：以什么为分隔数据，并且对比第一个字段的数据</span><br><span class="line">-i：忽略大小写差异</span><br><span class="line">-1：代表第一个文件要用哪个字段来分析</span><br><span class="line">-2：第二个文件用哪个字段来分析                                                                                   </span><br></pre></td></tr></table></figure><p><strong>paste</strong></p><p>不对比两个文件的相关性，直接将两个文件的两行贴在一起。</p><p><strong>expand</strong></p><p>将[tab]转为空格键</p><h4 id="切割命令：split">切割命令：split</h4><p>可以将一个文件依据文件大小或行数来切割成为小文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b：接欲切割成的文件大小，可加单位</span><br><span class="line">-l：依据行数切割</span><br><span class="line">PREFIX：代表前导符，可作为切割文件的前导文字。</span><br><span class="line"></span><br><span class="line"># 将ls -al /的输出信息，每15行记录成一个文件</span><br><span class="line">[root@VM-4-12-centos ~]# ls -al / | split -l 15 - lsroot</span><br><span class="line">[root@VM-4-12-centos ~]# wc -l lsroot*</span><br><span class="line">  15 lsrootaa</span><br><span class="line">  15 lsrootab</span><br><span class="line">   3 lsrootac</span><br><span class="line">  33 总用量</span><br><span class="line"></span><br><span class="line"># 如果需要stdout/stdin但没有文件时，-会被认为是stdout/stdin</span><br></pre></td></tr></table></figure><h4 id="参数代换：xargs">参数代换：xargs</h4><p>用来产生某个命令的参数</p><p>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</p><p>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有这个必要，所以就有了 xargs 命令</p><blockquote><p><a href="https://www.runoob.com/linux/linux-comm-xargs.html">Linux xargs 命令 | 菜鸟教程 (runoob.com)</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 复制所有图片文件到 /data/images 目录下：</span><br><span class="line"># 这个命令首先使用ls *.jpg列出当前目录中所有以.jpg结尾的文件，然后将这些文件作为参数传递给xargs命令。-n1选项告诉xargs每次只传递一个参数给cp命令，-I &#123;&#125;选项指定了用&#123;&#125;来代替传递的参数。最后，cp &#123;&#125; /data/images将每个.jpg文件复制到/data/images目录下。</span><br><span class="line">ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images</span><br><span class="line"></span><br><span class="line"># 用 rm 删除太多的文件时候，可能得到一个错误信息：/bin/rm Argument list too long. 用 xargs 去避免这个问题。xargs -0 将 \0 作为定界符</span><br><span class="line"># -print0选项是find命令的一个参数，它用于在输出文件路径时使用空字符（null字符，ASCII码为0）来分隔文件名，而不是默认的换行符。</span><br><span class="line"># 通过指定-type f，find命令将只查找并返回普通的文件，不包括目录、符号链接等其他文件类型。</span><br><span class="line">find . -type f -name &quot;*.log&quot; -print0 | xargs -0 rm -f</span><br><span class="line"></span><br><span class="line"># 统计一个源代码目录中所有 php 文件的行数：</span><br><span class="line">find . -type f -name &quot;*.php&quot; -print0 | xargs -0 wc -l</span><br><span class="line"></span><br><span class="line"># 查找所有的 jpg 文件，并且压缩它们：</span><br><span class="line">find . -type f -name &quot;*.jpg&quot; -print | xargs tar -czvf images.tar.gz</span><br><span class="line"></span><br><span class="line"># 假如你有一个文件包含了很多你希望下载的 URL，你能够使用 xargs下载所有链接：</span><br><span class="line">cat url-list.txt | xargs wget -c</span><br></pre></td></tr></table></figure><h4 id="关于减号-的用途">关于减号 - 的用途</h4><p>减号作为标准输入/输出的替代符号：在一些命令或管道操作中，减号（-）有时表示标准输入或标准输出的替代符号。例如，在<code>tar</code>命令中使用<code>-</code>来代表标准输入或输出流，比如<code>tar -cvf - /home</code>中的<code>-</code>表示将打包结果输出到标准输出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -cvf - /home | tar -xvf -</span><br></pre></td></tr></table></figure><p>我们将/home里面的文件打包，但打包的数据不是记录到文件里，而是传送到stdout；经过管道后，将tar -cvf - /home传送到后面的tar -xvf -。后面的-则是取用前一个命令的stdout，因此就不用使用文件了。</p><h2 id="正则表达式与文件格式化处理">正则表达式与文件格式化处理</h2><h3 id="基础正则表达式">基础正则表达式</h3><p>使用正则表达式时，要特别注意留意当时环境的语系时什么，否则可能会出现不同的选取结果。</p><p>一般练习正则表达式时，因为兼容的是POSIX的标准，所以使用LANG=C</p><table><thead><tr><th>特殊符号</th><th>代表意义</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>代表英文大小写和数字，即0-9，A-Z，a-z</td></tr><tr><td>[:alpha:]</td><td>A-Z，a-z</td></tr><tr><td>[:upper:]</td><td>A-Z</td></tr><tr><td>[:lower:]</td><td>a-z</td></tr><tr><td>[:digit:]</td><td>0-9</td></tr></tbody></table><p><strong>基础正则表达式字符</strong></p><h3 id="grep高级用法">grep高级用法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A：后接数字，为after的意思，罗列除本行外的后续n行</span><br><span class="line">-B</span><br><span class="line">--color=auto</span><br><span class="line"></span><br><span class="line"># 用dmesg显示内核信息，grep筛选出含eth行，并用颜色区分，加上行号表示</span><br><span class="line">dmesg | grep -n &#x27;eth&#x27; --color=auto</span><br></pre></td></tr></table></figure><h3 id="sed工具">sed工具</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed [-nefr] [动作]</span><br><span class="line">-n：只有经过sed特殊处理的一行才会被列出来</span><br><span class="line">-e：直接在命令行模式进行sed动作编辑</span><br><span class="line">-f：将sed动作写入一个文件</span><br><span class="line">-r：支持扩展性正则表达式语法</span><br><span class="line">-i：直接修改读取的文件内容，而不是屏幕输出</span><br><span class="line"></span><br><span class="line">动作说明：[n1][,n2]function</span><br><span class="line">在n1到n2之间进行动作，动作必须得用两个单引号括住</span><br><span class="line">function包括：</span><br><span class="line">a：新增，下一行出现</span><br><span class="line">c：替换，接字符串，可以替换n1到n2之间的行</span><br><span class="line">d：删除，不接参数</span><br><span class="line">i：插入。上一行出现</span><br><span class="line">p：打印，通常与-n连用</span><br><span class="line">s：替换</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除2-5行</span><br><span class="line">sed &#x27;2,5d&#x27;</span><br><span class="line"></span><br><span class="line"># 在第二行后增加两行</span><br><span class="line">sed &#x27;2a drink tea&#x27; \</span><br><span class="line">&gt; drink coffee ?</span><br><span class="line"></span><br><span class="line"># 替换2-5行</span><br><span class="line">sed &#x27;2,5c hello&#x27;</span><br><span class="line"></span><br><span class="line"># 列出5-7行</span><br><span class="line">sed &#x27;5,7p&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出5-7行</span><br><span class="line">sed &#x27;5,7p&#x27;</span><br><span class="line"></span><br><span class="line"># sed &#x27;s/要被替换的字符串/新的字符串/g&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip a | grep 172.20.14.4</span><br><span class="line">    inet 172.20.14.4/24 brd 172.20.14.255 scope global vmbr0</span><br><span class="line"># 只保留172.20.14.255</span><br><span class="line">ip a | grep 172.20.14.4 | sed &#x27;s/^.*brd//g&#x27; | sed &#x27;s/scope.*$//g&#x27;</span><br><span class="line"># 两个斜杠 // 表示将匹配的内容替换为空，$表示行尾，^表示开头</span><br><span class="line"># .* 则表示匹配前面的字符（在这里是 . ）零次或多次，直到行尾（$）</span><br></pre></td></tr></table></figure><p>sed修改文件内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 最后一行新增</span><br><span class="line">sed -i &#x27;$a # This is a test&#x27; mine.txt</span><br><span class="line"># $表示最后一行，a表示新增操作</span><br><span class="line"></span><br><span class="line"># 将mine.tx每一行最后一个.改为!</span><br><span class="line">sed -i &#x27;s/\.$/\!/g&#x27; mine.txt</span><br><span class="line"></span><br><span class="line">s/: 表示替换。</span><br><span class="line">\.: 匹配一个句点字符。这里的反斜杠（\）是为了转义句点，因为句点在正则表达式中是一个特殊字符，表示匹配任意单个字符。</span><br><span class="line">/\!/: 替换为感叹号。</span><br><span class="line">g: 表示全局替换，即替换每一行中所有的匹配项，而不只是第一个。</span><br></pre></td></tr></table></figure><h3 id="扩展正则表达式egrep">扩展正则表达式egrep</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -v &#x27;^$&#x27; mine.txt | grep -v &#x27;^#&#x27;</span><br><span class="line"># 使用egrep一次查找。通过|</span><br><span class="line">egrep -v &#x27;^$|^#&#x27; mine.txt</span><br><span class="line"></span><br><span class="line"># 如果想查出来文件中含有!与&gt;的行时</span><br><span class="line">egrep -n &#x27;[!&gt;]&#x27; mine.txt</span><br></pre></td></tr></table></figure><h3 id="文件的格式化与相关处理">文件的格式化与相关处理</h3><h4 id="格式化打印printf">格式化打印printf</h4><p>和C语言用法一致，通常和awk搭配使用</p><h4 id="awk：数据处理工具">awk：数据处理工具</h4><p>awk倾向于将一行分成数个字段来处理，sed常常作用于一整行的数据处理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125;&#x27; filename</span><br></pre></td></tr></table></figure><p>整个awk的处理流程：</p><ol><li>读取第一行，并将第一行的数据填入$0 $1 $2等变量当中</li><li>依据条件类型的限制，判断是否需要进行后面的动作</li><li>做完所有的动作与条件类型</li><li>若还有后续的”行“的数据，则重复上面1—3的步骤，知道所有的数据都读完</li><li>默认分隔符为空格键或[tab]键</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@master1:~# last -n 5</span><br><span class="line">root     pts/1        172.22.160.176   Sat Aug 17 22:29   still logged in</span><br><span class="line">root     pts/0        172.22.160.176   Sat Aug 17 22:29   still logged in</span><br><span class="line">root     pts/1        172.22.160.101   Fri Aug 16 19:03 - 19:49  (00:45)</span><br><span class="line">root     pts/0        172.22.160.101   Fri Aug 16 19:03 - 19:49  (00:45)</span><br><span class="line">root     pts/3        172.22.160.176   Wed Aug 14 12:23 - 13:13  (00:50)</span><br><span class="line"></span><br><span class="line">wtmp begins Sun May 26 23:47:55 2024</span><br><span class="line">root@master1:~# last -n 5 | awk &#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span><br><span class="line">root    172.22.160.176</span><br><span class="line">root    172.22.160.176</span><br><span class="line">root    172.22.160.101</span><br><span class="line">root    172.22.160.101</span><br><span class="line">root    172.22.160.176</span><br><span class="line">        </span><br><span class="line">wtmp    Sun</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>awk如何知道有几行几列，通过内置变量</p><table><thead><tr><th>变量名称</th><th>代表意义</th></tr></thead><tbody><tr><td>NF</td><td>每一行（$0）拥有的字段总数</td></tr><tr><td>NR</td><td>目前awk所处理的是”第几行数据“</td></tr><tr><td>FS</td><td>目前的分隔符，默认是空格</td></tr></tbody></table><p>awk的格式内容如果想要以print打印时，记得非变量的文字部分，包含一小节printf提到的格式中，都需要使用双引号来定义出来（就和C语言的printf格式化输出一样），因为单引号已经是awk的命令固定用法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@master1:~# last -n 5 | awk &#x27;&#123;print $1 &quot;\t lines:&quot; NR &quot;\t columes:&quot; NF&#125;&#x27;</span><br><span class="line">root     lines:1         columes:10</span><br><span class="line">root     lines:2         columes:10</span><br><span class="line">root     lines:3         columes:10</span><br><span class="line">root     lines:4         columes:10</span><br><span class="line">root     lines:5         columes:10</span><br><span class="line">         lines:6         columes:0</span><br><span class="line">wtmp     lines:7         columes:7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>awk也有逻辑运算符</p><p>在awk中，变量可以直接使用，不需要$</p><h4 id="文件比较工具">文件比较工具</h4><p><strong>diff</strong></p><p>通常用在同一的文件（或软件）的新旧版本区别上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff -[bBi] from-file to-file</span><br><span class="line"></span><br><span class="line">from-file:想要比较的文件</span><br><span class="line">to-file：目的比较文件</span><br><span class="line"></span><br><span class="line">-b：忽略一行当中有多个空白的泣别（about me和about     me视为相同）</span><br><span class="line">-B：忽略空白行的区别</span><br><span class="line">-i：忽略大小写的不同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@master1:~/yiiong# cat test.old </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">root@master1:~/yiiong# cat test.new </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">no six line!</span><br><span class="line">root@master1:~/yiiong# diff test.old test.new</span><br><span class="line">3c3   </span><br><span class="line">&lt; 3</span><br><span class="line">---</span><br><span class="line">&gt; </span><br><span class="line">6c6</span><br><span class="line">&lt; 6</span><br><span class="line">---</span><br><span class="line">&gt; no six line!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3c3 表示第三行在两个文件中都有所不同（c 表示变更）。</span><br><span class="line">&lt; 3 表示在 test.old 文件中第三行的内容是 3。</span><br><span class="line">--- 分隔符用来区分两个文件的不同部分。</span><br><span class="line">&gt; 表示 test.new 文件中的相应位置是空白行。</span><br><span class="line"></span><br><span class="line">6c6 表示第六行在两个文件中都有所不同。</span><br><span class="line">&lt; 6 表示在 test.old 文件中第六行的内容是 6。</span><br><span class="line">--- 分隔符用来区分两个文件的不同部分。</span><br><span class="line">&gt; no six line! 表示 test.new 文件中的相应位置是 no six line!。</span><br><span class="line">总结一下，diff 的输出告诉我们：</span><br><span class="line">在 test.old 文件的第三行原本是数字 3，但在 test.new 文件中第三行变成了空白行。</span><br><span class="line">在 test.old 文件的第六行原本是数字 6，但在 test.new 文件中第六行变成了 no six line!。</span><br></pre></td></tr></table></figure><p><strong>cmp</strong></p><p>以“字节”为单位比较，通常用来比较而二进制文件。diff以“行”为单位比较。</p><p><strong>patch</strong></p><p>与diff搭配，比如先用diff比较出新旧版本的区别，并将区别文件制作成为补丁文件，再由补丁文件更新旧文件即可。</p><p>diff制作出来的比较文件通常使用扩展名.patch，新文件看到-会删除，看到+会加入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 制作补丁</span><br><span class="line">root@master1:~/yiiong# diff -Naur test.old test.new &gt; test.patch</span><br><span class="line">-N: 表示即使文件在其中一个文件夹中不存在也要报告差异。这通常用于比较两个目录的内容，确保即使一个文件在一个目录中不存在也会被标记为差异。</span><br><span class="line">-a: 表示将所有文件视为文本文件，并尝试进行文本比较，即使它们实际上可能是二进制文件。</span><br><span class="line">-u: 表示使用统一格式输出差异。这会提供更多的上下文行，使得差异更容易理解。</span><br><span class="line">-r: 表示递归地比较子目录。 </span><br><span class="line">root@master1:~/yiiong# cat test.patch </span><br><span class="line">--- test.old    2024-08-17 23:16:41.482797614 +0800  # 新旧文件信息</span><br><span class="line">+++ test.new    2024-08-17 23:17:21.191871581 +0800</span><br><span class="line">@@ -1,6 +1,6 @@</span><br><span class="line"> 1</span><br><span class="line"> 2</span><br><span class="line">-3 # 左侧文件删除 </span><br><span class="line">+  # 右侧文件加入</span><br><span class="line"> 4</span><br><span class="line"> 5</span><br><span class="line">-6</span><br><span class="line">+no six line!</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch -pN &lt; patch_file # 更新</span><br><span class="line">patch -R -pN # 还原</span><br><span class="line"></span><br><span class="line"># 更新</span><br><span class="line">root@master1:~/yiiong# patch -p0 &lt; test.patch </span><br><span class="line">patching file test.old</span><br><span class="line">root@master1:~/yiiong# cat test.old </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">no six line!</span><br><span class="line"># 还原</span><br><span class="line">root@master1:~/yiiong# patch -R -p0 &lt; test.patch </span><br><span class="line">patching file test.old</span><br><span class="line">root@master1:~/yiiong# cat test.old </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="文件打印准备：pr">文件打印准备：pr</h4><h2 id="学习shell-script">学习shell script</h2><h2 id="Linux账号管理与ACL权限控制">Linux账号管理与ACL权限控制</h2><h3 id="Linux的账号与用户组">Linux的账号与用户组</h3><h4 id="用户标识符：UID与GID">用户标识符：UID与GID</h4><p>每个登录的用户至少都会获得两个ID：用户ID(User ID)、用户组ID（Group ID）</p><p>每一个文件都会有所谓的所有者ID和用户组ID，当我们有要显示文件属性的需求时，系统会依据/etc/passwd与/etc/group的内容，找到UID/GID对应的账号与组名再显示出来。</p><h4 id="用户账号">用户账号</h4><p>输入账号密码后，系统处理流程</p><ol><li>先找/etc/passwd里有没有账号，没有则跳出。如果有的话将该账号对应的UID/GID（在/etc/group里）读出来。另外，该账号的主文件夹和shell设置也一起读出来。</li><li>核对密码表。进入/etc/shadow里面照对应的账号和UID，然后核对是否相符。</li><li>如果一切顺利，则进入shell的管控阶段。</li></ol><p><strong>/etc/passwd管理用户UID/GID，/etc/shhadow专门管理密码相关数据。</strong></p><p><strong>/etc/passwd文件结构</strong></p><p><strong>权限设置-rw-r–r–</strong></p><p>每一行代表一个账户，有几个行就有几个账号。里面有一些系统账号，例如bin、daemon、adm、nobody</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@master1:~# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>一共七个字段，用:分隔</p><ol><li><p>账号名称：就是账号，用来对用UID</p></li><li><p>密码：数据被保存在/etc/shadow里，所有有一个x</p></li><li><p>UID：用户标识符。<br>0就是系统管理员，可以有很多个root（不建议）。<br>1-499为系统账号，系统账号通常不可登录，所以会有/sbin/nologin这个特殊shell。系统账号分为两种：1-99有distributions自行创建的系统账号。100-499若用户有登录系统账号需求时，可以使用的账号UID</p><p>500-65535：可登录账号。</p></li><li><p>GID：用来规定组名和GID的对应。</p></li><li><p>用户消息说明列：基本没有什么重要用途。</p></li><li><p>主文件夹：用户的主文件夹。</p></li><li><p>Shell</p></li></ol><p><strong>/etc/shadow文件结构</strong></p><p>默认权限-rw-------</p><p>同样以:分隔，有9个字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@master1:~# cat /etc/shadow</span><br><span class="line">root:$y$j9T$IEU0qofFrP52Vg.iH212f/$gWhA6xXAYgf/.8K3GtRge0CdNvRm5PyAikE82L8Uen2:19869:0:99999:7:::</span><br><span class="line">daemon:*:19869:0:99999:7:::</span><br><span class="line">bin:*:19869:0:99999:7:::</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ol><li>账号名称：要与/etc/passwd相同。</li><li>密码：编辑加密过的密码。</li><li>最近更动密码的日期：<code>19869</code> 表示自 1970 年 1 月 1 日以来的天数。</li><li>密码不可被更动的天数（与第三个字段相比）：表示这个账号的密码在最近一次被更改后需要经过几天才可以再被修改！如果是0，则随时可以改动。</li><li>密码需要重新更改的天数（与第三个字段相比）：为了强制要求用户更改密码。</li><li>密码需要更改期限前的警告天数（与第五个字段相比）</li><li>密码过期后的账号宽限时间（与第五个字段相比）：密码有效期为“更新日期（字段三）+重新更改天数（字段五），过了后密码过期，但是还可以使用，只不过会有更改密码的提示。一旦失效就无法登录了。</li><li>账号失效日期</li><li>保留</li></ol><h4 id="有效与初始用户组：groups，newgrp">有效与初始用户组：groups，newgrp</h4><p><strong>/etc/group文件结构</strong></p><p>:分隔，有四列</p><ol><li>用户组名称</li><li>用户组密码：保存在/etc/gshadow</li><li>GID</li><li>此用户组支持的账号名称</li></ol><p>重要的是第四列。如果同时加入多个用户组，那么在操作时，那么应该以哪个用户组为准？<br><strong>有效用户组与初始用户组</strong></p><p>/etc/passwd里的GID就是所谓的初始用户组（initial group），也就是说当用户登录系统，系统就拥有这个用户组的相关权限。</p><p>当用户加入一个新的用户组后，新建文件的组时哪个就要看有效用户组。</p><p><strong>groups：有效与支持用户组的查看</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groups</span><br><span class="line">第一个输出是有效用户组</span><br></pre></td></tr></table></figure><p><strong>newgrp：有效用户组的切换</strong></p><p>切换时你想要切换的用户组必须是你已经有支持的用户组。</p><p>这个命令可以更改目前用户的有效用户组，而且是以另外一个shell来提供这个功能的。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408182119663.png" alt="image-20240818211919470"></p><p><strong>/etc/gshadow</strong></p><p>用来创建组管理员</p><p>四个字段</p><ol><li>用户组名</li><li>密码列：！表示无合法密码，所以无用户组管理员</li><li>用户组管理员的账号</li><li>该用户组的所属账号</li></ol><h3 id="新增与删除用户：useradd，相关配置文件，passwd，usermod，userdel">新增与删除用户：useradd，相关配置文件，passwd，usermod，userdel</h3><p><strong>useradd</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd [-u UID] [-g 初始用户组] [-G 次要用户组] [-mM]\</span><br><span class="line">&gt; [-c 说明栏] [-d 主文件夹绝对路径] [-s shell] 用户账号名</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408182135286.png" alt="image-20240818213513093"></p><p>当我们使用useradd创建一个账号</p><ul><li>在/etc/passwd里面创建一行与账号相关的数据</li><li>在/etc/shadow里面将此账号的密码相关参数填入，但还没有密码</li><li>在/etc/group里面加入一个与账号名称一模一样的组名</li><li>在/home下面创建一个与账号同名的目录作为用户主文件夹，权限为700</li></ul><p>然后passwd 账号  给予密码才算完成用户的创建</p><p>用useradd添加用户至少会改动的几个文件</p><ul><li>用户账号密码相关的：/etc/passwd，/etc/shadow</li><li>用户组相关：/etc/group，/etc/gshadow</li><li>用户的主文件夹：/home/账号名称</li></ul><p><strong>useradd参考文件</strong></p><p>/etc/deault/useradd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@master1:/home# useradd -D</span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home</span><br><span class="line">INACTIVE=-1</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">SKEL=/etc/skel</span><br><span class="line">CREATE_MAIL_SPOOL=no</span><br><span class="line">LOG_INIT=yes</span><br></pre></td></tr></table></figure><p>GROUP=100：新建账号的初始用户组使用GID为100</p><p>CentOS上默认的用户组为与账号名相同的用户组。</p><ul><li>私有用户组机制：系统会创建一个与账号一样的用户组给用户作为初始用户组。这种机制比较有保密性，使用这种机制将不会参考GROUP=100这个设置值。代表有CentOS、RHEL。家目录的权限会设置为700</li><li>公共用户组机制：以GROUP=100作为新建账号的初始用户组。</li></ul><p>HOME=/home：用户主文件夹的基准目录（basedir）</p><p>INACTIVE=-1：密码过期后是否会失效的设置值。-1为永远不会失效</p><p>EXPIRE=：账号失效日期。如果是付费的会员制系统可以设置。</p><p>SHELL=/bin/sh：默认使用的shell程序文件名</p><p>SKEL=/etc/skel：用户主文件夹参考基准目录。比如你新建了/etc/skel/www，那么新建用户的主文件夹就会有www这个目录。</p><p>CREATE_MAIL_SPOOL=no：创建用户的mailbox</p><p>UID/GID和还有密码参数参考/etc/login.defs这个文件</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408182221328.png" alt="image-20240818222110242"></p><p>上面的UID_MIN指的是可登录系统的一般账号的最小UID，系统分配UID时，先参考UID_MIN取最小数字，有/etc/passwd查找最大UID，二者相比，然后找出最大的那个再加上1就是新账号的UID。</p><p>如果想创建系统用的账号，使用-r参数的时候就会找“比500小的最大的那个UID+1”</p><p>useradd时至少会参考：</p><ul><li>/etc/default/useradd</li><li>/etc/login.defs</li><li>/etc/skel/*</li><li>还有/eetc/passwd那些</li></ul><p><strong>passwd</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd [--stdin]</span><br><span class="line">passwd [-l] [-u] [--stdin] [-S] \</span><br><span class="line">&gt; [-n 日期] [-x 日数] [-w 日数] [-i 日期] 账号</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408182231610.png" alt="image-20240818223156481"></p><p><strong>chage</strong></p><p>详细的密码参数显示</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408191701900.png" alt="image-20240819170120753"></p><p><strong>usermod</strong></p><p>进行账号相关数据的微调</p><p><strong>userdel</strong></p><p>删除用户</p><p>-r：连同用户的主文件夹一起删除</p><h4 id="用户功能">用户功能</h4><p><strong>finger</strong></p><p>查询用户相关信息，大部分都是/etc/passwd里的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">finger [-s] username</span><br><span class="line"></span><br><span class="line">-s：仅列出用户的账号、全名、终端机代号与登陆时间</span><br><span class="line">-m：列出与后面接的账号相同者</span><br></pre></td></tr></table></figure><p><strong>chfn</strong></p><p>账号个人信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chfn [-foph] [账号名]</span><br><span class="line"></span><br><span class="line">-f：接真实姓名</span><br><span class="line">-o：办公室房间号</span><br><span class="line">-p：办公室电话</span><br><span class="line">-h：家里电话号码</span><br></pre></td></tr></table></figure><p><strong>chsh</strong></p><p>change shell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l：列出可用shell</span><br><span class="line">-s：设置修改自己的shell</span><br></pre></td></tr></table></figure><p><strong>id</strong></p><p>查询某人的UID/GID</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id [useername]</span><br></pre></td></tr></table></figure><h4 id="新增与删除用户组">新增与删除用户组</h4><p><strong>groupadd</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd [-g gid] [-r] 用户组名</span><br><span class="line"></span><br><span class="line">-g：后面接某个特定GID</span><br><span class="line">-r：新建系统用户组</span><br></pre></td></tr></table></figure><p><strong>groupmod</strong></p><p>对group相关参数修改</p><p><strong>groupdel</strong></p><p><strong>gpasswd</strong></p><p>用户组管理员</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># root可以做的</span><br><span class="line">gpasswd groupname</span><br><span class="line">gpasswd [-A user1,...] [-M user3,...] groupname</span><br><span class="line">gpasswd [-rR] groupname</span><br><span class="line"></span><br><span class="line">：若没有任何参数时，表示给予 groupname 一个密码(/etc/gshadow) </span><br><span class="line">-A  ：将 groupname 癿主控权交由后面的使用者管理(该群组癿管理员) </span><br><span class="line">-M  ：将某些账号加入这个群组中！ </span><br><span class="line">-r  ：将 groupname 的密码删除</span><br><span class="line">-R  ：讥 groupname 的密码栏失效</span><br><span class="line"></span><br><span class="line"># 用户管理员可以做的</span><br><span class="line">gpasswd [-ad] user groupname</span><br><span class="line">-a：加入</span><br><span class="line">-d：删除</span><br></pre></td></tr></table></figure><h3 id="主机的具体权限规划：ACL的使用">主机的具体权限规划：ACL的使用</h3><p>针对个人的专属权限</p><blockquote><p>比如user是/pro（权限2770，2是SGID）这个项目的助理，他需要这个项目的内容，但是他不可以修改项目目录内的任何数据。</p><p>如果把user放进了支持/pro的用户组里，user拥有/pro的完整权限，他可以删除增加任何内容。</p><p>而修改/pro的目录权限后，user可以查阅数据，但是其他所有人均可以进入这个目录查阅数据。</p></blockquote><p>ACL是Access Control List缩写，主要目的是提供传统的owner、group、others的read、write、execute的权限之外的具体权限设置。</p><p>它可以针对单一用户、单一文件或目录进行r、w、x的权限设置，对于需要特殊权限的使用状况非常有帮助。</p><p>要使用ACL必须有文件系统的支持。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dumpe2fs -h /dev/hda2 # 由superblock内容查询</span><br><span class="line">...</span><br><span class="line">Default mount options: user_xattr acl</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="ACL的设置技巧：getfacl、setfacl">ACL的设置技巧：getfacl、setfacl</h4><p>getfacl：取得某个文件/目录的ACL设置项目</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408221135568.png" alt="image-20240822113516326"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setfacl [-bkRd] [&#123;-m|-x&#125; acl参数] 目标文件</span><br><span class="line">-m：设置后续的acl参数给文件</span><br><span class="line">-x：删除后续的acl参数</span><br><span class="line">-b：删除所有的acl</span><br><span class="line">-k：删除默认的acl参数</span><br><span class="line">-R：递归设置acl</span><br><span class="line">-d：设置默认acl</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.针对特定用户</span><br><span class="line"># 设置规定是&quot; u:&#123;用户账号列表&#125;:&#123;rwx&#125; &quot;</span><br><span class="line">setfacl -m u:user:rx test.txt</span><br><span class="line"># 设置成功后权限会多一个+</span><br><span class="line"></span><br><span class="line"># 无用户列表，代表设置该文件所有者</span><br><span class="line">setfacl -m u::rx test.txt</span><br><span class="line"></span><br><span class="line"># 2.针对特定用户组</span><br><span class="line"># 设置规范是&quot; g:&#123;&#125;:&#123;rwx&#125; &quot;</span><br><span class="line">setfacl -m g:mygroup:rx test.txt</span><br><span class="line"></span><br><span class="line"># 3.针对有效权限mask的设置</span><br><span class="line"># mask的意思是用户或组所设置的权限必须要存在于mask的权限设置范围内才会生效，此即有效权限 </span><br><span class="line"># &quot; m:[rwx] &quot;</span><br><span class="line">setfacl -m m:r test.txt</span><br><span class="line"></span><br><span class="line"># 4.针对默认权限的设置</span><br><span class="line"># &quot;d:[ug]:用户列表:[rwx]&quot;</span><br><span class="line"># 让user在/pro下面一直具有rx的默认权限</span><br><span class="line">setfacl d:u:user:rx /pro</span><br></pre></td></tr></table></figure><p>引例中可以这样设置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setfacl -m u:user:rx /pro</span><br><span class="line"></span><br><span class="line"># 设置成功后可以进入目录查看，但是不能修改数据，也就是写（w）</span><br></pre></td></tr></table></figure><p>取消全部的ACL属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setfacl - b 文件名</span><br></pre></td></tr></table></figure><h3 id="用户身份切换">用户身份切换</h3><p><strong>su</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su [-lm] [-c 命令] [username]</span><br><span class="line"></span><br><span class="line">-：如&quot;su -&quot;代表使用login-shell的变量文件读取方式登录系统</span><br><span class="line">-l：与-类似</span><br><span class="line">-m：-m与-p一样，表示使用目前的环境变量，不读取新用户的配置文件</span><br><span class="line">-c：仅进行一次命令</span><br></pre></td></tr></table></figure><p>登录 shell 是当用户通过命令行登录系统时启动的 shell。这种类型的 shell 通常会<strong>执行用户的登录脚本</strong>，这些脚本可以设置环境变量、定义别名等。</p><p>非登录 shell 是在不需要用户登录的情况下启动的 shell。这种类型的 shell <strong>通常不会执行登录脚本</strong>，而是在已经存在的 shell 环境中启动的。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408221155752.png" alt="image-20240822115542590"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408221155247.png" alt="image-20240822115553156"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408221154790.png" alt="image-20240822115459648"></p><ol><li>如果要完整地切换到新用户的环境，必须使用<code>su -username</code>或<code>su - | username</code>，才会连同/PATH/USER/MAIL等变量都转换成新用户地环境。</li><li>如果仅仅想要执行一次root的命令，可以利用su - -c&quot;命令串&quot;的方式出合理。</li><li>使用root切换成任何用户时，并不需要输入新用户的密码。</li></ol><p><strong>sudo</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo [-b] [u 新用户账号]</span><br><span class="line">-b：将后续的命令让系统自动执行</span><br><span class="line">-u：后面可以接欲切换的用户</span><br><span class="line"></span><br><span class="line"># 以sshd身份，在/tmp下面新建一个名为mysshd的文件</span><br><span class="line">sudo -u sshd touch /tmp/mysshd</span><br><span class="line"># 如果是一串命令，可以使用“sh -c”</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408221719756.png" alt="image-20240822171917573"></p><p>sudo执行的重点是：</p><ol><li>能否使用sudo，要看/etc/sudoers的设置值。</li><li>可使用sudo的是通过输入用户自己的密码来执行后续的命令串。</li></ol><p><strong>visudo与/etc/sudoers</strong></p><p>使用visudo修改/etc/sudoers是因为/etc/sudoers是有语法的，如果设置错误会造成无法使用sudo命令。</p><p><strong>单一用户可进行root所有命令与sudoers文件语法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果想让user账号可以使用root的任何命令</span><br><span class="line">visudo</span><br><span class="line">...</span><br><span class="line"># 用户账号  登录者的来源主机名=（可切换的身份） 可执行的命令</span><br><span class="line">root ALL= (ALL)       ALL  # 大约在76行</span><br><span class="line">user ALL= (all)       ALL  # 添加这一行</span><br></pre></td></tr></table></figure><p><strong>利用用户组以及免密码的功能处理visudo</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">visudo</span><br><span class="line">...</span><br><span class="line">%wheel   ALL= (ALL)    ALL # 大约在84行</span><br><span class="line">...</span><br><span class="line">%wheel   ALL= (ALL)  NOPASSWD: ALL #大约在87行</span><br><span class="line">...</span><br><span class="line"># 在最左边加%代表用户组的意思</span><br><span class="line">usermod -a -G wheel pro1</span><br></pre></td></tr></table></figure><p>上面的设置会造成任何加入wheel这个用户组的用户就能够使用sudo切换任何身份来操作任何命令。</p><p><strong>有限制的命令操作</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">visudo</span><br><span class="line">myuser  ALL= (root)  !/usr/bin/passwd, /user/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</span><br></pre></td></tr></table></figure><p>意思是myuser可以执行<code>passwd 任意字符</code>，但是<code>passwd</code>和<code>passwd root</code>这两个命令除外，保证myuser不能修改root密码。</p><p><strong>通过别名设置visudo</strong></p><p>假如我的pro1、pro2、pro3与user1、user2要加入上述的密码管理员的sudo列表中，可以新建一个账户别名为ADMPW的名称，然后处理一下这个名称</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">visudo</span><br><span class="line">User_Alias ADMPW = pro1, pro2, pro3, user1, user2</span><br><span class="line">Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /user/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</span><br><span class="line"></span><br><span class="line">ADMPW  ALL= (root) ADMPWCOM</span><br></pre></td></tr></table></figure><p><strong>sudo的时间间隔问题</strong></p><p>如果两次sudo的时间间隔超过五分钟，那就需要重新输入一次密码了。这么做是防止第一次执行sudo输入密码后，由于担心用户暂时离开，但有人跑来使用你的账号的原因，所以需要你输入第一次密码重新确认一次身份。</p><p><strong>sudo搭配su使用</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408221748782.png" alt="image-20240822174819602"></p><h3 id="用户的特殊shell与PAM模块">用户的特殊shell与PAM模块</h3><h4 id="特殊的shell，-sbin-nologin">特殊的shell，/sbin/nologin</h4><p>“无法登录”指的是这个用户无法使用bash或其他shell来登录，并不是说这个账户就无法使用其他的系统资源。</p><p>有些账号像一台提供邮件服务的Linux主机，它上面的账号大部分都是用来接受主机的信件，并不需要登录主机，这个时候就可以用/sbin/nologin作为他们的shell</p><p>可以新建/etc/nologin.txt来在用户登录时说明不能登录的原因。</p><h4 id="PAM">PAM</h4><p><strong>PAM模块简介</strong></p><p>PAM(Oluggable Authentication Modules，嵌入式模块)可以说是一台应用程序编程接口（Application Programming Interface，API），它提供了一连串的验证机制，只要用户将验证阶段的需求告知PAM，它就能回报用户和验证的结果（成功或者失败）</p><p>可以在写程序的时候将PAM模块功能加入，就能够利用它的验证功能，目前很多程序都会利用PAM。</p><p><strong>PAM模块设置语法</strong></p><p>passwd调用PAM的过程</p><ol><li>用户开始执行/usr/bin/passwd，并输入密码</li><li>passwd调用PAM模块进行认证</li><li>PAM模块到/etc/pam.d/passwd内找寻与程序（passwd）同名的配置文件</li><li>依据/etc/pam.d/passwd内的设置，引用相关的PAM模块逐步进行验证分析</li><li>将验证结果（成功、失败以及其他信息）后回传给passwd这个程序</li><li>passwd这支程序会依据PAM回传的结果决定下一个操作（重新输入新密码或者通过验证）</li></ol><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408221954314.png" alt="image-20240822195449176"></p><p>第一个字段：验证类型（Type）</p><ul><li>auth（authentication）：主要用来检验用户的身份验证，后续接的模块都是用来检验用户的身份的</li><li>account：大部分是在进行authorization（授权），主要是在验证用户是否具有正确的权限。</li><li>session：通常管理用户在这次登录期间PAM所给予的环境设置。通常用于记录用户登录与注销时的信息。</li><li>password：用于提供验证的修订工作。就是更改密码。</li></ul><p>这四个验证的类型通常有顺序。</p><p>第二个字段：验证的控制标志（control flag）</p><ul><li>required：成功则带有success的标志，失败就是failure，但不论成功或失败都会继续后续的验证流程。由于后续的验证流程可以就行进行，因此相当于有利于数据的登录日志，这也是PAM最常使用required的原因。</li><li>requisite：与required最大的区别就是失败后不会继续验证。</li><li>sufficient：与requisite相反，成功则success并终止验证，失败failure则继续。</li><li>optional：用来显示信息</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222005598.png" alt="image-20240822200528416"></p><p><strong>常用模块简介</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222008656.png" alt="image-20240822200804494"></p><ul><li>pam_securetty.so：限制root只能够从安全（secure）的终端机登录。</li><li>pam_nologin.so：限制一般用户是否能够登录主机之用。当/etc/nologin这个文件存在，则所有一般用户均无法再登录系统。</li><li>pam_selinux.so</li><li>pam_console.so：当系统出现某些问题，或者是某些时刻你需要使用特殊的终端接口登录主机，它可以帮助你处理一些文件权限的问题，让用户通过特殊终端接口顺利登录系统。</li><li>pam_loginuid.so：验证用户的UID是否真的是我们所需要的数值。</li><li>pam_env.so：用来设置环境变量的。</li><li>pam_UNIX.so：可以用于验证阶段的认证功能、可以用于授权阶段的账号许可证管理、可以用于会议阶段的日志文件记录、甚至可以用于密码更新阶段的检验。</li><li>pam_cracklib.so：可以检验密码的强度，</li><li>pam_limits.so：为ulimit提供能力。</li></ul><p>login的PAM验证机制流程：</p><ol><li>验证阶段（auth）：首先会先经过pam_securetty.so判断，如果用户是root，则会参考/etc/seecuretty的设置。接下来经过pam_env.so设置额外的环境变量；再通过pam_UNIX.so检验密码，若通过则好好回报login程序；若不通过则继续往下以pam_succeed_if.so判断UID是否大于500，若小于则回报失败，否则再往下以pam_deny.so拒绝连接。</li><li>授权阶段（account）：先以pam_nologin.so判断/etc/nologin是否存在，若存在则不许一般用户登录；接下来以pam_UNIX进行账号管理，再以pam_succeed_if.so判断UID是否大于500，若小于则不记录登录信息。最后以pam_permit.so允许该账号登录。</li><li>密码阶段（password）：先以pam_cracklib.so设置密码仅能尝试错误3次；接下来以pam_UNIX.so通过md5，shadow等功能进行密码检验，若通过则回报login程序，若不通过则以pam_deny.so拒绝登录。</li><li>会议阶段（session）：先以pam_selinux.so暂时关闭SELinux；使用pam_limits.so设置好用户能够操作的系统资源；登录成功后开始记录相关信息在登录文件中；以pam_loginuid.so设置不同的UID权限；打开pam_selinux.so</li></ol><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222034959.png" alt="image-20240822203421868"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222034242.png" alt="image-20240822203445058"></p><p><strong>其他相关文件</strong></p><p>主要都在/etc/security中</p><p><strong>limits.conf</strong>：ulimit的功能，限制用户资源</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222147638.png" alt="image-20240822214719490"></p><p><strong>/var/log/secure，/var/log/messages</strong>：PAM会把任何无法登录或者产生的一些错误记录在里面。</p><h3 id="Linux主机上的用户信息传递">Linux主机上的用户信息传递</h3><h4 id="查询用户：w，who，last，lastlog">查询用户：w，who，last，lastlog</h4><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222147757.png" alt="image-20240822214733598"></p><p>lastlog可以知道每个账号的最近登录时间，它会读取/var/log/lastlog</p><h4 id="用户对谈：write，mesg，wall">用户对谈：write，mesg，wall</h4><p>举例来说，我们的Linux上有user和root两个人在线，可以用write来对话</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">write 用户账号 [用户所在终端接口]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222153244.png" alt="image-20240822215323080"></p><p>如果user不想接受信息，但是必须接受root的信息。root可以拒绝接收来自其他用户的信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mesg n</span><br><span class="line"></span><br><span class="line"># 解开</span><br><span class="line">mesg y</span><br></pre></td></tr></table></figure><p>还可以进行广播，所有人都可以接收到信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wall &quot;your_message&quot;</span><br></pre></td></tr></table></figure><h4 id="用户邮件信箱：mail">用户邮件信箱：mail</h4><p>一般来说，mailbox都会放置在/var/spool/mail里</p><p>执行<code>mail username@localhost -s&quot;邮件标题&quot;</code></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222213712.png" alt="image-20240822221310558"></p><p>可以先用vi将信件内容编辑好，然后再用mail user -s “title” &lt; filename来将文件内容传输。</p><p>收信时同样使用mail</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222209400.png" alt="image-20240822220953256"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222209608.png" alt="image-20240822220908508"></p><p>可以想象为/var/spool/mail/user为user的信箱，而/home/user/mbox为收信箱</p><h3 id="手动新增用户">手动新增用户</h3><p><strong>pwck</strong></p><p>检查/etc/passwd这个账号配置文件内的信息，与实际的主文件夹是否存在等信息，呵呵还可以比较/etc/passwd /etc/shhadow的信息是否一致</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@master1:/etc/apt# pwck</span><br><span class="line">user &#x27;lp&#x27;: directory &#x27;/var/spool/lpd&#x27; does not exist</span><br><span class="line">user &#x27;news&#x27;: directory &#x27;/var/spool/news&#x27; does not exist</span><br><span class="line">user &#x27;uucp&#x27;: directory &#x27;/var/spool/uucp&#x27; does not exist</span><br><span class="line">user &#x27;list&#x27;: directory &#x27;/var/list&#x27; does not exist</span><br><span class="line">user &#x27;irc&#x27;: directory &#x27;/run/ircd&#x27; does not exist</span><br><span class="line">user &#x27;master1&#x27;: directory &#x27;/home/master1&#x27; does not exist</span><br><span class="line">pwck: no changes</span><br><span class="line"></span><br><span class="line"># 绝大部分账号都是系统账号，没有文件夹正常</span><br></pre></td></tr></table></figure><p>用户组检查可以用grpck</p><p><strong>pwconv</strong></p><p>将/etc/passwd内的账号与密码移动到/etc/shadow中</p><p><strong>pwunconv</strong></p><p>将/etc/shadow内的密码列数据写回/etc/passwd，并且删除/etc/shadow</p><p><strong>chpasswd</strong></p><p>可以读入未加密前的密码，并且经过加密后，将加密后的密码写入/etc/shadow中</p><p><strong>特殊账号（如纯数字账号）的手工新建</strong></p><p>纯数字账号容易引起系统的误解</p><p>整个流程：</p><ol><li>先新建所需要的用户组（vi /etc/group）</li><li>将/etc/group与/etc/gshadow同步（grpconv）</li><li>新建账号的各个属性（vi /etc/passwd）</li><li>将/etc/passwd与/etc/shadow同步（pwconv）</li><li>新建该账号的密码（passwd accountname）</li><li>新建用户主文件夹（cp -a /etc/skel /home/accountname）</li><li>更改用户主文件夹的属性（chown -R accounname.group /homr/accountname）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 手动新增用户</span><br><span class="line"></span><br><span class="line">root@master1:/etc/apt# vi /etc/group</span><br><span class="line">root@master1:/etc/apt# grpconv</span><br><span class="line">root@master1:/etc/apt# grep &#x27;yiiong&#x27;  /etc/group /etc/gshadow</span><br><span class="line">/etc/group:yiiong:x:520:</span><br><span class="line">/etc/gshadow:yiiong:x::</span><br><span class="line">root@master1:/etc/apt# vi /etc/passwd</span><br><span class="line">root@master1:/etc/apt# pwconv</span><br><span class="line">root@master1:/etc/apt# grep &#x27;yiiong&#x27;  /etc/passwd /etc/shadow</span><br><span class="line">/etc/passwd:yiiong:x:700:520::/home/yiiong:/bin/bash</span><br><span class="line">/etc/shadow:yiiong:x:19957:0:99999:7:::</span><br><span class="line">root@master1:/etc/apt# passwd yiiong</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">root@master1:/etc/apt# cp -a /etc/skel /home/yiiong/</span><br><span class="line">root@master1:/etc/apt# chown -R yiiong:yiiong /home/yiiong/</span><br><span class="line">root@master1:/etc/apt# chmod 700 /home/yiiong/</span><br></pre></td></tr></table></figure><p><strong>批量新建账号模板（适用于passwd --stdin参数）</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222238848.png" alt="image-20240822223820675"></p><p><strong>批量新建账号的范例（适用于连续数字，如学号）</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222241641.png" alt="image-20240822224143476"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222241936.png" alt="image-20240822224155845"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222242511.png" alt="image-20240822224247354"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408222242264.png" alt="image-20240822224255169"></p><h2 id="磁盘配额（Quota）与高级文件系统管理">磁盘配额（Quota）与高级文件系统管理</h2><h3 id="什么是Quota？">什么是Quota？</h3><p>Linux是多用户、多任务的环境，所以会有多用户共同使用一个硬盘空间的情况发生，如果其中少数几个用户占掉了大量的硬盘空间，肯定会影响其他用户的使用。因此管理员应当适当限制硬盘的空间给用户，以妥善分配系统资源。</p><p><strong>Quota的一般用途</strong></p><ul><li>针对www server，例如每个人的网页空间容量限制</li><li>针对mail server，例如每个人的邮件空间限制</li><li>针对file server，例如每个人最大的可用网络硬盘空间</li><li>限制某一用户组所能使用的最大磁盘配额</li><li>限制某一用户的最大磁盘配额</li><li>以Link的方式使邮件可以作为限制的配额（更改/var/spool/mail这个路径）</li></ul><p><strong>Quota的使用限制</strong></p><ul><li>仅能针对整个文件系统：例如你的/dev/sda5是挂载在/home下的，那么/home下面的所有目录都会受到限制</li><li>内核必须支持quota</li></ul><p><strong>Quota的日志文件</strong></p><p>并不是所有Linux上的账号都可以设置Quota，比如root就不行，因为整个系统所有的数据几乎都是它的。</p><p>所有你不能针对某个目录来进行Quota的设计，但你可以针对某个文件系统来设置。</p><p><strong>Quota的设置选项</strong></p><p>Quota针对整个文件系统的限制项目有以下几个部分：</p><p>1.容量限制或者文件数量限制（block或者inode）</p><p>限制inode用量（管理用户可以新建的文件数量）</p><p>限制block用量（管理用户磁盘容量的限制）</p><p>也就是说要么限制能创建多少文件，要么限制创建出的文件大小。</p><p>2.soft/hard：</p><p>hard：表示用户的用量绝对不会超过这个限制</p><p>soft：表示用户在低于soft限制时，可以正常使用磁盘，如果超过soft但是低于hard，每次用户登录系统时，系统会主动发出磁盘即将饱满的警告信息，并且还会给予一个宽限时间（gracetime）</p><p>3.会倒计时的宽限时间（grace time）</p><p>只有在用户的磁盘用量介于soft和hard之间时，才会出现且会倒数的一个时间。一般为7天，如果7天内不进行任何磁盘管理，那么soft会立刻替代hard，从而使用户的磁盘使用权可能会被锁住。</p><h3 id="Quota的实践">Quota的实践</h3><p><strong>范例</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408300040576.png" alt="image-20240830003959463"></p><p>先创建用户，并加入到用户组中</p><h4 id="文件系统支持">文件系统支持</h4><p>先确保/home为独立的文件系统</p><p>此外，VFAT文件系统并不支持Liunx Quota功能</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409012317646.png" alt="image-20240901231706487"></p><p>如果只想在开机中使用Quota</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o remount,usrquota,grpquota /home</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409012317385.png" alt="image-20240901231757260"></p><p>如果想开机就能自动挂载的话，可以修改/etc/fstab</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/fstab</span><br><span class="line">LABEL=/home /home ext4 defaults,usrquota,grpquota 1 2 </span><br></pre></td></tr></table></figure><h4 id="新建Quota配置文件">新建Quota配置文件</h4><p>Quota是通过分析整个文件系统中每个用户（用户组）拥有的文件总数与总容量，再将这些数据记录在该文件系统的最顶层目录，然后在该配置文件中再使用每个账号（或用户组）的限制值去规定磁盘使用量的。</p><p><strong>quotacheck：扫描文件系统并新建Quota配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quotacheck [-avugfM] [/mount_point]</span><br><span class="line"></span><br><span class="line">-a：扫描所有在/etc/mtab内，含有quota支持的文件系统。</span><br><span class="line">-u：针对用户扫描文件与目录的使用情况，还会新建aquota.user</span><br><span class="line">-v：显示扫面过程的信息</span><br><span class="line">-f：强制扫描文件系统，并写入新的quota配置文件</span><br><span class="line">-M：强制以读写的方式扫描文件系统，只有在特殊情况下才会使用。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409012338645.png" alt="image-20240901233812537"></p><h4 id="Quota的启动、关闭于限制值设置">Quota的启动、关闭于限制值设置</h4><p><strong>quotaon：启动quota服务</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-u：针对用户启动（aquota.user）</span><br><span class="line">-g：用户组</span><br><span class="line">-v：显示启动过程</span><br><span class="line">-a：根据/etc/mtab内的文件系统设置有关的quota，不加的话后面要加上特定的文件系统</span><br></pre></td></tr></table></figure><p>只需要启动一次就好，下次启动系统会自动启动quota</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409012346244.png" alt="image-20240901234616146"></p><p><strong>quotaoff：关闭quota服务</strong></p><p><strong>edquota：编辑账号/用户组的限值与宽限时间</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409012348529.png" alt="image-20240901234811368"></p><p>限制myquota1，然后以1为模板限制后面的用户，然后再限制用户组，最后设置宽限时间为14天</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409012351805.png" alt="image-20240901235153713"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409012355253.png" alt="image-20240901235510163"></p><h4 id="Quota限制值的报表">Quota限制值的报表</h4><p>quota的报表有两种模式</p><ol><li>针对每个个人或用户组的quota命令</li><li>针对整个文件系统的repquota命令</li></ol><p><strong>quota：单一用户的quota报表</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409012358437.png" alt="image-20240901235815287"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409012359246.png" alt="image-20240901235909145"></p><p>相比于edquota多了一个grace</p><p><strong>repquota：针对文件系统的限额做报表</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409020002970.png" alt="image-20240902000219825"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409020003044.png" alt="image-20240902000326954"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root 用户没有设置配额限制。</span><br><span class="line">用户 myquota1 至 myquota5 每人都有一个软限制为 245MB 和硬限制为 293MB 的磁盘空间。目前这些用户都没有使用任何磁盘空间。</span><br><span class="line">每个用户的文件数量都还没有使用，软硬限制也都未设置。</span><br><span class="line">统计数据显示总共有 7 个块，其中 1 个块是数据块。有 6 个用户被报告，并且使用的平均值为 6.000000，这个值通常是指每个用户使用的平均块数</span><br></pre></td></tr></table></figure><h4 id="测试与管理">测试与管理</h4><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409020038666.png" alt="image-20240902003829462"></p><p><strong>warnquota：对超过限额者发出警告信</strong></p><p><strong>setquota：直接于命令中设置quota限额</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409020043916.png" alt="image-20240902004333722"></p><h4 id="不改动既有系统的Quota实例">不改动既有系统的Quota实例</h4><p>link的使用</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409020045980.png" alt="image-20240902004507818"></p><h3 id="软件磁盘阵列（Software-RAID）">软件磁盘阵列（Software RAID）</h3><p>磁盘阵列全名RedundantArrays of Inexpensive Disks（RAID），即容错廉价磁盘阵列。</p><p>它可以通过一些技术，将多个较小的磁盘整合成为一个较大的磁盘设备，而这个较大的磁盘不仅可以存储，还具有数据保护的功能。</p><p>整个RAID有几个等级，使得整合后的磁盘具有不同的功能。</p><h4 id="RAID-0（等量模式，stripe）：性能最佳">RAID-0（等量模式，stripe）：性能最佳</h4><p>该模式如果使用相同型号相同容量的磁盘来组成，效果最佳。</p><p>RAID-0会将磁盘先切出等量的区块（chunk），然后当一个文件要写入RAID时，该文件会依据块的大小切割好，之后再依序放到各个磁盘里去。由于每个磁盘会交错存放数据，因此当你的数据要写入RAID时，数据会被等量放置在各个磁盘上面。</p><p>举例来说，你有两块磁盘组成RAID-0，当你有100MB的数据要写入时，每个磁盘会各自被分配50MB的存储量。</p><p>因为数据被分散到了不同的磁盘上， 每块磁盘负责的数据量就低了。所以说，越多块磁盘组成RAID-0，性能会越好，因为每块磁盘负责数据量就更低了。</p><p>但是RAID-0需要自行负担数据损毁的风险，只要任何一块出问题，整个数据都会无法读取。因为文件数据被切割，按序放在各个磁盘上，一旦有一个磁盘出问题，文件数据就会缺一块。</p><p>假如200GB和500GB组成RAID-0，那最初的400GB是分散在两块磁盘上的，后面再加入的数据就只能存放在500GB的硬盘上了。</p><h4 id="RAID-1（映像模式，mirror）：完整备份">RAID-1（映像模式，mirror）：完整备份</h4><p>也需要相同的磁盘容量，最好是一模一样的硬盘。</p><p>这种模式主要是让同一份数据完整的保存在两块磁盘上面。比如100MB的数据保存在RAID-1组成的两块磁盘上时，这两块磁盘会同步写入这100MB的数据。因此整体的容量几乎少了一半。</p><p>因为数据进入RAID-1后会被分成两股，并分别写入到各个磁盘里。因此在大量写入RAID-1的情况下，写入的额性能可能会变得很差。</p><p>好在如果你使用了硬件RAID卡，磁盘阵列卡会主动复制一份而不使用系统的I/O系统，性能还可以。</p><p>RAID-1最大的优点就是数据的备份，但是总容量是全部磁盘容量的一半。虽然RAID-1的写入性能不佳，但是它的读取能力还可以，因为RAID-1会自行取得最佳的读取平衡。</p><h4 id="RAID-0-1-RAID-1-0">RAID 0 + 1, RAID 1 + 0</h4><p>所谓的RAID 0 + 1，意思就是先让两块磁盘组成RAID-0，这样的设置共有两组，然后这两组RAID-0再组成RAID-1。</p><p>当有100MB的文件写入时，由于RAID-1的原因会被复制两份，一份给A和B，另一份给C和D。然后A和B又因为RAID-0，对数据切割并且按序排放。</p><h4 id="RAID-5：性能与数据备份的均衡考虑">RAID-5：性能与数据备份的均衡考虑</h4><p>至少需要三块以上的硬盘。</p><p>RAID-5的写入有点类似RAID-0，但是每个循环的写入过程中，在每块磁盘上还加入一个同位检查数据（Parity），这个数据会记录其他磁盘的备份数据，用于数据恢复。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409030017147.png" alt="image-20240903001749967"></p><p>任何一个磁盘损毁时都能够通过其他磁盘的检查码来重建原本磁盘内的数据。不过要注意的是由于同位检查码，因此RAID-5的总容量会是整体磁盘数量减一块。RAID-5仅能支持一块磁盘损毁的情况。</p><p>RAID-5由于要计算同位检查码，所以写入性能不佳。依赖硬件。</p><h4 id="Spare-Disk：预备磁盘功能">Spare Disk：预备磁盘功能</h4><p>当磁盘阵列的磁盘损毁时，需要将坏硬盘拔掉，再插入新硬盘。换完且顺利启动磁盘阵列后，磁盘阵列就会开始主动重建原本坏掉的那块磁盘数据到新的磁盘上。</p><p>Spare Disk可以让我们实时的在坏掉硬盘时主动重建。所谓的Spare Disk就是把一块或多块没有包含在原本磁盘阵列等级中的磁盘，当磁盘阵列有磁盘损毁时，Spare Disk会被主动拉入磁盘阵列，坏掉的磁盘会被主动踢出，然后重建系统。</p><h4 id="software，hardware-RAID">software，hardware RAID</h4><p>硬件磁盘阵列依靠磁盘阵列卡，但是卡太贵。</p><p>软件磁盘阵列依靠CPU的运算与I/O总线的资源。</p><p>CentOS通过mdadm这套软件，可以让分区组成RAID。</p><h4 id="软件磁盘阵列的设置">软件磁盘阵列的设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mdadm --create --auto=yes /dev/md[0-9] --raid-devices=N \</span><br><span class="line">&gt; --level=[015] --spare-devices=N /dev/sda[1,2,3......]</span><br><span class="line"></span><br><span class="line">--create：新建raid参数</span><br><span class="line">--auto=yes：决定新建后面接的软件磁盘阵列设备，例如/dev/md0</span><br><span class="line">--raid-devices=N：使用几个磁盘作为磁盘阵列</span><br><span class="line">--spare-devices=N：做备用设备</span><br><span class="line">--level=[015]：磁盘阵列等级</span><br><span class="line">--detail：后面所接磁盘阵列设备的详细信息</span><br></pre></td></tr></table></figure><p>以madam创建raid</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mdadm --create --auto=yes /dev/md0 --level=5 --raid-devices=4 --spare-deevices=1 /dev/sdb[1-5]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409072312422.png" alt="image-20240907231242244"></p><p>第一行：指出md0为raid5，使用了sdb[1-4]四块磁盘，每个磁盘[]内的数字为此磁盘在RAID中的额顺序，sdb5的(S)意思是它为spare</p><p>第二行：此磁盘阵列有608256个blocks（每个blocks为1kb），使用RAID 5,写入磁盘的小区块为512K，使用algorithm2磁盘阵列算法。</p><p>[m/n]代表此数组需要m个设备，且n个设备正常运行。U代表正常运作，4个U代表四个设备正常运行。</p><h4 id="仿真RAID错误的救援模式">仿真RAID错误的救援模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mdadm --manage /dev/md[0-9] [--add 设备] [--remove 设备] \</span><br><span class="line">&gt; [--fail 设备]</span><br><span class="line">--fail：会将后面的设备设置为出错的状态</span><br></pre></td></tr></table></figure><p>设置某个设备出错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mdadm --manage /dev/md0 --fail /dev/sdb3</span><br></pre></td></tr></table></figure><p>然后raid-5就会立刻将spare-device拉入raid组恢复正常</p><p><strong>开机自启动RAID并自动挂载</strong></p><p>利用uuid</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409082040859.png" alt="image-20240908204044731"></p><p><strong>关闭软件RAID</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">umount /dev/md0</span><br><span class="line">修改/etc/fstab，关闭开机自动挂载</span><br><span class="line">mdadm --stop /dev/md0</span><br><span class="line">cat /proc/mdstat # 查看状态</span><br><span class="line">修改/etc/mdadm.conf # 取消设置</span><br><span class="line">删除分区上的 RAID 超级块信息，使得这些设备不再被认为是 RAID 的一部分。</span><br><span class="line">mdadm --zero-superblock /dev/sdb1</span><br></pre></td></tr></table></figure><h3 id="逻辑卷管理器（Logical-Volume-Manager）">逻辑卷管理器（Logical Volume Manager）</h3><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409222307714.png" alt="image-20240922230749604"></p><p>LVM的重点在于可以弹性调整文件系统的容量，它可以整个多个物理分区在一起，让这些分区看起来就像是一个磁盘一样。</p><h4 id="什么是LVM：PV、PE、VG、LV的意义">什么是LVM：PV、PE、VG、LV的意义</h4><p>LVM的做法是将几个物理的分区（或磁盘）通过软件组合成为一块看起来是独立的大磁盘（VG），然后将这块大磁盘再经过分成为可用分区（LV），最终就能挂载使用了。</p><p><strong>PV（物理卷）：PhysicalVolume</strong></p><p>我们实际的分区需要调整系统标识符（system ID）成为8e（LVM的标识符），然后再经过pvcreate的命令将它转为LVM最底层的物理卷（PV），之后才能够将这些PV加以利用，调整system ID的方式就是fdisk</p><p><strong>VG（卷用户组）：Volume Group</strong></p><p>VG就是LVM组合成为的大磁盘。VG的大小与PE有关。</p><p><strong>PE（物理扩展块）：Physical Extend</strong></p><p>LVM默认使用4MB的PE块，而LVM的VG最多仅能含有65534个PE，因此默认的LVM VG会有256G.</p><p>PE是整个LVM最小的存储块，也就是说，我们的文件数据都是由写入PE来处理的。类似于文件系统中的block</p><p><strong>LV（逻辑卷）：Logical Volume</strong></p><p>最终的VG还会被切割成为LV，这个LV就是最后可以被格式化使用的类似分区。其大小与LV内的PE有关。</p><p>LV的设备文件通常指定为<code>/dev/vgname/lvname</code></p><p>LVM通过交换PE来进行数据转换，将原本LV内的PE移转到其他设备中以降低LV容量。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409082240554.png" alt="image-20240908224033407"></p><p>VG内的PE会分给虚拟的LV，如果VG要扩充，加上其他的PV即可。LV要扩充的话，加入VG中没有使用的PE。</p><p><strong>实现流程</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409082244375.png" alt="image-20240908224402222"></p><p>数据写入LV时，写入硬盘有两种方式</p><ol><li>线性模式（linear）：假如将/dev/hda1、/dev/hda2加入VG，并且整个VG只有一个LV时，所谓线性模式就是/dev/hda1用完后，再用/dev/hda2</li><li>交错模式（triped）：将一个数据分成两部分，分别写入两个分区，类似于RAID-0</li></ol><p>LVM最主要的用途是弹性调整文件系统的容量，而不是着眼在性能上。如果强调性能与备份，那么直接使用RAID即可。</p><h4 id="LVM实作流程">LVM实作流程</h4><p>步骤：</p><ol><li><p>分出5个分区，设置Type为Linux LVM</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br><span class="line">使用t</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409082309009.png" alt="image-20240908230935910"></p></li><li><p>全部的分区整合为1个VG，VG名称设置为myvg，PE大小为16MB</p></li><li><p>全部VG容量都丢给LV，LV名称设置为mylv</p></li><li><p>最终LV格式化为ext4，挂载在/mnt/lvm</p></li></ol><h5 id="PV阶段">PV阶段</h5><ul><li>pvcreate：将物理分区新建成为PV</li><li>pvscan：查询目前系统里面任何具有PV的磁盘</li><li>pvdisplay：显示出目前系统上面的PV状态</li><li>pvremove：将PV属性删除，让该分区不具有PV属性</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409082337557.png" alt="image-20240908233743388"></p><p>pvscan回显的最后一行，显示：整体PV的量 / 已经使用VG的PV量 / 剩余PV量</p><p>Allocatable：是否已经被分配</p><h5 id="VG阶段"><strong>VG阶段</strong></h5><ul><li>vgcreate：新建VG</li><li>vgscan：查找系统上面是否有VG</li><li>vgdisplay：显示目前系统上面VG的状态</li><li>vgextend：在VG内增加额外的PV</li><li>vgreduce：在VG内删除PV</li><li>vgchange：设置VG是否启动</li><li>vgremove：删除一个VG</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vgcreate [-s N[mgt]] VG名称 PV名称</span><br><span class="line"></span><br><span class="line">-s：后面接PE的大小</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409092209364.png" alt="image-20240909220909232"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409092213809.png" alt="image-20240909221312672"></p><p>sdb5没有用，此时扩容VG</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vgeextend myvg /dev/sdb5</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409092210010.png" alt="image-20240909221056926"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409092211801.png" alt="image-20240909221109661"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409092213809.png" alt=""></p><h5 id="LV阶段"><strong>LV阶段</strong></h5><p>创造出VG后，接下来就要新建分区。这个分区就是LV。</p><p>假设要将刚才那个myvg磁盘分成mylv，整个VG的容量都被分配到mylv里面。</p><p>命令和vg的一样，多了lvresize：对LV进行容量大小的调整</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lvcreate [-L N[mgt]] [-n LV名称] VG名称</span><br><span class="line">lvcreate [-l N] [-N lV名称] VG名称</span><br><span class="line"></span><br><span class="line">-L：后面接容量，最小单位是PE。因此这个数量必须是PE的倍数</span><br><span class="line">-l：后面接PE的个数，而不是数量。</span><br><span class="line">-n：后面接LV的名称</span><br></pre></td></tr></table></figure><p>把myvg全部的PE分给mglv</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409092235575.png" alt="image-20240909223526496"></p><p>创建好的LV的信息，此时LV的名称为/dev/myvg/mylv</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409092235431.png" alt="image-20240909223559288"></p><h5 id="放大LV容量">放大LV容量</h5><ol><li>用fdisk 设置新的具有8e systemID的分区</li><li>利用pvcreate构建PV</li><li>利用vgextend将PV加入我们的myvg</li><li>利用lvresize将新加入的PV内的PE加入mylv</li><li>通过resize2fs将文件系统的容量确实增加</li></ol><p>因为文件系统格式化的时候新建是多个block group，因此我们可以通过在文件系统当中增加block group的方式来增减文件系统的量，而增减block group就是利用resize2fs</p><p>新建新的PV</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409111637305.png" alt="image-20240911163716964"></p><p>使用vgextend加大VG</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409111638389.png" alt="image-20240911163833230"></p><p>可以看到PE从之前的48增加到92</p><p>利用lvresize放大LV，将剩余的31个PE加入LV</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409111641987.png" alt="image-20240911164116875"></p><p>LV被放大到1.44G左右，但是文件系统却没有增加（大约0.96G）</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409111647049.png" alt="image-20240911164703938"></p><p>使用resize2fs处理文件系统</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resize2fs [-f] [devices] [size]</span><br><span class="line"></span><br><span class="line">-f：强制resize</span><br></pre></td></tr></table></figure><p>完整地将LV的容量扩充到整个文件系统</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409131925492.png" alt="image-20240913192515324"></p><p>当使用 lvextend 命令扩展逻辑卷时，实际上只是增加了逻辑卷的大小，但这并不会自动扩展文件系统。文件系统不知道逻辑卷已经被扩展，因此它仍然认为自己的大小没有变化。所以需要使用resize2fs来扩充文件系统的大小。</p><h5 id="缩小LV容量">缩小LV容量</h5><p>先缩小文件系统</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409131932035.png" alt="image-20240913193253943"></p><p>然后将LV缩小</p><p>使用lvresize</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409131935743.png" alt="image-20240913193503605"><br><img src="https://gitee.com/beatrueman/images/raw/master/img/202409131935277.png" alt="image-20240913193517128"></p><p>接下来将/dev/sdc1移出myvg这个VG中，所以需要先确定/dev/sdc1里面的PE完全不被使用后才能将其抽离。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pvremove /dev/sdc1</span><br></pre></td></tr></table></figure><h4 id="LVM的系统快照（snapshot）">LVM的系统快照（snapshot）</h4><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409222151329.png" alt="image-20240922215101082"></p><p>LVM会预留一个区域作为数据存放处。快照区与系统区共享所有的PE数据，因此快照区的内容与文件系统是一模一样的。等系统运行一段时候后，假设A区域的数据被改动了，则改动前的系统会将该区域的数据移动到快照区。</p><p>快照区如何创建？首先由于快照区与原来的LV共享很多PE区块，因此快照与被快照的LV必须在同一个VG上面。</p><p><strong>快照区的创建</strong></p><p>使用lvcreate创建系统快照区，给予20个PE</p><p>-s表示创建快照的意思</p><p>-n后面接快照区的设备名称</p><p>-l接PE的数量来作为快照区</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409222200879.png" alt="image-20240922220005769"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409222204236.png" alt="20240922-220414"></p><p>快照的工作原理是使用一种称为“写时复制”（Copy-on-Write, COW）的技术。作用是在某一时刻捕获原卷的状态，以便你可以在这个时间点恢复数据或进行备份。</p><p>此时挂载/dev/vg/myss到/mnt/ss和/dev/vg/lv到/mnt/lvm，发现两个数据一模一样</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409222210106.png" alt="image-20240922221011979"></p><p><strong>利用快照复原系统</strong></p><p>要注意的是要复原的数据不能高于快照区所能负载的实际容量</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409222212901.png" alt="image-20240922221244750"></p><p>此时我们删除/mnt/lvm/lost+found，然后利用/mnt/myss/进行复原</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409222214488.png" alt="image-20240922221406294"></p><p>可以看到快照区已经被使用了10%，因为原始的文件系统被改动过</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409222218644.png" alt="20240922-221705"></p><p>利用快照区进行复原</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409222234974.png" alt="image-20240922223410866"></p><p>复原的过程有些特别。需要先进行备份，</p><p><em>为什么不可以直接格式化/dev/vg/lv，然后将/dev/vg/myss直接复制给lv呢？</em></p><p>因为myss是lv的快照，快照卷主要用于存储原卷数据的变化，而不是完整的数据副本。</p><p>1.快照卷中的数据块引用的是原卷在创建快照时的状态，但这些状态已经不存在了，因为原卷的数据已经被新的文件系统覆盖。</p><p>2.如果你格式化整个lv时，原本的文件系统所有数据就会被移动到ss。如果ss的容量不够大，那么这部分的数据将无法复制到ss内，数据也会无法复原。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -jcv -f /bak/lvm.tar.bz2 *</span><br><span class="line">-j表示使用bzip2进行压缩</span><br><span class="line">-c归档</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将快照区删除</span><br><span class="line">umount /mnt/ss</span><br><span class="line">lvremove /dev/vg/myss</span><br><span class="line"></span><br><span class="line">umount /mnt/lvm</span><br><span class="line">mkfs -t ext4 /dev/vg/lv</span><br><span class="line">mount /dev/vg/lv /mnt/lvm</span><br><span class="line">tar -jxv -f /bak/lvm.tar.bz2 -C /mnt/lvm</span><br><span class="line"># 此时/mnt/lvm就还原了</span><br></pre></td></tr></table></figure><h4 id="LVM的关闭">LVM的关闭</h4><ol><li>先卸载所有系统上面的LVM文件系统（包括快照和所有的LV）</li><li>使用lvremove删除LV</li><li>使用vgchange -an VGname 让VGname这个VG不具有Active的标志</li><li>使用vgremove删除VG</li><li>使用pvremove删除PV</li><li>最后使用fdisk将ID修改回来</li></ol><h3 id="例行性工作（corntab）">例行性工作（corntab）</h3><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">Cron</th><th style="text-align:center">Systemd</th></tr></thead><tbody><tr><td style="text-align:center">设计理念</td><td style="text-align:center">定时任务调度</td><td style="text-align:center">系统和服务管理</td></tr><tr><td style="text-align:center">配置方式</td><td style="text-align:center">crontab 文件，五字段语法</td><td style="text-align:center">.timer 和 .service 单元文件，灵活的时间表达</td></tr><tr><td style="text-align:center">适用场景</td><td style="text-align:center">简单任务，用户级任务</td><td style="text-align:center">复杂任务，系统级任务</td></tr><tr><td style="text-align:center">用户管理</td><td style="text-align:center">每个用户可以有自己的 crontab</td><td style="text-align:center">系统级别的任务管理</td></tr><tr><td style="text-align:center">持久性</td><td style="text-align:center">不支持持久性任务</td><td style="text-align:center">支持持久性任务</td></tr><tr><td style="text-align:center">依赖管理</td><td style="text-align:center">有限的依赖管理</td><td style="text-align:center">强大的依赖管理</td></tr><tr><td style="text-align:center">日志管理</td><td style="text-align:center">依赖系统日志或自定义日志</td><td style="text-align:center">集成的日志管理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux相关问题与解决</title>
      <link href="/2024/11/08/Linux%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
      <url>/2024/11/08/Linux%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Q1：yum仓库报错，提示无法从-var-lib-rpm-打开软件包数据库">Q1：yum仓库报错，提示无法从 /var/lib/rpm 打开软件包数据库</h2><p><strong>问题描述</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos ~]# yum update</span><br><span class="line">错误：db5 错误(11) 来自 dbenv-&gt;open：资源暂时不可用</span><br><span class="line">错误：无法使用 db5 - 资源暂时不可用 (11) 打开 Packages 索引</span><br><span class="line">错误：无法从 /var/lib/rpm 打开软件包数据库</span><br><span class="line">CRITICAL:yum.main:</span><br><span class="line"></span><br><span class="line">Error: rpmdb open failed</span><br></pre></td></tr></table></figure><p><strong>原因</strong></p><p>误操作导致rpm数据库损坏</p><p><strong>解决</strong></p><p>刪除<code>/var/lib/rpm/_db.*</code>，然后<code>rebuilddb</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos ~]# cd /var/lib/rpm</span><br><span class="line">[root@VM-4-12-centos rpm]# rm -rf _db.*</span><br><span class="line">[root@VM-4-12-centos rpm]# rpm --rebuilddb</span><br></pre></td></tr></table></figure><h2 id="Q2：frp-穿透不上">Q2：frp 穿透不上</h2><p><strong>问题描述</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos frp-opi-wp]# ./frps -c frps.toml</span><br><span class="line">2024/01/23 21:51:18 [I] [root.go:104] frps uses config file: frps.toml</span><br><span class="line">2024/01/23 21:51:18 [I] [service.go:225] frps tcp listen on 0.0.0.0:7000</span><br><span class="line">2024/01/23 21:51:18 [I] [root.go:113] frps started successfully</span><br><span class="line">2024/01/23 21:51:26 [I] [service.go:563] [315e3525738f8c2b] client login info: ip [124.23.134.193:2449] version [0.53.2] hostname [] os [linux] arch [arm64]</span><br><span class="line">2024/01/23 21:51:46 [I] [control.go:359] [315e3525738f8c2b] client exit success</span><br><span class="line">2024/01/23 21:51:49 [I] [service.go:563] [fa610981038e4f2e] client login info: ip [124.23.134.193:2452] version [0.53.2] hostname [] os [linux] arch [arm64]</span><br><span class="line">2024/01/23 21:53:12 [I] [control.go:359] [fa610981038e4f2e] client exit success</span><br><span class="line">2024/01/23 21:54:00 [I] [service.go:563] [e82f6daa8dd087ab] client login info: ip [124.23.133.67:57501] version [0.53.2] hostname [] os [linux] arch [arm64]</span><br><span class="line"># 未显示代理信息</span><br></pre></td></tr></table></figure><p><strong>原因</strong></p><p><code>frpc.toml</code>中代理名被改变</p><p>值得注意的是，在0.53.2版本中的配置文件已经使用了.toml，而不是以前的.ini</p><p><strong>解决方案</strong></p><p>这个<code>[[proxies]]</code>一定不能更改，通过<code>name</code>变量来命名</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202401232222075.png" alt="20240123-222152"></p><p>穿透成功服务端日志</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos frp-opi-wp]# ./frps -c frps.toml</span><br><span class="line">2024/01/23 21:56:35 [I] [root.go:104] frps uses config file: frps.toml</span><br><span class="line">2024/01/23 21:56:35 [I] [service.go:225] frps tcp listen on 0.0.0.0:7000</span><br><span class="line">2024/01/23 21:56:35 [I] [root.go:113] frps started successfully</span><br><span class="line">2024/01/23 22:00:08 [I] [service.go:563] [cfa62ad515ec4c40] client login info: ip [124.23.134.193:2457] version [0.53.2] hostname [] os [linux] arch [arm64]</span><br><span class="line">2024/01/23 22:00:50 [I] [control.go:359] [cfa62ad515ec4c40] client exit success</span><br><span class="line">2024/01/23 22:11:24 [I] [service.go:563] [301af5cc896139a2] client login info: ip [124.23.133.67:57505] version [0.53.2] hostname [] os [linux] arch [arm64]</span><br><span class="line">2024/01/23 22:15:27 [I] [control.go:359] [301af5cc896139a2] client exit success</span><br><span class="line"># 可以注意到有[ssh]出现了</span><br><span class="line">2024/01/23 22:16:29 [I] [service.go:563] [399ffe49d60af967] client login info: ip [124.23.133.67:57508] version [0.53.2] hostname [] os [linux] arch [arm64]</span><br><span class="line">2024/01/23 22:16:29 [I] [tcp.go:82] [399ffe49d60af967] [ssh] tcp proxy listen port [6000]</span><br><span class="line">2024/01/23 22:16:29 [I] [control.go:401] [399ffe49d60af967] new proxy [ssh] type [tcp] success</span><br><span class="line">2024/01/23 22:16:44 [I] [proxy.go:204] [399ffe49d60af967] [ssh] get a user connection [124.221.233.12:47008]</span><br><span class="line">2024/01/23 22:21:12 [I] [proxy.go:115] [399ffe49d60af967] [ssh] proxy closing</span><br></pre></td></tr></table></figure><h2 id="Q3：Kubernetes强制删除处于Terminating状态的namespace">Q3：Kubernetes强制删除处于Terminating状态的namespace</h2><h2 id="Q4：旧版NFS配置StorageClass的SelfLink问题">Q4：旧版NFS配置StorageClass的SelfLink问题</h2><p><strong>问题描述：</strong></p><p>使用NFS配置StorageClass时，你可能会遇到这样的问题。</p><p>在创建pvc指定storageClass为NFS时，pvc一直处于pending状态。<br>查看nfs-storage的pod提示</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405112206274.png" alt="68cc3d2d1916d49007eb4b16300af48e"></p><p>根据网上的提示</p><p>修改<code>/etc/kubernetes/mainfestes/kube-apiserver.yaml</code>，在<code>command</code>字段下添加<code>--feature-gates=RemoveSelfLink=false</code></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405112206935.png" alt="59082ac86d9655f3edb3652f973786bb"></p><p>但是提示禁止修改，有时还会造成集群失联（慎重apply！将原先添加的字段删除等一段时间可以恢复）</p><p>如何可以正常使用？似乎是与K8s版本相关。</p><p><strong>环境：</strong></p><p>Kubernetes单节点，版本v1.25.0</p><p><strong>原因：</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405112208999.jpg" alt="img_v3_02ap_63cb6506-9b5b-4018-93bb-0c3b656bacfg"></p><p><strong>解决：</strong></p><p>安装支持nfs-subdir-external-provisioner的NFS</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner</span><br><span class="line"></span><br><span class="line">helm update</span><br><span class="line"></span><br><span class="line">helm pull nfs-subdir-external-provisioner/nfs-subdir-external-provisioner</span><br><span class="line"></span><br><span class="line"># 改镜像、加NFS服务器地址、加共享目录路径、设置默认SC（可选）</span><br><span class="line">helm install nfs nfs-subdir-external-provisioner/nfs-subdir-external-provisioner -f values.yaml -n nfs-sc</span><br></pre></td></tr></table></figure><h2 id="Q5：docker无法创建容器">Q5：docker无法创建容器</h2><p><strong>问题描述</strong>：</p><p>docker无法创建新的容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: unable to apply cgroup configuration: unable to start unit &quot;docker-a894cd187acfb351f1d43246680a644054604ab292c2cbf04847567d351a31c6.scope&quot; (properties [&#123;Name:Description Value:&quot;libcontainer container a894cd187acfb351f1d43246680a644054604ab292c2cbf04847567d351a31c6&quot;&#125; &#123;Name:Slice Value:&quot;system.slice&quot;&#125; &#123;Name:Delegate Value:true&#125; &#123;Name:PIDs Value:@au [2919971]&#125; &#123;Name:MemoryAccounting Value:true&#125; &#123;Name:CPUAccounting Value:true&#125; &#123;Name:IOAccounting Value:true&#125; &#123;Name:TasksAccounting Value:true&#125; &#123;Name:DefaultDependencies Value:false&#125;]): Failed to activate service &#x27;org.freedesktop.systemd1&#x27;: timed out (service_start_timeout=25000ms): unknown ERROR: Service &#x27;ferry&#x27; failed to build : Build failed</span><br></pre></td></tr></table></figure><p><strong>原因：</strong></p><p>报错提到<code> unable to apply cgroup configuration</code></p><p>应该是与cgroup有关</p><p>docker可能默认使用cgroup v2，而<code>cat /proc/cgroup</code>后显示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@master1:~/yiiong/ferry# cat /proc/cgroups</span><br><span class="line">#subsys_name    hierarchy       num_cgroups     enabled</span><br><span class="line">cpuset  0       154     1</span><br><span class="line">cpu     0       154     1</span><br><span class="line">cpuacct 0       154     1</span><br><span class="line">blkio   0       154     1</span><br><span class="line">memory  0       154     1</span><br><span class="line">devices 0       154     1</span><br><span class="line">freezer 0       154     1</span><br><span class="line">net_cls 0       154     1</span><br><span class="line">perf_event      0       154     1</span><br><span class="line">net_prio        0       154     1</span><br><span class="line">hugetlb 0       154     1</span><br><span class="line">pids    0       154     1</span><br><span class="line">rdma    0       154     1</span><br><span class="line">misc    0       154     1</span><br></pre></td></tr></table></figure><p>所有子系统的 hierarchy 列值都是 0，并且每个子系统都有独立的条目。这表明系统使用的是 cgroups v1，而不是 cgroups v2。</p><p>在 cgroups v2 中，所有子系统会统一在一个层级中管理，而不会分别列出。</p><p><strong>解决：</strong></p><p>在<code>/etc/docker/daemon.json</code>中添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=cgroupfs&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使docker使用cgroup v1</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器运维 </tag>
            
            <tag> Trouble Shooting </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器运维</title>
      <link href="/2024/11/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/"/>
      <url>/2024/11/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器介绍">服务器介绍</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/269897820">服务器概念、组成和架构详解 - 知乎 (zhihu.com)</a></p></blockquote><p><a href="https://link.zhihu.com/?target=https%3A//www.pangdayun.com/">服务器</a>**的英文名称为“ Server”，是指在网络上提供各种服务的高性能计算机。**作为网络的节点，存储、处理网络上80％的数据、信息，因此也被称为网络的灵魂。</p><p><a href="https://link.zhihu.com/?target=https%3A//www.pangdayun.com/">服务器</a>**和普通计算机的功能是类似的。**只是相对于普通计算机，服务器在稳定性、安全性、性能等方面都要求更高，因此CPU、芯片组、内存、磁盘系统、网络等硬件和普通计算机有所不同。</p><p>分类：</p><p>**按产品形态：**塔式服务器、机架服务器、刀片服务器、机柜服务器等。</p><p><img src="https://pic1.zhimg.com/v2-a294fcbfe3ce3e34d86a39a17304e700_r.jpg" alt="img"></p><p><strong>按指令集架构</strong>：CISC服务器、RISC服务器、EPIC服务器</p><p><strong>按处理器数量</strong>：单路服务器、双路服务器（主流）、四路服务器、八路服务器等</p><h2 id="服务器的组装与排线">服务器的组装与排线</h2><h3 id="服务器的主要组成部件">服务器的主要组成部件</h3><p>服务器硬件主要包括：中央处理器(CPU)、内存(RAM)、芯片组、I/O（RAID卡、网卡、HBA卡）、硬盘、机箱（电源、风扇）</p><h4 id="中央处理器-CPU">中央处理器(CPU)</h4><p>与普通的个人计算机不同，服务器可以拥有多个CPU，具体数量取决于服务器的型号和配置。一些小型服务器可能只有一个CPU插槽，而大型服务器可以有多达数十个CPU插槽。此外，每个CPU插槽可以安装多核处理器，从而进一步提高性能。因此，一个服务器可以拥有多个物理和逻辑CPU核心。</p><h4 id="I-O">I/O</h4><p>I/O的意思是<strong>输入/输出操作</strong></p><p>当服务器处理用户请求时，它需要从输入设备（如键盘、鼠标等）读取输入数据，并将输出数据发送到输出设备（如显示器、打印机等）显示或保存。服务器进行的许多操作，例如读取和写入文件、网络通信等，都涉及输入/输出操作。</p><h4 id="RAID卡">RAID卡</h4><p>RAID卡（Redundant Array of Independent Disks controller）是一种硬件设备，用于管理和控制RAID（Redundant Array of Independent Disks）阵列。</p><p>RAID卡通常安装在计算机的主板上或者插槽中，它提供了一种方便的方法来配置和管理RAID阵列。RAID卡通常具有多个SATA或SAS接口，用于连接硬盘驱动器。它还包含一个处理器和缓存来更好地管理和控制硬盘驱动器的读写操作。 使用RAID卡，用户可以配置多个硬盘驱动器为RAID阵列，并选择不同的RAID级别，如RAID 0、RAID 1、RAID 5等。RAID卡还提供了更高的数据安全性和可靠性，通过使用冗余数据存储和热备份等功能来保护数据免受硬盘故障的影响。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308062151463.png" alt="image-20230806215131356"></p><h4 id="网络接口卡-NIC">网络接口卡(NIC)</h4><p>服务器网卡（Network Interface Card，NIC）是一种用于连接服务器和计算机网络的硬件设备。它负责接收和发送数据包，将服务器与网络中的其他设备连接起来。网卡通常包括一个物理接口（如以太网接口）和一个控制芯片，用于处理网络数据的传输和处理。服务器网卡通常具有高速传输能力、可靠性和安全性，以满足服务器对网络连接的高要求。</p><p>**PCIe网卡：**PCIe是一种最新的标准，在计算机和服务器主板上很流行。PCIe网卡现在有五个版本，分别支持不同的速度。</p><h4 id="HBA卡">HBA卡</h4><p>HBA卡（Host Bus Adapter）是一种接口卡，用于将计算机主机和存储设备（如硬盘、磁带机等）连接起来。它负责处理主机和存储设备之间的数据传输和通信，并提供传输协议的支持。HBA卡通常使用Fibre Channel、SCSI或SAS等接口标准，可以在不同的计算机系统和存储设备之间实现快速、可靠的数据传输。HBA卡在企业级存储系统中起着至关重要的作用，可提高数据传输速度、稳定性和可扩展性。</p><h3 id="网线水晶头接法">网线水晶头接法</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/146932098">网线水晶头接法图解 - 知乎 (zhihu.com)</a></p></blockquote><p>网线水晶头有两种接法，一种是<strong>直连互联法</strong>，一种是**<a href="https://baike.baidu.com/item/%E4%BA%A4%E5%8F%89%E4%BA%92%E8%81%94/19463384?fromModule=lemma_inlink">交叉互联法</a>**。</p><p><strong>交叉线</strong>的做法是：一头采用**<a href="https://baike.baidu.com/item/568A/9679118?fromModule=lemma_inlink">568A</a>**标准，一头采用<a href="https://baike.baidu.com/item/568B/9679177?fromModule=lemma_inlink">568B</a>标准。</p><p><strong>平行（直通）线</strong>的做法是：两头同为<strong>568</strong>A标准或<strong>568</strong>B标准。</p><p>标准568A：绿白-1，绿-2，橙白-3，蓝-4，蓝白-5，橙-6，棕白-7，棕-8。</p><p>标准568B：橙白-1，橙-2，绿白-3，蓝-4，蓝白-5，绿-6，棕白-7，棕-8。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202308062203919.png" alt="568A"></p><h2 id="服务器的配置">服务器的配置</h2><h3 id="BIOS">BIOS</h3><p><a href="https://www.cnblogs.com/zdz8207/p/all-bios-coms.html">怎么进入bios设置界面，电脑如何进入BIOS进行设置,怎么进入BIOS的方法集合 - 大自然的流风 - 博客园 (cnblogs.com)</a></p><p>BIOS 是计算机上的基本输入/输出系统（Basic Input/Output System）的缩写。它是一种固化在计算机主板上的软件，<strong>用于初始化计算机硬件并协助操作系统启动。</strong></p><p>BIOS 的主要功能包括：</p><p>1.初始化硬件：在计算机启动时，BIOS会检测和初始化各种硬件设备，包括处理器、内存、硬盘、光驱、显示器等。</p><p>2.提供基本的输入/输出功能：BIOS提供了最基本的键盘、鼠标和显示器的输入/输出功能，以便用户能够在计算机启动时进行操作。</p><p>3.启动操作系统：BIOS负责加载、验证并启动操作系统。它会寻找操作系统的引导扇区，并将控制权转交给操作系统的启动程序</p><p>4.提供硬件配置选项：BIOS还提供了一些配置选项，允许用户根据需要修改硬件设置，例如调整系统时钟、启用/禁用某些设备等。</p><h3 id="用U盘装系统">用U盘装系统</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/99422332">如何用U盘装系统？ - 知乎 (zhihu.com)</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_46047285/article/details/104105817">windows 10 使用U盘重装系统，超详细！！！_晚风花间寺中人的博客-CSDN博客</a></p></blockquote><p>系统文件也就是我们的操作系统，一般有两种格式：<strong>ISO格式和GHO格式</strong>。ISO格式又分为原版系统和GHOST封装系统二种。</p><p><strong>安装步骤思路：</strong></p><p>1.软件与硬件准备</p><p>2.用U盘装系统软件制作启动U盘</p><p>3.下载您需要的gho系统文件并复制到U盘中</p><p>4.进入BIOS设置U盘启动顺序</p><p>5.用U盘启动快速安装系统</p><h3 id="Linux">Linux</h3><h4 id="Linux命令">Linux命令</h4><blockquote><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全 | 菜鸟教程 (runoob.com)</a></p></blockquote><h4 id="文本操作">文本操作</h4><blockquote><p><a href="https://www.runoob.com/linux/linux-vim.html">Linux vi/vim | 菜鸟教程 (runoob.com)</a></p></blockquote><h4 id="Shell">Shell</h4><blockquote><p><a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程 | 菜鸟教程 (runoob.com)</a></p></blockquote><h4 id="linux系统下的磁盘的格式化-分区-挂载">linux系统下的磁盘的格式化/分区/挂载</h4><p><strong>磁盘格式化：</strong></p><p>1.首先，使用命令<code>fdisk -l</code>查看系统中的磁盘分区情况。找到需要格式化的磁盘，比如 <code>/dev/sdb</code>。</p><p>2.然后，使用命令<code>fdisk /dev/sdb</code>对磁盘进行分区操作。按一定的分区规则进行分区，然后保存并退出。</p><p>3.接下来，使用命令<code>mkfs</code>将分区格式化为对应的文件系统，比如<code>mkfs.ext4 /dev/sdb1</code>。</p><p><strong>磁盘分区：</strong></p><p>1.使用命令<code>fdisk /dev/sdb</code>对磁盘进行分区操作。根据需要进行分区的大小、类型等设置，然后保存并退出。</p><p>2.使用命令<code>partprobe</code>或重启系统使分区生效。</p><p><strong>磁盘挂载：</strong></p><p>1.首先，选择一个目录作为挂载点，比如<code>/mnt/mydisk</code>。</p><p>2.使用命令<code>mount</code>将磁盘分区挂载到挂载点上，比如<code>mount /dev/sdb1 /mnt/mydisk</code>。如果需要指定文件系统类型，可以使用<code>-t</code>选项，比如<code>mount -t ext4 /dev/sdb1 /mnt/mydisk</code>。</p><p>3.可以通过修改<code>/etc/fstab</code>文件，实现开机自动挂载。在文件中添加一行</p><p>格式为<code>&lt; device &gt; &lt; mount point &gt; &lt; file system &gt; &lt; options &gt; &lt; dump &gt; &lt; pass &gt;</code></p><p>比如<code>/dev/sdb1 /mnt/mydisk ext4 defaults 0 2</code>。</p><h4 id="service与-timer">.service与.timer</h4><blockquote><p><a href="https://blog.csdn.net/qq_16268979/article/details/114771854">linux文件目录：systemd的service文件说明_linux service文件存放路径_啊荻～的博客-CSDN博客</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/uetucci/p/7762053.html">Linux学习-systemctl 针对 timer 的配置文件 - uetucci - 博客园 (cnblogs.com)</a></p></blockquote><h4 id="SSH">SSH</h4><blockquote><p><a href="https://zhuanlan.zhihu.com/p/191627275">使用Linux，从正确配置ssh开始 - 知乎 (zhihu.com)</a></p></blockquote><h4 id="命令后台运行">命令后台运行</h4><blockquote><p><a href="https://blog.csdn.net/Pan_peter/article/details/128875714">Linux——让程序在后台运行（四种方法+使用推荐）_linux 后台运行_Pan_peter的博客-CSDN博客</a></p></blockquote><h2 id="iptables-的使用">iptables 的使用</h2><h3 id="四表">四表</h3><ul><li>raw</li><li>mangle</li><li>nat</li><li>filter</li><li>security</li></ul><p>table有优先级：由高到低排列为：<strong>raw -&gt; mangle -&gt; nat -&gt; filter</strong>；</p><h4 id="Raw-Table">Raw Table</h4><p>提供且仅提供一个让数据包绕过连接跟踪的框架。</p><h4 id="Mangle-Table">Mangle Table</h4><p>修改数据包IP头部，还可以对数据包打一个仅在内核内有效的标记（mark），后续对于该数据包的处理可以用到这些标记。</p><h3 id="NAT-Table">NAT Table</h3><p>用来做网络地址转换</p><ul><li>SNAT：用于<strong>局域网服务访问公网服务</strong>的场景。即将局域网发出的请求的原地址转换成NAT主机所拥有的公网IP地址，从而与公网服务进行通信；</li><li>DNAT：用于<strong>公网请求访问局域网服务</strong>的场景。即将从公网接收到的请求的目的地址通过NAT规则所配置的局域网网段进行目标服务器局域网地址的转换，从而与局域网内服务通信。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器运维 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署示范</title>
      <link href="/2024/11/08/%E9%83%A8%E7%BD%B2%E7%A4%BA%E8%8C%83/"/>
      <url>/2024/11/08/%E9%83%A8%E7%BD%B2%E7%A4%BA%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1>Harbor的部署</h1><blockquote><p><a href="https://goharbor.io/">Harbor官方文档</a></p></blockquote><blockquote><p><a href="https://github.com/goharbor/harbor">Harbor Github仓库</a></p></blockquote><blockquote><p><a href="https://cloud.tencent.com/developer/article/1865259">Harbor 入门指南-腾讯云开发者社区-腾讯云 (tencent.com)</a></p></blockquote><h2 id="配置">配置</h2><ul><li>服务器：腾讯云</li><li>Linux版本：<code>Linux VM-4-12-centos 3.10.0-1160.90.1.el7.x86_64</code></li><li>Docker：<code>Docker version 24.0.5, build ced0996</code></li><li>Docker-Comose：<code>docker-compose version 1.24.1, build 4667896b</code></li></ul><h2 id="下载Harbor离线安装包">下载Harbor离线安装包</h2><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fgoharbor%2Fharbor%2Freleases&amp;source=article&amp;objectId=2371563">Harbor Github Releases</a></p><p>解压后的目录如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">harbor</span><br><span class="line">├── common.sh         # 通用命令，使用install.sh驱动</span><br><span class="line">├── harbor.v2.7.3.tar.gz  </span><br><span class="line">├── harbor.yml.tmpl   # 配置模板</span><br><span class="line">├── install.sh        # 安装脚本</span><br><span class="line">├── LICENSE</span><br><span class="line">└── prepare    </span><br></pre></td></tr></table></figure><h2 id="OpenSSL自签证书">OpenSSL自签证书</h2><p>为了保证Harbor的安全性，我们需要为Harbor配置一个SSL证书以保证安全，防止黑客篡改</p><blockquote><p>使用可信证书颁发机构（CA）签发的证书，要么1年需要换一次，要么3个月需要续签名一次。可是我们的Harbor启动后，除非有安全漏洞，否则启动后，可能几年都不会做一次变更。这个时候，怎么办呢？</p></blockquote><p>我们使用OpenSSL自签名证书，不过浏览器不信任这种证书，用户在首次访问时会收到安全警告</p><h3 id="创建目录">创建目录</h3><p>存放生成的证书</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /root/cert</span><br><span class="line">cd /root/cert/</span><br></pre></td></tr></table></figure><h3 id="生成CA证书">生成CA证书</h3><p><strong>生成CA密钥</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out ca.key 4096</span><br></pre></td></tr></table></figure><ul><li><code>genrsa</code>：表示要生成一个 RSA 密钥对。</li><li><code>-out ca.key</code>：指定生成的私钥将保存在名为 <code>ca.key</code> 的文件中。</li><li><code>4096</code>：表示生成的 RSA 私钥使用 4096 位的密钥长度。</li></ul><p><strong>生成CA证书</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -new -nodes -sha512 -days 3650 \</span><br><span class="line"> -subj &quot;/C=CN/ST=Chongqing/L=Chongqing/O=Redrock/OU=Personal/CN=harbor.yiiong.top&quot; \</span><br><span class="line"> -key ca.key \</span><br><span class="line"> -out ca.crt</span><br></pre></td></tr></table></figure><ul><li><p><code>-x509</code>：表示生成自签名的 X.509 格式证书。</p></li><li><p><code>-new</code>：表示生成一个新的证书请求。</p></li><li><p><code>-nodes</code>：表示生成的私钥不加密。</p></li><li><p><code>-sha512</code>：表示使用 SHA-512 算法进行签名。</p></li><li><p><code>-days 3650</code>：表示证书的有效期为 3650 天（大约 10 年）。</p></li><li><p><code>-subj &quot;/C=CN/ST=Chongqing/L=Chongqing/O=Redrock/OU=Personal/CN=harbor.yiiong.top&quot;</code>：设置证书的 Subject 字段信息，包括国家（C=CN）、省份（ST=Chongqing）、城市（L=Chongqing）、组织（O=Redrock）、组织单位（OU=Personal）和通用名称（CN=harbor.yiiong.top）。</p></li><li><p><code>-key ca.key</code>：指定使用之前生成的 <code>ca.key</code> 文件作为证书的私钥。</p></li><li><p><code>-out ca.crt</code>：指定生成的证书将保存在名为 <code>ca.crt</code> 的文件中。</p><p><strong>.crt (Certificate)</strong>：<code>.crt</code> 文件是数字证书文件的扩展名，用于存储证书的内容。证书通常用于建立安全连接，并验证服务器（或客户端）的身份和信任</p></li></ul><h3 id="生成Server证书">生成Server证书</h3><p><strong>生成 Server 证书私钥</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成密钥</span><br><span class="line">openssl genrsa -out server.key 4096</span><br></pre></td></tr></table></figure><h3 id="生成Server证书签名请求（CSR）"><strong>生成Server证书签名请求（CSR）</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -sha512 -new \</span><br><span class="line"> -subj &quot;/C=CN/ST=Chongqing/L=Chongqing/O=Redrock/OU=Personal/CN=harbor.yiiong.top&quot; \</span><br><span class="line"> -key server.key \</span><br><span class="line"> -out server.csr</span><br></pre></td></tr></table></figure><ul><li><p><code>-out server.csr</code>：指定生成的证书签名请求将保存在名为 <code>server.csr</code> 的文件中。</p><p><strong>.csr (Certificate Signing Request)</strong>：<code>.csr</code> 文件用于向证书颁发机构（CA）提交请求，申请签发数字证书。</p></li></ul><h3 id="生成-x509-v3-证书扩展文件">生成 x509 v3 证书扩展文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; v3.ext &lt;&lt;-EOF</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">extendedKeyUsage = serverAuth</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1=harbor.yiiong.top</span><br><span class="line">DNS.2=hostname</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><code>v3.ext</code> 可以被用于在签署证书时指定证书的一些属性和要求，比如证书的用途、适用主题名称等。通常用于构建自签名证书或配置 CA 签发证书时的扩展属性。</p><h3 id="使用-CA-证书签发-Server-证书"><strong>使用 CA 证书签发 Server 证书</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -sha512 -days 3650 \</span><br><span class="line">    -extfile v3.ext \</span><br><span class="line">    -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">    -in server.csr \</span><br><span class="line">    -out server.crt</span><br></pre></td></tr></table></figure><ul><li><code>-extfile v3.ext</code>：指定了存储证书扩展信息的文件 <code>v3.ext</code>。</li><li><code>-CA ca.crt</code>：指定了 CA 证书文件 <code>ca.crt</code>，用于签署服务器证书。</li><li><code>-CAkey ca.key</code>：指定用于签署证书的 CA 私钥文件 <code>ca.key</code>。</li><li><code>-CAcreateserial</code>：表示自动生成一个序列号文件，用于签署的证书。</li><li><code>-in server.csr</code>：表示输入待签署的服务器证书签名请求文件 <code>server.csr</code>。</li><li><code>-out server.crt</code>：表示输出签署的服务器证书文件为 <code>server.crt</code>。</li></ul><p>一共有如下这些</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos harbor]# cd /root/cert</span><br><span class="line">[root@VM-4-12-centos cert]# ll</span><br><span class="line">总用量 28</span><br><span class="line">-rw-r--r-- 1 root root 2045 12月 30 23:32 ca.crt</span><br><span class="line">-rw-r--r-- 1 root root 3247 12月 30 23:32 ca.key</span><br><span class="line">-rw-r--r-- 1 root root   17 12月 30 23:39 ca.srl</span><br><span class="line">-rw-r--r-- 1 root root 2094 12月 30 23:39 server.crt</span><br><span class="line">-rw-r--r-- 1 root root 1712 12月 30 23:38 server.csr</span><br><span class="line">-rw-r--r-- 1 root root 3243 12月 30 23:32 server.key</span><br><span class="line">-rw-r--r-- 1 root root  248 12月 30 23:35 v3.ext</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202403212259115.png" alt="image-20240321225956058"></p><h2 id="为-Harbor-和-Docker-配置证书"><strong>为 Harbor 和 Docker 配置证书</strong></h2><p><strong>将 server 证书和密钥复制到 Harbor 主机上的 /data/cert 目录中</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/cert</span><br><span class="line">cp server.crt /data/cert/</span><br><span class="line">cp server.key /data/cert/</span><br></pre></td></tr></table></figure><p><strong>转换 server.crt 为 server.cert</strong></p><p>.crt 和 .cert 本质上没有区别，并且通常可以互换使用。为什么还要把.crt转为.cert呢？因为Docker 客户端默认将文件名 <code>.cert</code> 视为客户端证书.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform PEM -in server.crt -out server.cert</span><br></pre></td></tr></table></figure><p><strong>将 server 证书，密钥和 CA 证书复制到 Harbor 主机上的 Docker 证书目录中</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/docker/certs.d/harbor.yiiong.top:8443</span><br><span class="line">cp server.key /etc/docker/certs.d/harbor.yiiong.top:8443</span><br><span class="line">cp server.cert /etc/docker/certs.d/harbor.yiiong.top:8443</span><br><span class="line">cp ca.crt /etc/docker/certs.d/harbor.yiiong.top:8443</span><br></pre></td></tr></table></figure><p>查看 Docker 证书目录文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos harbor.yiiong.top:8443]# ll</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r-- 1 root root 2045 12月 30 23:42 ca.crt</span><br><span class="line">-rw-r--r-- 1 root root 2094 12月 30 23:41 server.cert</span><br><span class="line">-rw-r--r-- 1 root root 3243 12月 30 23:41 server.key</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重启Docker</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="初始化Harbor">初始化Harbor</h2><p>将模板复制一份</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp harbor.yml.tmpl harbor.yml</span><br></pre></td></tr></table></figure><p>在<code>harbor.yml</code>中修改如下的参数</p><ul><li>hostname：Harbor的访问地址，最好写ip</li><li>https/port：对外暴露8443端口，记得放行8443端口</li><li>https/certificate: 使用宿主机的SSL证书文件。也就是.crt的位置</li><li>https/certificate: 使用宿主机的SSL证书文件，是.key的位置</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312302358195.png" alt="image-20231230235823077"></p><h2 id="安装">安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure><h2 id="访问">访问</h2><p>https访问，并且加上8443端口号</p><h2 id="登录">登录</h2><p>在<code>/etc/docker/daemon.json</code>中加入Harbor仓库地址以允许 Docker 客户端连接到该不安全的注册表而不进行证书验证。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;insecure-registries&quot;:[&quot;https://harbor.yiiong.top:8443&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="更改配置的操作">更改配置的操作</h2><p><strong>使用 prepare 脚本生成 HTTPS 配置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./prepare</span><br></pre></td></tr></table></figure><p><strong>删除原有 Harbor 容器</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose down -v</span><br></pre></td></tr></table></figure><p><strong>重新启动 Harbor</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="问题与解决">问题与解决</h3><p>1.出现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@master2:~# docker login https://harbor.yiiong.top:8443</span><br><span class="line">Username: admin</span><br><span class="line">Password: </span><br><span class="line">Error response from daemon: Get &quot;https://harbor.yiiong.top:8443/v2/&quot;: Get &quot;https://172.20.14.31:8443/service/token?account=admin&amp;client_id=docker&amp;offline_token=true&amp;service=harbor-registry&quot;: tls: failed to verify certificate: x509: cannot validate certificate for 172.20.14.31 because it doesn&#x27;t contain any IP SANs</span><br></pre></td></tr></table></figure><p>原因：<code> /etc/docker/daemon.json</code>中没有更新 Harbor 注册表的证书配置，我们只需要把Harbor地址添加到 Docker 的不安全注册表列表中，允许 Docker 客户端连接到该不安全的注册表而不进行证书验证。</p><p>1.出现<code>Error response from daemon: failed to create task for container: failed to initialize logging driver: dial tcp [::1]:1514: connect: connection refused</code></p><p>取消rsyslog.conf文件第19，20行注释，并将514改为1514</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/rsyslog.conf</span><br><span class="line"></span><br><span class="line"># 取消注释并修改</span><br><span class="line">$ModLoad imtcp</span><br><span class="line">$InputTCPServerRun 1514</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312301419517.png" alt="harbor"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 重启rsyslog</span><br><span class="line">systemctl restart rsyslog.service</span><br></pre></td></tr></table></figure><p>2.出现<code>Error response from daemon: driver failed programming external connectivity on endpoint nginx (191f6b9a13a1d60e6f9656c7f8030be35bcd96395c524f8fc4af5c83e2b45f26): Error starting userland proxy: listen tcp4 0.0.0.0:8080: bind: address already in use</code></p><p>修改<code>harbor.yml</code>中的http/port为没有占用的端口即可，然后记得放行端口</p><h1>Kubernetes的部署</h1><blockquote><p><a href="http://www.bearxiong2003.xyz/index.php/2023/06/07/kubernetes%E9%83%A8%E7%BD%B2/">Kubernetes部署 – Yiiong’s blog (bearxiong2003.xyz)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器运维 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维常用工具</title>
      <link href="/2024/11/08/%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/11/08/%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="Harbor">Harbor</h2><blockquote><p><a href="https://goharbor.io/">Harbor (goharbor.io)</a></p></blockquote><p>尽管Docker官方提供了公共的镜像仓库DockerHub，但从安全性和稳定性等方面考虑，部署私有镜像仓库是非常有必要的。Harbor是一个由VMware公司开源的企业级的Docker Registry管理项目，是我们搭建私有镜像仓库的不二之选。</p><h3 id="整体架构">整体架构</h3><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202403212031265.png" alt="img"></p><p>如上图所示是 Harbor 2.0 的架构图，从上到下可分为代理层、功能层和数据层。</p><ul><li><strong>代理层</strong>：代理层实质上是一个 Nginx 反向代理，负责接收不同类型的客户端请求，包括浏览器、用户脚本、Docker 等，并根据请求类型和 URI 转发给不同的后端服务进行处理。</li><li><strong>功能层</strong>：<ul><li><strong>Portal</strong>：是一个基于 Argular 的前端应用，提供 Harbor 用户访问的界面。</li><li><strong>Core</strong>：是 Harbor 中的核心组件，封装了 Harbor 绝大部分的业务逻辑。</li><li><strong>JobService</strong>：异步任务组件，负责 Harbor 中很多比较耗时的功能，比如 Artifact 复制、扫描、垃圾回收等。</li><li><strong>Docker Distribution</strong>：Harbor 通过 Distribution 实现 Artifact 的读写和存取等功能。</li><li><strong>RegistryCtl</strong>：Docker Distribution 的控制组件。</li><li><strong>Notary（可选）</strong>：基于 TUF 提供镜像签名管理的功能。</li><li><strong>扫描工具（可选）</strong>：镜像的漏洞<a href="https://cloud.tencent.com/product/tools?from_column=20065&amp;from=20065">检测工具</a>。</li><li><strong>ChartMuseum（可选）</strong>：提供 API 管理非 OCI 规范的 Helm Chart，随着兼容 OCI 规范的 Helm Chart 在社区上被更广泛地接受，Helm Chart 能以 Artifact 的形式在 Harbor 中存储和管理，不再依赖 ChartMuseum，因此 Harbor 可能会在后续版本中移除对 ChartMuseum 的支持。</li></ul></li><li><strong>数据层</strong>：<ul><li><strong>Redis</strong>：主要作为缓存服务存储一些生命周期较短的数据，同时对于 JobService 还提供了类似队列的功能。</li><li><strong>PostgreSQL</strong>：存储 Harbor 的应用数据，比如项目信息、用户与项目的关系、管理策略、配置信息、Artifact 的元数据等等。</li><li><strong>Artifact 存储</strong>：存储 Artifact 本身的内容，Artiact就是每次推送镜像、Helm Chart 时，数据最终存储的地方。默认情况下，Harbor 会把 Artifact 写入本地文件系统中。用户也可以修改配置，将 Artifact 存储在外部存储中，例如阿里云的对象存储 OSS 等等。</li></ul></li></ul><h3 id="Harbor的安装">Harbor的安装</h3><p><a href="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CDesktop%5CRedrock%5C%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86%5C%E9%83%A8%E7%BD%B2%E7%A4%BA%E8%8C%83.md">Harbor安装示范</a></p><h3 id="Harbor的使用">Harbor的使用</h3><h4 id="基本推送与拉取">基本推送与拉取</h4><p>先登录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login https://harbor.yiiong.top:8443</span><br></pre></td></tr></table></figure><p>镜像推送（先打标签，再推送）</p><p>harbor地址/项目名/镜像名:版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag mysql harbor.yiiong.top:8443/library/mysql:latest</span><br></pre></td></tr></table></figure><p>镜像拉取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull harbor.yiiong.top:8443/library/mysql:latest</span><br></pre></td></tr></table></figure><h4 id="机器人账户">机器人账户</h4><p>在一些情况下，为了提高 Harbor 仓库的安全性考虑，不建议直接在流水线任务（CI/CD）中直接使用个人账户。因为这种方式会导致权限管理和维护变得复杂，尤其是当项目是公开的时候。</p><p>为解决这个问题，可以考虑使用 Harbor 自带的机器人账户（Robot Account）。机器人账户是一种特殊类型的账户，允许非个人实体访问 Harbor 仓库并执行特定的操作，而无需提供实际的用户名和密码。通过机器人账户，可以实现自动化 CI/CD 流程中的推送和拉取镜像操作，确保安全同时减少人为处理。</p><h2 id="内网穿透工具">内网穿透工具</h2><h3 id="frp">frp</h3><blockquote><p><a href="https://github.com/fatedier/frp">Github</a></p><p><a href="https://gofrp.org/zh-cn/docs/">文档 | frp (gofrp.org)</a></p></blockquote><p>frp 是一款高性能的反向代理应用，专注于内网穿透。它支持多种协议，包括 TCP、UDP、HTTP、HTTPS 等，并且具备 P2P 通信功能。使用 frp，我们可以使用frp安全、便捷地将内网服务暴露到公网，通过拥有公网 IP 的节点进行中转。</p><p>在0.52.0版本开始支持toml格式的配置文件了，并将在后继某个版本开始取消对ini配置格式的支持。</p><h4 id="通过SSH访问内网机器">通过SSH访问内网机器</h4><p><a href="https://blog.csdn.net/qq_74046217/article/details/135798340?spm=1001.2014.3001.5501">利用frp将处于内网香橙派中的服务穿透至公网_proxy.go:204-CSDN博客</a></p><h4 id="通过自定义域名访问内网的-Web-服务">通过自定义域名访问内网的 Web 服务</h4><p><a href="https://blog.csdn.net/qq_74046217/article/details/135798340?spm=1001.2014.3001.5501">利用frp将处于内网香橙派中的服务穿透至公网_proxy.go:204-CSDN博客</a></p><h4 id="后台运行">后台运行</h4><p>一切都没有问题后，我们把它们制作成service，保证它们可以在后台稳定运行</p><p><strong>服务端</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/frps.service</span><br></pre></td></tr></table></figure><p>frps.service配置如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frps Server Service</span><br><span class="line">After=network.target</span><br><span class="line">Wants=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/root/frp-all/frp-os-server/frps -c /root/frp-all/frp-os-server/frps.toml # 你的frps文件的绝对路径</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start frps</span><br></pre></td></tr></table></figure><p>开机自启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable frps</span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status frps</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><p>与服务端同理，frpc.service的配置中ExecStart修改为frpc文件的绝对路径，下面操作相同</p><h4 id="原理">原理</h4><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202403242028736.png" alt="image-20240324202815687"></p><p>frpc并不监听哪个端口，只是它在局域网主机中启动时会通过一个随机端口来与外网服务器的7010端口建立一个隧道连接，隧道建立后7010端口和那个frpc所用过的随机端口并不直接参与数据包的传输。frps会将发往外网服务器6010端口的数据直接插入隧道中传至frpc中，这是隧道技术的一个关键特性，允许数据在网络上高效、安全地传输。</p><h3 id="ngrok">ngrok</h3><blockquote><p><a href="https://ngrok.com/download">Download (ngrok.com)</a></p></blockquote><p>ngrok 通过在公共端点和本地运行的 Web 服务器之间建立一个免费且安全的通道，实现内网主机的服务可以暴露给外网。</p><p>你可以使用ngrok将你处于内网的服务暂时暴露在公网，方便测试服务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先添加Authtoken</span><br><span class="line">ngrok config add-authtoken &lt;token&gt;</span><br><span class="line"></span><br><span class="line">开启隧道</span><br><span class="line">ngrok http &lt;port&gt;</span><br></pre></td></tr></table></figure><h2 id="Nginx">Nginx</h2><h3 id="介绍">介绍</h3><p>Nginx是一款轻量级的Web 服务器/反向代理服务器及 电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><h3 id="正向代理与反向代理">正向代理与反向代理</h3><h4 id="正向代理"><strong>正向代理</strong></h4><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202403270005273.png" alt="在这里插入图片描述"></p><p>正向代理，指的是通过<code>代理服务器</code> 代理<code>浏览器/客户端</code>去重定向请求访问到<code>目标服务器</code> 的一种代理服务。<br>正向代理服务的特点是<code>代理服务器</code> 代理的对象是<code>浏览器/客户端</code>，也就是对于<code>目标服务器</code> 来说<code>浏览器/客户端</code>是隐藏的。</p><p><strong>正向代理有什么用途？</strong></p><p>举个例子：我是一个用户，我访问不了某网站，但是能访问一个代理服务器，这个代理服务器能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去把数据包取回来，然后返回给我。</p><ol><li>访问原来无法访问的资源，如google （通过正向代理实现科学上网）</li><li>可以做缓存，加速访问资源</li><li>对客户端访问授权，上网进行认证</li><li>代理可以记录用户访问记录（上网行为管理）</li><li>对外隐藏用户信息，保护隐私</li></ol><h4 id="反向代理">反向代理</h4><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202403270027495.png" alt="在这里插入图片描述"></p><p>反向代理，指的是<code>浏览器/客户端</code>并不知道自己要访问具体哪台<code>目标服务器</code>，只知道去访问<code>代理服务器</code> ，<code>代理服务器</code>再通过<code>反向代理 +负载均衡</code>实现请求分发到<code>应用服务器</code>的一种代理服务。<br>反向代理服务的特点是<code>代理服务器</code> 代理的对象是<code>应用服务器</code>，也就是对于<code>浏览器/客户端</code> 来说<code>应用服务器</code>是隐藏的。</p><p>大型网站，通常将反向代理作为公网访问地址，而Web应用服务器作为内网。</p><p>有了反向代理，用户永远不会与使用它的Web服务器进行直接通信。可以将它们看作web服务 器或服务器集群的某种包装器。通过负载平衡和缓存，它们可以保护web服务器免遭攻击，并提供更好 的web性能。</p><p><strong>反向代理的用途：</strong></p><ol><li>反向代理服务器像一个大门一样保证内网的安全，我们可以使用反向代理提供WAF（Web Application Firewall）功能，阻止web攻击 。</li><li>负载均衡，通过反向代理服务器来优化网站的负载。</li></ol><h3 id="配置文件介绍">配置文件介绍</h3><p><code>nginx.conf</code>为最主要的配置文件</p><p><strong>nginx 文件结构</strong></p><blockquote><p><a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">Nginx 配置详解 | 菜鸟教程 (runoob.com)</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123; </span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li><strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li><strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，             4定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li><strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li></ul><h3 id="应用">应用</h3><h4 id="反向代理-负载均衡">反向代理+负载均衡</h4><p>实现效果：访问<code>nginx.yiiong.top:8000</code>时，将请求平均分配到8881和8882端口。</p><p><code>nginx.yiiong.top</code>解析到<code>172.20.14.31</code></p><p>docker启动两个nginx容器，分别映射到宿主机8881、8882端口</p><p>为了区分，我修改了主页内容（<code>/usr/share/nginx/html/index.html</code>）</p><p><strong>反向代理</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">server &#123;</span><br><span class="line">                listen 8000;</span><br><span class="line">                server_name 172.20.14.31;</span><br><span class="line">                location / &#123;</span><br><span class="line">                        proxy_pass 172.20.14.31:8881; # 反向代理到8881</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>反向代理+负载均衡</strong></p><p>upstream可以提供负载均衡和高可用性。</p><p>weight：weight代表每个服务器的权重值，默认为1，权重越高，被分配的用户数就越多。这种分配方式主要用于后端服务器性能不均的情况。</p><p>此时，访问8882端口的次数会是8881端口的两倍。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">        upstream web&#123;</span><br><span class="line">                server 172.20.14.31:8881 weight=5;</span><br><span class="line">                server 172.20.14.31:8882 weight=10;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        server &#123;</span><br><span class="line">                listen 8000;</span><br><span class="line">                server_name 172.20.14.31;</span><br><span class="line">                location / &#123;</span><br><span class="line">                        proxy_pass http://web; # 反向代理到8881或8882</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="文件服务器">文件服务器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">                listen 8888;</span><br><span class="line">                server_name localhost;</span><br><span class="line">                charset utf-8;</span><br><span class="line">                root /home; # 显示该目录下的文件</span><br><span class="line"></span><br><span class="line">                location / &#123;</span><br><span class="line">                        autoindex on; # 自动生成目录索引页面</span><br><span class="line">                        autoindex_exact_size on; # 显示文件大小</span><br><span class="line">                        autoindex_localtime on; # 显示文件的最后修改时间</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>有些类型的文件链接在浏览器里点击后并不会直接下载而是只预览，这是我们只需要在<code>mime.types</code>中添加<code>application/octet-stream  &lt;文件类型&gt;</code>即可。</p><p><code>application/octet-stream</code> 是一种 MIME 类型，用于指示未知类型的文件。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202403281642214.png" alt="image-20240328164218152"></p><h2 id="ddns">ddns</h2><p>由于DHCP分配给用户设备的IP地址并不固定，为了将设备当前的IP及时映射到域名上，使用户在任何时候都可以通过固定的地址访问到设备，产生了动态域名解析DDNS技术。</p><p><strong>ddns-go</strong> 是一个轻量级的动态域名解析服务更新器，由Go语言编写，其主要功能是监测你的公共IP地址变化，并自动将新IP同步到支持自定义脚本的DDNS服务商。</p><blockquote><p><a href="https://github.com/jeessy2/ddns-go">jeessy2/ddns-go: Simple and easy to use DDNS. Support Aliyun, Tencent Cloud, Dnspod, Cloudflare, Callback, Huawei Cloud, Baidu Cloud, Porkbun, GoDaddy, Namecheap, NameSilo… (github.com)</a></p></blockquote><blockquote><p><a href="http://www.yiiong.top:88/?p=192">内网穿透方法总结</a></p></blockquote><h2 id="Softether-VPN">Softether VPN</h2><p>VPN（Virtual Private Network，虚拟私人网络）</p><blockquote><p><a href="https://www.softether.org/4-docs/1-manual/7._Installing_SoftEther_VPN_Server/7.3_Install_on_Linux_and_Initial_Configurations">7.3 在 Linux 上安装和初始配置 - SoftEther VPN 项目</a></p><p><a href="https://www.softether-download.com/cn.aspx?product=softether">下载</a></p></blockquote><h3 id="介绍-v2">介绍</h3><p>Softether VPN是一个能够虚拟网卡和集线器（HUB）的工具，只要可以访问互联网，都可以使用它来组建远程局域网。</p><h3 id="VPN用途">VPN用途</h3><ol><li><strong>安全远程访问</strong>：VPN允许远程用户通过公共网络安全地连接到公司内部网络。</li><li><strong>绕过地理限制</strong>：通过连接到位于其他地区的VPN服务器，用户可以访问被地理限制的网站、内容和服务。这是因为连接到VPN后，我们的IP地址会被伪装为VPN服务器所在地的IP地址，使得我们看起来好像是从该地区访问网站。</li></ol><h3 id="前提">前提</h3><p>想要科学上网，我们就得有一台公网海外服务器。</p><p>将 VPN Server 安装到 Linux 操作系统需要以下软件和库。检查系统是否已安装并启用以下软件和库。(make和gcc一定要有)</p><ul><li><strong>make</strong></li><li><strong>GCC软件</strong></li><li><strong>Binutils 软件</strong></li><li><strong>tar、gzip 或其他用于提取软件包文件的软件</strong></li><li><strong>chkconfig 系统实用程序</strong></li><li><strong>cat、cp 或其他基本文件操作实用程序</strong></li><li><strong>EUC-JP、UTF-8 或其他代码页表，用于日语环境</strong></li><li><strong>libc （glibc） 库</strong></li><li><strong>zlib 库</strong></li><li><strong>OpenSSL 库</strong></li><li><strong>Readline 库</strong></li><li><strong>ncurses 库</strong></li><li><strong>pthread 库</strong></li></ul><p>将压缩包解压，并将其移动至<code>/usr/local/vpnserver</code>，然后执行<code>make</code>进行编译，出现如下即成功。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202403251912879.png" alt="image-20240325191200775"></p><p>启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@RainYun-SJkdAk4z:/usr/local/vpnserver# ./vpnserver start</span><br><span class="line">The SoftEther VPN Server service has been started.</span><br><span class="line"></span><br><span class="line">Let&#x27;s get started by accessing to the following URL from your PC:</span><br><span class="line"></span><br><span class="line">https://172.16.120.106:5555/</span><br><span class="line">  or</span><br><span class="line">https://172.16.120.106/</span><br><span class="line"></span><br><span class="line">Note: IP address may vary. Specify your server&#x27;s IP address.</span><br><span class="line">A TLS certificate warning will appear because the server uses self signed certificate by default. That is natural. Continue with ignoring the TLS warning.</span><br></pre></td></tr></table></figure><p>可以访问到我们的后台。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202403251913187.png" alt="image-20240325191354087"></p><h3 id="检查服务运行状态">检查服务运行状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@RainYun-SJkdAk4z:/usr/local/vpnserver# ./vpncmd</span><br><span class="line">vpncmd command - SoftEther VPN Command Line Management Utility</span><br><span class="line">SoftEther VPN Command Line Management Utility (vpncmd command)</span><br><span class="line">Version 4.43 Build 9799   (English)</span><br><span class="line">Compiled 2023/08/31 10:50:49 by buildsan at crosswin with OpenSSL 3.0.9</span><br><span class="line">Copyright (c) 2012-2023 SoftEther VPN Project. All Rights Reserved.</span><br><span class="line"></span><br><span class="line">By using vpncmd program, the following can be achieved. </span><br><span class="line"></span><br><span class="line">1. Management of VPN Server or VPN Bridge </span><br><span class="line">2. Management of VPN Client</span><br><span class="line">3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool)</span><br><span class="line"></span><br><span class="line">Select 1, 2 or 3: 3</span><br><span class="line"></span><br><span class="line">VPN Tools has been launched. By inputting HELP, you can view a list of the commands that can be used.</span><br><span class="line"></span><br><span class="line">VPN Tools&gt;check</span><br><span class="line">Check command - Check whether SoftEther VPN Operation is Possible</span><br><span class="line">---------------------------------------------------</span><br><span class="line">SoftEther VPN Operation Environment Check Tool</span><br><span class="line"></span><br><span class="line">Copyright (c) SoftEther VPN Project.</span><br><span class="line">All Rights Reserved.</span><br><span class="line"></span><br><span class="line">If this operation environment check tool is run on a system and that system passes, it is most likely that SoftEther VPN software can operate on that system. This check may take a while. Please wait...</span><br><span class="line"></span><br><span class="line">Checking &#x27;Kernel System&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;Memory Operation System&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;ANSI / Unicode string processing system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;File system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;Thread processing system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line">Checking &#x27;Network system&#x27;... </span><br><span class="line">              Pass</span><br><span class="line"></span><br><span class="line">All checks passed. It is most likely that SoftEther VPN Server / Bridge can operate normally on this system.</span><br><span class="line"></span><br><span class="line">The command completed successfully.</span><br></pre></td></tr></table></figure><p>出现successfully后就可以开始搭建我们的vpnserver了。</p><h3 id="安装vpnserver">安装vpnserver</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@RainYun-SJkdAk4z:/usr/local/vpnserver# ./vpncmd</span><br><span class="line">vpncmd command - SoftEther VPN Command Line Management Utility</span><br><span class="line">SoftEther VPN Command Line Management Utility (vpncmd command)</span><br><span class="line">Version 4.43 Build 9799   (English)</span><br><span class="line">Compiled 2023/08/31 10:50:49 by buildsan at crosswin with OpenSSL 3.0.9</span><br><span class="line">Copyright (c) 2012-2023 SoftEther VPN Project. All Rights Reserved.</span><br><span class="line"></span><br><span class="line">By using vpncmd program, the following can be achieved. </span><br><span class="line"></span><br><span class="line">1. Management of VPN Server or VPN Bridge </span><br><span class="line">2. Management of VPN Client</span><br><span class="line">3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool)</span><br><span class="line"></span><br><span class="line">Select 1, 2 or 3: 1 // 选1，安装vpnserver</span><br><span class="line"></span><br><span class="line">Specify the host name or IP address of the computer that the destination VPN Server or VPN Bridge is operating on. </span><br><span class="line">By specifying according to the format &#x27;host name:port number&#x27;, you can also specify the port number. </span><br><span class="line">(When the port number is unspecified, 443 is used.)</span><br><span class="line">If nothing is input and the Enter key is pressed, the connection will be made to the port number 8888 of localhost (this computer).</span><br><span class="line">Hostname of IP Address of Destination: 154.3.0.248 // 填写你的公网IP</span><br><span class="line"></span><br><span class="line">If connecting to the server by Virtual Hub Admin Mode, please input the Virtual Hub name. </span><br><span class="line">If connecting by server admin mode, please press Enter without inputting anything.</span><br><span class="line">Specify Virtual Hub Name: // 不填，直接回车</span><br><span class="line">Connection has been established with VPN Server &quot;154.3.0.248&quot; (port 443).</span><br><span class="line"></span><br><span class="line">You have administrator privileges for the entire VPN Server.</span><br></pre></td></tr></table></figure><h3 id="下载Softether-VPN-Server-Manager">下载Softether VPN Server Manager</h3><h3 id="SecureNAT的作用">SecureNAT的作用</h3><p>提供虚拟NAT和虚拟DHCP服务。</p><p>具体流程类似wifi路由器上网过程。</p><p>wifi路由器上网过程：客户端通过路由器DHCP到一个内网IP，然后通过路由器的NAT功能，将内网IP映射到路由器的公网IP，通过路由器的公网IP进行上网。</p><p>VPN：客户端连接到VPN Server，通过虚拟DHCP获得一个虚拟IP，通过SecureNAT，将这个虚拟IP映射到VPN Server的IP，通过VPN Server的IP上网。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202403252239076.png" alt="image-20240325223944006"></p><h3 id="通过Client使用VPN">通过Client使用VPN</h3><p>PC端通过SoftEther VPN Client使用</p><p>移动端(需要支持L2TP-一种VPN协议)使用自带VPN直接连接即可</p><h2 id="Proxmox-VE">Proxmox VE</h2><blockquote><p><a href="https://pve.proxmox.com/wiki/Main_Page">Proxmox VE</a></p></blockquote><p>Proxmox虚拟环境（简称PVE）是用于操作来宾操作系统的基于Debian Linux和KVM的虚拟化平台。</p><p>你可以把它类比为VMware，只不过使用PVE的前提是你得有一个小迷你主机或闲置的电脑，因为PVE安装时是一个系统镜像。</p><p><strong>区别</strong>：</p><ul><li>VMware基于自家开发的 ESXi 虚拟化技术，是一种完全虚拟化，敏感指令在操作系统和硬件之间被捕捉处理，客户操作系统无需修改，且所有软件都能在虚拟机中运行。</li><li>PVE主要基于 KVM，是一种基于内核的虚拟机，可将Linux内核转化成虚拟机监视器。同时它还有裸机安装器、网页版远程管理界面、HA集群堆栈、统一存储、柔性网络及可选的商业支持。</li></ul><p><strong>局限性：</strong></p><p>Proxmox群集的虚拟化和存储主机的最大数量为32台物理服务器。</p><blockquote><p>下载：<a href="https://www.proxmox.com/de/downloads/proxmox-virtual-environment/iso">ISO Installer - Proxmox Virtual Environment</a></p></blockquote><h3 id="安装">安装</h3><p>CPU类别：</p><ul><li>host：性能最佳但兼容性不好，如果想将虚拟机从一台宿主机迁移到另一台 CPU 型号或架构不同的宿主机时，可能会出现兼容性问题。</li><li>kvm64：兼容性好但性能不是最佳，它可以让我们在不同的宿主机之间迁移虚拟机。</li></ul><p>LVM（Logical Volume Manager）是一种在 Linux 操作系统上使用的逻辑卷管理器，它允许用户对存储设备进行灵活的管理。</p><ol><li>动态调整逻辑卷的大小，而无需重新分区磁盘。</li><li>实现数据的快速备份和还原。</li><li>支持数据的快速迁移和快速扩展存储容量。</li><li>提高数据安全性和可靠性，包括数据冗余和快速恢复能力。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器运维 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 第三讲</title>
      <link href="/2024/11/08/Kubernetes%E7%AC%AC%E4%B8%89%E8%AE%B2/"/>
      <url>/2024/11/08/Kubernetes%E7%AC%AC%E4%B8%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h1>Kubernetes 第三讲</h1><h2 id="存储">存储</h2><h3 id="持久化">持久化</h3><p>Pod是由多个容器组成的，在了解Pod的文件系统结构时，我们可以先看看一个Docker容器是如何被制作的。</p><p>容器根据镜像启动。我们在Dockerfile中的每一条RUN命令，会生成一层一层的镜像层，这些镜像层从下向上以栈的形式组成了一个镜像。而容器和镜像都是由多个层组成的，他们之间最大的区别就是容器的最上面的一层是读写层，叫做容器层。但镜像的所有层都是只读层，叫做镜像层。</p><p>容器启动后，Docker会在容器使用的镜像上添加一个容器层。容器运行时，所有和数据变化相关的操作都是在这个读写层中完成的，如新建文件，修改文件等。删除容器时，Docker同时会删除这个容器层。</p><p>每个容器运行时，都有自己的容器层，并在容器层中保存容器运行相关的数据。容器层之下的所有镜像层都是只读的，因此多个容器可以共享同一个镜像。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404232153808.jpeg" alt="img"></p><p>Pod中有若干个容器，每个容器的文件系统都是独立且一次性的。当容器因为某些原因重启时（崩溃、调度等情况），容器层就会被销毁并重新创建。</p><p>假如我们运行了一个MySQL的Pod，如果你没有对它做持久化存储，一旦这个Pod因为某些原因被销毁，那么这个Pod里的数据就会全部丢失，然后工作负载就会另起一个全新的MySQL的Pod，这个Pod是一干二净的，原来Pod的数据不会被保留也不会被恢复，<s>这样你就得跑路了</s>~</p><p>因此，对数据的持久化是非常有必要的！</p><h3 id="存储卷Volume">存储卷Volume</h3><p><a href="https://kubernetes.io/zh-cn/docs/concepts/storage/">存储 | Kubernetes</a></p><p>Volume 的生命周期独立于容器，Pod 中的容器可能被销毁和重建，但 Volume 会被保留。</p><p>在Docker中，我们可以通过<code>-v</code>参数来指定挂载目录。而在K8s中，我们需要通过定义存储卷（Volume）来满足数据持久化的需求。</p><p>Kubernetes支持很多类型的卷。同一个pod也可以挂载多个多种不同类型的卷。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404301751592.png" alt="在这里插入图片描述"></p><p>总体来看可以分为四大类：</p><ol><li>本地卷：hostPath-直接挂载到宿主机文件类型、emptyDir-数据的存储取决于宿主机所使用的介质，比如磁盘或 SSD 或网络存储。（这种卷的数据直接保存在宿主机的本地磁盘上，并且Pod只能在该特定节点上访问这些数据）</li><li>网络数据卷：比如Nfs、ClusterFs、Ceph，这些都是外部的存储都可以挂载到k8s上。</li><li>云盘：云服务商自行提供的存储方案。</li><li>K8s的自身资源：比如Secret、ConfigMap等。</li></ol><h4 id="emptyDir">emptyDir</h4><p><em><strong>用于存储临时数据的简单空目录。</strong></em></p><p><strong>工作流程：</strong></p><p>当 Pod 被分派到某个 Node 上时，emptyDir 卷会被自动创建在该Pod中，并且在 Pod 在该节点上运行期间，卷一直存在。当 Pod 因为某些原因被从节点上删除时，emptyDir 卷中的数据也会被永久删除。但是容器崩溃并不会导致 Pod 被从节点上移除，因此容器崩溃期间 emptyDir 卷中的数据是安全的。</p><p><strong>用途：</strong></p><ul><li>临时空间，例如用于某些应用程序运行时所需要的临时目录，且无需永久保留</li><li>同一个Pod中的 一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</li></ul><p><strong>缺点：</strong></p><p>emptyDir不能提供数据持久化，也无法跨节点同步数据，所以仅在容器临时存放数据时使用它。</p><p><strong>emptyDir存储卷的配置示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: volume1</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line">  - name: volume2</span><br><span class="line">    emptyDir:</span><br><span class="line">      medium: Memory</span><br><span class="line">      sizeLimit: 100Mi</span><br></pre></td></tr></table></figure><ul><li><p>medium</p><p>作为卷来使⽤的emptyDir是在承载Pod的⼯作节点的实际磁盘上创建的， 因此其性能取决于节点的磁盘类型。如果需要高速的读写性能，我们可以通知Kubernetes在tmpfs⽂件系统（储存在内存⽽⾮硬盘）上创建emptyDir。因此，将emptyDir的medium设置为Memory。</p></li><li><p>sizeLimit</p><p>可以限制emptyDir被容器填充的大小，则填写此项。如：100Mi，20Gi。此项在大多数卷中是通用的。</p></li></ul><p>emptyDir卷是最简单的卷类型，其他类型的卷都是在它的基础上构建的，在创建空⽬录后，其他类型的卷会⽤数据填充它。</p><h4 id="hostPath">hostPath</h4><p><em><strong>⽤于将⽬录从⼯作节点的⽂件系统挂载到Pod中。</strong></em></p><p><strong>工作流程：</strong></p><p>就是将工作节点中的一个实际目录挂载进Pod中，以供容器使用，提供对主机上文件的访问。它可以保证数据的持久化，即使Pod被销毁了，数据也仍然在工作节点上。它和我们在<code>docker run</code>时的<code>-v</code>参数很类似。</p><p><strong>用途：</strong></p><ul><li>如果Pod需要使用Node上的某些东西时，比如某容器需要访问Docker,可使用hostPath 挂载宿主机节点的<code>/var/lib/docker</code>(Docker的工作目录)</li><li>某些系统级别的Pod（通常由DaemonSet管理，例如DDNS）确实需要读取节点的⽂件或使⽤节点⽂件系统来访问节点设备</li></ul><blockquote><p>DaemonSet会在每个节点上都运行一个指定的的Pod实例，无论节点是什么时候加入或离开集群。</p></blockquote><p><strong>缺点：</strong></p><ol><li>仅提供了单节点的数据持久化，不提供跨节点的数据同步。一般不建议使用这种存储方式（除非是单节点），因为当Pod被调度到另一个Node上时，它会找不到数据。而且理论上⼤多数Pod应该忽略它们的主机节点，因此它们不应该访问节点⽂件系统上的任何⽂件。</li><li>存在安全风险，可能会暴露特权系统凭据（例如 Kubelet）或特权 API（例如容器运行时套接字），可用于容器逃逸或攻击集群的其他部分。因此应该尽量避免使用hostPath，如确需使用，也应该限制它的范围只到所需的文件或目录，并且以只读的方式(readOnly: true)挂载。</li></ol><p><strong>hostPath存储卷的配置示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: hostpath-volume</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /path/to/node # 指定挂载目录</span><br><span class="line">      type: DirectoryOrCreate</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405051959940.png" alt="在这里插入图片描述"></p><p><strong>实例演示：使用hostPath实现Nginx的日志持久化</strong></p><p>指定两个容器：Nginx和BusyBox。</p><p>Nginx用于生成日志，并且将名为 <code>logs-volume</code> 的卷挂载到容器的 <code>/var/log/nginx</code> 目录。</p><p>BusyBox用来证明容器之间的数据可以实现共享，它将名为 <code>logs-volume</code> 的卷挂载到容器的 <code>/logs</code> 目录。</p><p>最后定义了名为 <code>logs-volume</code> 的卷，通过 <code>hostPath</code> 指定了它在宿主机上的路径为 <code>/home/logs</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: volume-hostpath</span><br><span class="line">  namespace: lesson-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: reg.redrock.team/library/nginx:latest</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: logs-volume</span><br><span class="line">      mountPath: /var/log/nginx</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox:1.30</span><br><span class="line">    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;tail -f /logs/access.log&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: logs-volume</span><br><span class="line">      mountPath: /logs</span><br><span class="line">  volumes:</span><br><span class="line">  - name: logs-volume</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /home/logs</span><br><span class="line">      type: DirectoryOrCreate</span><br></pre></td></tr></table></figure><p>查看资源，Pod被调度在master3上。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405052121706.png" alt="image-20240505212147670"></p><p>可以看到master3上已经自动生成了<code>/home/logs</code>目录，并且挂载了<code>/var/log/nginx</code>里的内容。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405052148183.png" alt="image-20240505214844144"></p><p>连续访问三次Pod，访问被成功记录到了<code>/home/logs/access.log</code>中。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405052151466.png" alt="image-20240505215147402"></p><p>进入busybox的容器中，查看busybox<code>/logs/access.log</code>中的内容，发现已经记录了三条访问记录。说明不同容器之间可以共享数据并进行相互交互。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405052151069.png" alt="image-20240505215123023"></p><p>此时删除Pod后，发现数据仍然存在。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405052052594.png" alt="image-20240505205251540"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405052152552.png" alt="image-20240505215200500"></p><h4 id="NFS">NFS</h4><p><strong>可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。</strong></p><p>当运⾏在⼀个Pod中的应⽤程序需要将数据保存到磁盘上，并且即使该Pod重新调度到另⼀个节点时也要求具有相同的数据可⽤。这就不能使⽤到⽬前为⽌我们提到的任何一种卷类型，由于这些数据需要可以从任何集群节点访问， 因此必须将其存储在某种类型的⽹络存储NAS（Network Attached Storage）中。</p><p><strong>工作流程：</strong></p><p>NFS服务器可以让计算机将网络中的NFS服务器共享的目录挂载到本地端的文件系统中，而在本地端的系统中来看，那个远程主机的目录就好像是自己的一个磁盘分区一样，在使用上相当便利。</p><p><strong>用途：</strong></p><p>一般做数据的共享存储，保证多个节点提供一致性的程序。</p><p><strong>缺点：</strong></p><ol><li>容易发生单点故障，Server机宕机了后所有客户端都不能访问</li><li>在高并发下NFS性能有限</li><li>客户端无用户认证机制，且数据是通过明文传送，安全性一般（一般建议在局域网内使用）</li><li>NFS的数据是明文的，对数据完整性不做验证</li></ol><p>为了多节点数据同步及持久化，目前已有更优的cephfs方案，它也是一种网络文件系统。如果你在各大云平台购买Kubernetes容器服务，他们也会提供更底层的数据同步卷及插件，这些卷可挂载到容器中，也可卸载下来复用。但是由于NFS是最简单的多节点数据同步及持久化方案，我们使用它来演示。</p><p><strong>NFS服务端的安装与配置（Debian系）</strong></p><p>安装NFS服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install nfs-kernel-server</span><br></pre></td></tr></table></figure><p>创建一个NFS共享目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/nfs</span><br></pre></td></tr></table></figure><p>修改<code>/etc/exports</code>文件（这个文件包含了NFS 服务器共享的目录），编辑内容为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/nfs/ *(insecure,rw,sync,no_subtree_check,no_root_squash)</span><br><span class="line"># rw代表读写访问，sync代表所有数据在请求时写入共享，no_subtree_check代表不检查父目录权限，no_root_squash代表root用户具有根目录的完全管理访问权限</span><br></pre></td></tr></table></figure><p>使用以下命令启动NFS服务器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable rpcbind</span><br><span class="line">systemctl enable nfs-server</span><br><span class="line"></span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl start nfs-server</span><br><span class="line">exportfs -r # 重新导入配置文件</span><br><span class="line"></span><br><span class="line">exportfs</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405052224976.png" alt="image-20240505222446947"></p><p>配置完NFS后我们就可以在Kubernetes中使用它了。</p><p><strong>NFS存储卷的配置示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: nfs-volume</span><br><span class="line">    nfs:</span><br><span class="line">      server: 172.20.14.180</span><br><span class="line">      path: /root/nfs</span><br></pre></td></tr></table></figure><h3 id="持久卷和持久卷声明">持久卷和持久卷声明</h3><p>以上的存储方案看起来十分不错，但到⽬前为⽌，我们探索过的所有持久卷类型都要求Pod的开发⼈员了解集群中可⽤的真实⽹络存储的基础结构。例如，要创建⽀持NFS协议的卷，开发⼈员必须知道NFS节点所在的实际服务器。这对开发人员很不友好，因为他们应该专注于开发而不是部署。而且将这种涉及基础设施类型的信息塞到⼀个Pod设置中，意味着Pod设置与特定的Kubernetes集群有很⼤耦合度。这就不能在另⼀个Pod中使⽤相同的设置了。所以使⽤这样的卷并不是在Pod中附加持久化存储的最佳实践。</p><p>在理想情况下，在Kubernetes上部署应用程序的开发人员是应该不需要知道集群提供了什么存储技术，与基础设施相关的交互才是集群管理员该做的事情。当开发⼈员需要⼀定数量的持久化存储来进⾏应⽤时，可以向Kubernetes请求，就像在创建Pod时可以请求CPU、内存和其他资源⼀样。集群管理员可以对集群进⾏配置让其可以为应⽤程序提供所需的服务。</p><h4 id="什么是持久卷和持久卷声明？">什么是持久卷和持久卷声明？</h4><p>为了解决上面出现的问题，K8s给出了一种解决方案：<strong>持久卷PersistentVolume</strong> （PV）和 <strong>持久卷声明PersistentVolumeClaim</strong>（PVC）</p><p>PersistentVolume (PV) 是外部存储系统中的一块存储空间，由管理员创建和维护。与 Volume 一样，PV 具有持久性，生命周期独立于 Pod。</p><p>PersistentVolumeClaim (PVC) 是对 PV 的申请 (Claim)。PVC 通常由普通用户创建和维护。需要为 Pod 分配存储资源时，用户可以创建一个 PVC，指明存储资源的容量大小和访问模式（比如只读）等信息，Kubernetes 会查找并提供满足条件的 PV。</p><p>有了 PersistentVolumeClaim，用户只需要告诉 Kubernetes 需要什么样的存储资源，而不必关心真正的空间从哪里分配，如何访问等底层细节信息。这些需要提供存储的底层信息交给管理员来处理，只有管理员才应该关心创建 PersistentVolume 的细节信息。</p><h4 id="持久卷（PV）">持久卷（PV）</h4><p>现在，为了使开发人员不用关心集群上的存储资源的具体细节，我们首先充当集群管理员来配置持久卷。之后，我们再充当开发人员，来使用持久卷完成开发。</p><p><em><strong>如何申请一个PV呢？</strong></em></p><p>在创建持久卷时，管理员需要告诉Kubernetes其对应的容量需求，以及它是否可以由单个节点或多个节点同时读取或写⼊。管理员还需要告诉Kubernetes当持久卷声明的绑定被删除时如何处理PersistentVolume。最后，管理员需要指定持久卷⽀持的实际存储类型、位置和其他属性。</p><p>持久卷的配置示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pv</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  persistentVolumeReclaimPolicy: Retain</span><br><span class="line">  nfs:</span><br><span class="line">    server: 172.20.14.180</span><br><span class="line">    path: /root/nfs</span><br></pre></td></tr></table></figure><p>配置项：</p><ul><li>Capacity：指定 PV 的容量</li><li>accessModes：指定访问模式为 ReadWriteOnce，支持的访问模式有：<ul><li>ReadWriteOnce：读写权限，并且只能被单个Node挂载。</li><li>ReadOnlyMany ：只读权限，允许被多个Node挂载。</li><li>ReadWriteMany：读写权限，允许被多个Node挂载。</li></ul></li><li>persistentVolumeReclaimPolicy：指定当 PV 的回收策略为 Recycle，支持的策略有：<ul><li>Retain：需要管理员手工回收</li><li>Recycle：清除 PV 中的数据并使PV重新可用，效果相当于执行 rm -rf /path/*（将被弃用）</li><li>Delete：删除存储资源并删除PV</li></ul></li></ul><p>使用该命令查看PV。注意PV不属于任何一个命名空间，它跟节点⼀样是集群层⾯的资源。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pv</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405062108901.png" alt="image-20240506210842821"></p><p>此时的PV没有被任何PVC绑定，因此它的状态是Available可用状态。</p><h4 id="持久卷声明（PVC）">持久卷声明（PVC）</h4><p>现在我们扮演开发人员来使用之前创建的持久卷来开发应用。</p><p>我们现在需要使用刚才创建的PV，这个PV是不能像存储卷那样直接在Pod使用的，我们得先创建一个持久卷声明，告诉Kubernetes我们现在需要一个PV，Kubernetes会根据这个清单（PVC）来寻找一个合适的PV。</p><p>持久卷声明的配置实例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pvc</span><br><span class="line">  namespace：</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br><span class="line">  storageClassName: &quot;&quot; # 下一部分将详述</span><br></pre></td></tr></table></figure><p>当创建好声明，Kubernetes就会自动找到适当的持久卷并将其绑定到声明，持久卷的容量必须⾜够⼤以满⾜声明的需求，并且卷的访问模式必须包含声明中指定的访问模式。在该⽰例中，声明请求5G的存储空间和ReadWriteOnce访问模式。之前创建的持久卷符合刚刚声明中的这两个条件，所以它被绑定到对应的声明中。我们可以通过检查声明来查看。</p><p>创好持久卷声明之后，使用以下命令查看所有持久卷声明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pvc</span><br></pre></td></tr></table></figure><p>访问模式的简写含义：</p><ul><li>RWO（ReadWriteOnce）：仅允许单个节点挂载读写。</li><li>ROX（ReadOnlyMany）：允许多个节点挂载只读。</li><li>RWX（ReadWriteMany）：允许多个节点挂载读写这个卷。</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405062111349.png" alt="image-20240506211151286"></p><p>PV与PVC已经成功绑定（Bound）</p><p>PV显⽰被绑定在default/nfs-pvc的PVC上，这个default部分是PVC所在的命名空间（在默认命名空间中创建的声明），我们之前有提到过PV是集群范围的，因此不能在特定的命名空间中创建，但是PVC又只能在特定的命名空间创建，所以PV和PVC只能被同⼀命名空间内的Pod创建使⽤。</p><h4 id="在Pod中使用持久卷声明">在Pod中使用持久卷声明</h4><p>要在Pod中使⽤持久卷，需要在Pod的卷中引⽤持久卷声明名称。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: database</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: data</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: nfs-pvc</span><br><span class="line">  containers:</span><br><span class="line">  - image: busybox:latest</span><br><span class="line">    name: database</span><br><span class="line">    command: [&quot;sleep&quot;]</span><br><span class="line">    args: [&quot;999999&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /var/db</span><br></pre></td></tr></table></figure><p>我们进入容器，在<code>/var/db</code>下新增一个文件，然后退出容器，发现nfs共享目录<code>/root/nfs</code>也新增了同样的文件。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405062156845.png" alt="image-20240506215618770"></p><p>说明Pod已经成功使用了这个持久卷。</p><h4 id="回收持久卷">回收持久卷</h4><p>删除Pod和PVC后，PV的状态为Released，不像之前的Available</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405062210580.png" alt="image-20240506221056517"></p><p>此时我们再次apply刚才删除的PVC，此时的PVC的状态为Pending，PV并没有和PVC成功绑定。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405062212128.png" alt=""></p><p>这是因为之前已经使⽤过这个卷，所以它可能包含前⼀个声明⼈的数据，如果集群管理员还没来得及清理，那么就不应该将这个卷绑定到全新的声明中。</p><p>根据回收策略进行回收</p><ul><li><p>手动回收持久卷</p><p>通过将<code>persistentVolumeReclaimPolicy</code>设置为<code>Retain</code>从⽽通知到Kubernetes，我们希望在创建持久卷后将其持久化，让Kubernetes可以在持久卷从持久卷声明中释放后仍然能保留它的卷和数据内容。⼿动回收持久卷并使其恢复可⽤的⽅法是删除和重新创建持久卷资源。当这样操作时，你将决定如何处理底层存储中的⽂件：可以删除这些⽂件，也可以妥善保存或者复⽤它们。</p></li><li><p>自动回收持久卷</p><p>存在两种其他可⾏的回收策略：<code>Recycle</code>和<code>Delete</code>。</p><p>第⼀种<code>Recycle</code>删除卷的内容并使卷可⽤于再次声明，通过这种⽅式，持久卷可以被不同的持久卷声明和Pod反复使⽤。此回收策略即将被弃用，不建议使用。</p><p>⽽另⼀种<code>Delete</code>策略删除底层存储及PV。</p></li></ul><p>并不是所有类型的持久卷都支持这三种回收策略，在创建持久卷之前，⼀定要检查卷中所⽤到的特定底层存储⽀持什么回收策略。</p><h3 id="持久卷的动态配置——存储类（StorageClass）">持久卷的动态配置——存储类（StorageClass）</h3><p>到目前为止，集群管理员仍然需要按照开发人员的需求来手动配置持久卷。即每出现一个持久卷声明，就需要一个对应的持久卷。这样做还是有些麻烦，还好Kubernetes可以通过动态配置持久卷来自动执行任务。</p><p>集群管理员可以创建一个持久卷配置，并且定义一个或多个存储类对象（StorageClass），这样开发人员就可以在其持久卷声明中引用存储类，K8s将根据持久卷声明动态分配一个符合要求的持久卷。</p><p>与管理员预先提供⼀组持久卷不同的是，动态配置持久卷需要定义若干个StorageClass，并允许系统在每次通过持久卷声明请求时创建⼀个新的持久卷。</p><p>存储类与持久卷类似，它也是一种集群资源。</p><h4 id="创建一个存储类">创建一个存储类</h4><p>如果你的集群部署在云服务提供商上，一般云服务提供商会提供好StorageClass资源，在使用时只需要指定SC的名称（storageClassName）即可。但我们的集群部署在本地，所以我们需要手动创建一个或多个StorageClass资源，然后才能创建新的持久卷。</p><p>helm创建storageClass资源</p><p>我们在这里安装<code>longhorn</code></p><p><a href="https://longhorn.io/docs/">Longhorn | Documentation</a><a href="https://longhorn.io/docs/">Longhorn | Documentation</a></p><p>longhorn是一个轻量级且功能强大的云原生 Kubernetes 分布式存储平台，可以在任意基础设施上运行。</p><p>它有以下的优点：</p><ol><li>可以创建跨集群灾难恢复卷，以便可以从第二个 Kubernetes 集群中的备份中快速恢复主 Kubernetes 集群中的数据</li><li>跨多个节点和数据中心复制块存储以提高可用性</li><li>将备份数据存储在 NFS 或 AWS S3 等外部存储中，然后从备份中还原卷等等</li></ol><p>首先安装open-iscsi。longhorn依赖此协议。iSCSI 是一种远程存储协议，允许在 IP 网络上通过标准以太网连接访问存储资源。和NFS很类似，都是一种远程访问存储数据的网络协议。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install open-iscsi</span><br></pre></td></tr></table></figure><p>然后使用helm安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add longhorn https://charts.longhorn.io</span><br><span class="line">helm repo update</span><br><span class="line"></span><br><span class="line">kubectl create ns longhorn</span><br><span class="line">helm install longhorn longhorn/longhorn -n longhorn</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405080014656.png" alt="image-20240508001449518"></p><p>删除时参照如下方法，不要直接<code>helm uninstall</code></p><blockquote><p><a href="https://www.bookstack.cn/read/longhorn-1.4.1-en/ff5b9c8ef42952e8.md">Uninstall Longhorn - 《Longhorn v1.4.1 Documentation》 - 书栈网 · BookStack</a></p></blockquote><h4 id="使用存储类">使用存储类</h4><p>创建好StorageClass资源后，我们在PVC中直接指定storageClass资源名称即可，K8s就会自动为我们分配一个符合要求的PV。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-test</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: longhorn # 指定storageClass的名称</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br></pre></td></tr></table></figure><p><code>apply</code>后storageClass为我们自动分配了一个PV</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405072354008.png" alt="image-20240507235405935"></p><p>动态配置的持久卷其容量和访问模式是在PVC中所要求的。它的回收策略是Delete，这意味着当PVC被删除时，PV也将被删除。</p><p>集群管理员可以创建具有不同性能或其他特性的多个存储类，然后研发⼈员再决定对应每⼀个声明最适合的存储类。</p><p>存储类的好处在于，声明是通过名称引⽤它们的。因此，只要StorageClass名称在所有这些名称中相同，PVC定义便可跨不同集群移植。</p><h4 id="不指定存储类的动态配置">不指定存储类的动态配置</h4><p>我们在用NFS创建storageClass资源时指定了它为默认的存储类，当我们创建PVC时，如果不指定storageClassName，它就会默认使用你设置为默认的（default）作为存储类。</p><p>如果我们需要手动创建PV，不使用存储类，我们只需要把<code>storageClassName: &quot;&quot;</code>设置为空字符即可。</p><h2 id="配置">配置</h2><h3 id="向容器内传递命令行与参数">向容器内传递命令行与参数</h3><p>每个应用程序都是可执行程序文件，例如Nginx、Tomcat、MySQL等，但我们使用中，通常不会通过默认的配置参数来运行应用，一般都需要自定义符合我们场景的配置，那么就需要定义配置文件来完成。那我们的应用运行在容器中，应该如何定义配置信息呢？</p><h4 id="Docker容器中的命令行与参数的传递">Docker容器中的命令行与参数的传递</h4><p><strong>向容器命令传递参数</strong></p><p>比如Dockerfile中的<code>CMD</code>与<code>ENTRYPOINT</code>指令。</p><p><code>ENTRYPOINT</code> 指令用于设置容器启动时要执行的默认命令或程序，而 <code>CMD</code> 指令用于为 <code>ENTRYPOINT</code> 提供默认参数。当同时存在 <code>ENTRYPOINT</code> 和 <code>CMD</code> 指令时，<code>CMD</code> 中的内容会被解释为覆盖 <code>ENTRYPOINT</code> 指定程序的默认参数。</p><p>比如这个Dockerfile。<code>ENTRYPOINT</code> 指定了在容器启动时要运行的命令，即 <code>echo &quot;Hello,&quot;</code>，而 <code>CMD</code> 指定了作为参数传递给 <code>ENTRYPOINT</code> 指定的程序的默认参数，即 <code>&quot;world&quot;</code>。因此，当你启动这个容器时，它会打印出<code> &quot;Hello, world&quot;</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT [&quot;echo&quot;, &quot;Hello,&quot;]</span><br><span class="line">CMD [&quot;world&quot;]</span><br></pre></td></tr></table></figure><p>但如果你在运行容器时覆盖了<code>CMD</code>时，那么<code>CMD [&quot;world&quot;]</code>中的world会被换位good morning，容器最后会打印出<code>&quot;Hello, good morning&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加参数docker run &lt;image&gt; &lt;arguments&gt;</span><br><span class="line">docker run my-image good morning</span><br></pre></td></tr></table></figure><p>这样可以方便用户灵活地更改参数，从而无需更改Dockerfile。</p><p><strong>将定义好的配置文件嵌入镜像文件中</strong></p><p>你可以提前把配置文件写好，然后COPY或ADD在容器的指定位置。或者你也可以通过RUN指令搭配echo、sed之类的命令同样向配置文件中写入指定参数以达到更改配置文件的效果。</p><p><strong>通过环境变量(Environment Variables)传递配置数据</strong></p><p>通过环境变量为容器提供配置信息是最常见的使用方式，例如，使用MySQL官方提供的镜像文件启动MySQL容器时使用的<code>MYSQL_ROOT_PASSWORD</code>环境变量，它用于为MYSQL服务器的root用户设置登陆密码。</p><p>你可以在<code>docker run</code>时通过<code>-e</code>参数向环境变量传值即能实现应用配置。</p><p><strong>基于Docker卷传送配置文件</strong></p><p>你也可以事先将配置文件放置于宿主机之上的某个路径中，而后在启动容器时将其挂载进容器里。但这也依赖于用户需要事先将配置数据提供在宿主机上的特定路径下，而且在多主机模型中，若容器存在被调度至任一主机运行的可能性时，用户还需要将配置共享到任一宿主机来确保容器能够正常地获取到它们。</p><h4 id="在Kubernetes中覆写命令行与参数">在Kubernetes中覆写命令行与参数</h4><p>在Kubernetes中定义容器时，镜像的ENTRYPOINT和CMD均可以被覆盖，仅需在容器定义中分别设置属性command和args的值。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: alpine:latest</span><br><span class="line">    name: test</span><br><span class="line">    command: [&quot;sleep&quot;]</span><br><span class="line">    args: [&quot;999999&quot;]</span><br></pre></td></tr></table></figure><p>绝⼤多数情况下，只需要设置⾃定义参数。命令⼀般很少被覆盖，除⾮针对⼀些未定义ENTRYPOINT的通⽤镜像，例如busybox。</p><p>注意 command和args字段在pod创建后⽆法被修改。</p><p>如果你想传递多个参数，args是一个列表，在这个列表中指定多个字符串即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">args: [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405091713285.png" alt="image-20240509171351227"></p><p>可以看到其父进程（PID为1）为我们指定的命令与参数</p><h3 id="为容器设置环境变量">为容器设置环境变量</h3><p>在Kubernetes中使用镜像启动容器时，可以在Pod资源或Pod模版资源为容器配置使用env参数来定义所使用的环境变量列表。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: mysql</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    env:</span><br><span class="line">      - name: MYSQL_ROOT_PASSWORD # 通过env指定了root用户的密码</span><br><span class="line">        value: &quot;redrock&quot; </span><br></pre></td></tr></table></figure><h3 id="ConfigMap">ConfigMap</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/185988609">Kubernetes之ConfigMap详解及实践 - 知乎 (zhihu.com)</a></p><p><a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/">ConfigMaps | Kubernetes</a></p></blockquote><p><em><strong>为什么要引入ConfigMap？</strong></em></p><p>如果一台服务器上部署多个服务：nginx、tomcat、apache等，那么这些配置都存在这个节点上。如果有一个服务出现问题，需要修改配置文件，每台物理节点上的配置都需要修改，这种方式肯定满足不了线上大批量的配置变更要求。所以，K8s 中引入了 ConfigMap资源对象，可以当成 Volume 挂载到 Pod 中，实现统一的配置管理。简单来说，一个ConfigMap对象就是一系列配置数据的集合，这些数据可“注入”到Pod对象中，并为容器应用所使用，注入方式有挂载为<strong>存储卷</strong>和<strong>传递为环境变量</strong>两种。</p><p>优点：将配置存放在独⽴的资源对象中有助于在不同环境（开发、测试、质量保障和⽣产等）下拥有多份同名配置清单。Pod是通过名称引⽤ConfigMap的，因此可以在多环境下使⽤相同的Pod定义描述，同时保持不同的配置值以适应不同环境。</p><p>ConfigMap是名称空间级的资源，因此引用它的Pod必须处于同一名称空间中。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405091835579.png" alt="image-20230424205526940"></p><h4 id="创建ConfigMap">创建ConfigMap</h4><p>命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create configmap &lt;map-name&gt; &lt;data-source&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;map-name&gt;</code>为ConfigMap对象的名称，<code>&lt;data-source&gt;</code>是数据源。数据源可以是键值对类型的数据，也可以指定文件或目录来获取。</p><h5 id="通过键值创建"><strong>通过键值创建</strong></h5><p>创建一个名为<code>mysql-config</code>的ConfigMap，键值对第一个key为<code>mysql_ip</code>值为<code>1.2.3.4</code> 键值对第二个key为<code>mysql_port</code>值为<code>3306</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create configmap mysql-config \</span><br><span class="line">--from-literal=mysql_ip=1.2.3.4 --from-literal=mysql_port=3306</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405091847055.png" alt="image-20240509184756957"></p><h5 id="通过文件创建"><strong>通过文件创建</strong></h5><p>命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create configmap &lt;configmap_name&gt; --from-file=&lt;[key=]source&gt;</span><br></pre></td></tr></table></figure><p>配置文件以键值对形式写入</p><p><code>mysql-config.yaml</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql_ip: 1.2.3.4</span><br><span class="line">mysql_port: 3306</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create configmap mysql-config --from-file=./mysql-config.yaml</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405091852932.png" alt="image-20240509185235800"></p><h5 id="通过目录创建"><strong>通过目录创建</strong></h5><p>当配置文件数量较多时，我们可以在<code>--from-file</code>选项后所跟的路径指向一个目录路径就能把目录下的所有文件一同创建同一个 ConfigMap 资源中。</p><p>命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create configmap &lt;configmap_name&gt; --from-file=&lt;path-to-directory&gt;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /data/configs/nginx/conf.d/</span><br><span class="line">myserver.conf  myserver-gzip.cfg  myserver-status.cfg</span><br><span class="line"></span><br><span class="line">kubectl create configmap nginx-config-files --from-file=/data/configs/nginx/conf.d/</span><br></pre></td></tr></table></figure><p>这种情况下，kubectl会为⽂件夹中的每个⽂件单独创建条⽬。<img src="https://gitee.com/beatrueman/images/raw/master/img/202405091858687.png" alt="image-20230424211107489"></p><p>当从文件创建ConfigMap时，所有条⽬第⼀⾏最后的管道符号表⽰后续的条⽬值是多⾏字⾯量。（字面量是一种在 ConfigMap 中直接指定键和值的方式）</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405091858368.png" alt="image-20240509185807309"></p><h5 id="直接通过资源配置清单创建"><strong>直接通过资源配置清单创建</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql-config</span><br><span class="line">data:</span><br><span class="line">  mysql_ip: 1.2.3.4</span><br><span class="line">  mysql_port: 3306</span><br></pre></td></tr></table></figure><h4 id="向Pod中传递ConfigMap作为环境变量">向Pod中传递ConfigMap作为环境变量</h4><p>格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">valueFrom:</span><br><span class="line">  configMapKeyRef: </span><br><span class="line">    key: # 要引用ConfigMap对象中某键的键名</span><br><span class="line">    name: # 要引用的ConfigMap对象的名称</span><br><span class="line">    optional: # 用于为当前Pod资源指明此引用是否为可选</span><br></pre></td></tr></table></figure><p>创建一个ConfigMap</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create configmap mysql-config --from-literal=mysql_password=redrock</span><br></pre></td></tr></table></figure><h5 id="valueFrom单一映射">valueFrom单一映射</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: mysql</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    env:</span><br><span class="line">      - name: MYSQL_ROOT_PASSWORD # 通过env指定了root用户的密码</span><br><span class="line">        valueFrom:</span><br><span class="line">    configMapKeyRef: </span><br><span class="line">    name: mysql-config# 要引用的ConfigMap对象的名称</span><br><span class="line">    key: mysql_password# 要引用ConfigMap对象中某键的键名</span><br><span class="line">       #optional: # 用于为当前Pod资源指明此引用是否为可选。当值为true时，即使ConfigMap不存在，容器也可以正常启动</span><br></pre></td></tr></table></figure><h5 id="envFrom全部映射">envFrom全部映射</h5><p>如果ConfigMap包含不少条⽬，Kubernetes提供了暴露ConfigMap的所有条⽬作为环境变量的⼿段。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: mysql</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    envFrom:</span><br><span class="line">    - prefix: HTCPG_ # 给键加前缀可以避免从多个ConfigMap引入键值数据时产生键key重名(名称冲突)的问题</span><br><span class="line">      configMapKeyRef: </span><br><span class="line">        name: mysql-config  # CM资源名称</span><br></pre></td></tr></table></figure><p>你也可以向command和args字段中引用环境变量，使用<code>$(VAR_NAME)</code>的格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">command: [&quot;mysql&quot;]</span><br><span class="line">args: [&quot;-u&quot;,&quot;root&quot;,&quot;-p&quot;,&quot;$(MYSQL_ROOT_PASSWORD)&quot;]</span><br></pre></td></tr></table></figure><h5 id="以ConfigMap存储卷形式挂载Pod读取配置文件">以ConfigMap存储卷形式挂载Pod读取配置文件</h5><p>环境变量或者命令⾏参数值作为配置值通常适⽤于变量值较短的场景。由于ConfigMap中可以包含完整的配置⽂件内容，当你想要将其暴露给容器时，可以借助前⾯章节提到过的⼀种称为configMap卷的特殊卷格式。</p><p>ConfigMap卷会将ConfigMap中的每个条⽬均暴露成⼀个⽂件。运⾏在容器中的进程可通过读取⽂件内容获得对应的条⽬值。这种⽅法主要适⽤于传递较⼤的配置⽂件给容器。</p><p>先创建一个cm</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create cm stu-config --from-file=/root/class3/cm-volume --from-literal=country=China</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405092021234.png" alt="image-20240509202150107"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: stu-mount</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">    - name: config-volume</span><br><span class="line">      configMap: # configMap形式存储卷</span><br><span class="line">        name: stu-config</span><br><span class="line">  containers:</span><br><span class="line">    - name: test-container</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;sleep 1000000&quot; ]</span><br><span class="line">      volumeMounts:</span><br><span class="line">        - name: config-volume</span><br><span class="line">          mountPath: /data/config</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405092023304.png" alt="image-20240509202304229"></p><p>ConfigMap的所有条目都以文件的形式挂载进了Pod中</p><p>如果只想要ConfigMap的部分内容，并自定义文件名，可通过items来配置，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: stu-mount</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">    - name: config-volume</span><br><span class="line">      configMap:</span><br><span class="line">        name: stu-config</span><br><span class="line">        items: # 引用部分内容</span><br><span class="line">          - key: Tom.yaml </span><br><span class="line">            path: tom.yaml # 自定义文件名</span><br><span class="line">          - key: Mary.yaml</span><br><span class="line">            path: mary.yaml</span><br><span class="line">  containers:</span><br><span class="line">    - name: test-container</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;sleep 1000000&quot; ]</span><br><span class="line">      volumeMounts:</span><br><span class="line">        - name: config-volume</span><br><span class="line">          mountPath: /data/config</span><br></pre></td></tr></table></figure><p>要注意挂载某⼀⽂件夹会隐藏该⽂件夹中已存在的⽂件。如果挂载⽂件夹是/etc，该⽂件夹通常包含不少重要⽂件。由于/etc下的所有⽂件不存在，容器极⼤可能会损坏。如果你希望添加⽂件⾄某个⽂件夹如/etc，绝不能采⽤这种⽅法。</p><p>如何能挂载ConfigMap对应⽂件⾄现有⽂件夹的同时不会隐藏现有⽂件？volumeMount额外的subPath字段可以被⽤作挂载卷中的某个独⽴⽂件或者是⽂件夹，⽆须挂载完整卷。挂载任意⼀种卷时均可以使⽤<code>subPath</code>属性。可以选择挂载部分卷⽽不是挂载完整的卷。</p><p>在/etc下增加一个Tom.yaml，而不是把全部覆盖掉/etc</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: stu-mount-1</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">    - name: config-volume</span><br><span class="line">      configMap:</span><br><span class="line">        name: stu-config</span><br><span class="line">  containers:</span><br><span class="line">    - name: test-container</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;sleep 1000000&quot; ]</span><br><span class="line">      volumeMounts:</span><br><span class="line">        - name: config-volume</span><br><span class="line">          mountPath: /etc/Tom.yaml</span><br><span class="line">          subPath: Tom.yaml</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405092038190.png" alt="image-20240509203852081"></p><h4 id="ConfigMap的更新">ConfigMap的更新</h4><p>更新ConfigMap之后ConfigMap卷中对应⽂件的更新可能耗费数分钟。如果使用环境变量的方法，这些值将不会更新；如果在ConfigMap卷中使用了subPath属性，则这些文件也不会更新。在使用时需要注意这一点，必要时手动重启Pod。</p><h3 id="Secret">Secret</h3><p>到⽬前为⽌传递给容器的所有信息都是⽐较常规的⾮敏感数据。然⽽配置通常会包含⼀些敏感数据，如证书和私钥，需要确保其安全性。为了存储与分发此类信息，Kubernetes提供了⼀种称为Secret的单独资源对象用来传递敏感配置。</p><p>Secret结构与ConfigMap类似，均是键/值对的映射，但Secret专门用于保存机密数据。Secret的使⽤⽅法也与ConfigMap相同，可以将Secret条⽬作为环境变量传递给容器，或将Secret条⽬暴露为卷中的⽂件。</p><p>Kubernetes通过仅仅将Secret分发到需要访问Secret的pod所在的机器节点来保障其安全性。另外，Secret只会存储在节点的内存中，永不写⼊物理存储，这样从节点上删除Secret时就不需要擦除磁盘了。另外Secret通过base64编码存储于其中的敏感数据，这样做有两点好处：</p><ol><li>base64可以将一些非文本对象编码为文本值，如图片等。注意其大小不能超过1MB。</li><li>base64编码后的数据人类不可读，这避免了一些时候操作人员无意中看到并记住密码的情况。</li></ol><p>因此应采⽤ConfigMap存储⾮敏感的⽂本配置数据，采⽤Secret存储天⽣敏感的数据，通过键来引⽤。如果⼀个配置⽂件同时包含敏感与⾮敏感数据，该⽂件应该被存储在Secret中。</p><p>Secret有三种类型：</p><ul><li><p>Opaque：base64编码格式的 Secret，用来存储密码、密钥等。</p></li><li><p>Service Account：用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的 <code>/run/secrets/kubernetes.io/serviceaccount</code>目录中。</p></li><li><p>DockerConfig：用来存储私有docker registry的认证信息。</p></li></ul><h4 id="默认令牌（Service-Account）">默认令牌（Service Account）</h4><p>默认被挂载⾄所有容器的Secret，用于容器访问Kubernetes API的身份认证。</p><h4 id="创建并使用Opaque类型Secret">创建并使用Opaque类型Secret</h4><p>创建一个Secret用来存储mysql的root密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic mysql-passwd --from-literal=passwd=redrock</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405092152525.png" alt="image-20240509215248413"></p><p>passwd被自动base64编码</p><p>在Pod中使用Secret</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql-secret</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: mysql</span><br><span class="line">      image: mysql:5.7</span><br><span class="line">      env:</span><br><span class="line">        - name: MYSQL_ROOT_PASSWORD </span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: mysql-passwd</span><br><span class="line">              key: passwd</span><br></pre></td></tr></table></figure><p>通过Volume挂载到容器内部时，当该Secret的值发生变化时，容器内部具备自动更新的能力，但是通过环境变量设置到容器内部该值不具备自动更新的能力。所以一般推荐使用Volume挂载的方式使用Secret。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1 </span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: easybanner-deployment </span><br><span class="line">  namespace: bot </span><br><span class="line">  labels:  </span><br><span class="line">    app: easybanner</span><br><span class="line">spec: </span><br><span class="line">  replicas: 1</span><br><span class="line">  selector: </span><br><span class="line">    matchLabels: </span><br><span class="line">      app: easybanner</span><br><span class="line">  template: </span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: easybanner</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: easybanner-secret-config</span><br><span class="line">          secret:</span><br><span class="line">            secretName: easybanner-secret</span><br><span class="line">      containers: </span><br><span class="line">      - name: easybanner</span><br><span class="line">        image: reg.redrock.team/library/easybanner:1.0</span><br><span class="line">        env:</span><br><span class="line">          - name: App_ID</span><br><span class="line">            valueFrom:</span><br><span class="line">              secretKeyRef:</span><br><span class="line">                name: easybanner-secret</span><br><span class="line">                key: App_ID</span><br><span class="line">          - name: App_Secret</span><br><span class="line">            valueFrom:</span><br><span class="line">              secretKeyRef:</span><br><span class="line">                name: easybanner-secret</span><br><span class="line">                key: App_Secret</span><br><span class="line">          - name: URL</span><br><span class="line">            valueFrom:</span><br><span class="line">              secretKeyRef:</span><br><span class="line">                name: easybanner-secret</span><br><span class="line">                key: URL</span><br><span class="line">          - name: GIN_MODE</span><br><span class="line">            valueFrom:</span><br><span class="line">              secretKeyRef:</span><br><span class="line">                name: easybanner-secret</span><br><span class="line">                key: GIN_MODE</span><br><span class="line">        volumeMounts:</span><br><span class="line">          - name: easybanner-secret-config</span><br><span class="line">            mountPath: /app/secrets</span><br><span class="line">            readOnly: true</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建并使用DockerConfig-Secret（镜像拉取Secret）">创建并使用DockerConfig Secret（镜像拉取Secret）</h4><p>⼤部分组织机构不希望它们的镜像开放给所有⼈，因此会使⽤私有镜像仓库。部署⼀个pod时，如果容器镜像位于私有仓库，Kubernetes需拥有拉取镜像所需的证书。</p><p>我们可以直接create secret，只是参数有些差异。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry secret-dockercfg --docker-username=xxx --docker-password=xxx --docker-email=xxx</span><br></pre></td></tr></table></figure><p>而我们在宿主机docker login时，用户名和密码信息被保存在<code>~/.docker/config.json</code>，我们也可以对这个文件进行base64编码后填入<code>.dockerconfigjson</code>字段中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base64 ~/.docker/config.json</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: secret-dockercfg</span><br><span class="line">type: kubernetes.io/dockerconfigjson #指定类型 使用新版本的 </span><br><span class="line">data:</span><br><span class="line">  .dockerconfigjson: |</span><br><span class="line">        &quot;&lt;base64 encoded ~/.docker/config.json file&gt;&quot;</span><br></pre></td></tr></table></figure><p>然后再Pod中使用Secret</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pull-images</span><br><span class="line">spec:</span><br><span class="line">  imagePullSecrets: # 在这里指定Secret名称</span><br><span class="line">  - name: secret-dockercfg</span><br><span class="line">  containers:</span><br><span class="line">  - image: zhangxinhui02/nginx:private</span><br><span class="line">    name: nginx-private</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 第三讲</title>
      <link href="/2024/11/08/Kubernetes%20%E7%AC%AC%E5%9B%9B%E8%AE%B2/"/>
      <url>/2024/11/08/Kubernetes%20%E7%AC%AC%E5%9B%9B%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h1>Kubernetes 第四讲</h1><h2 id="调度">调度</h2><p>Kubernetes允许你去影响pod被调度到哪个节点。起初，只能通过在pod规范⾥指定节点选择器来实现，后⾯通过其他机制的逐渐加⼊来扩容这项功能。</p><h3 id="固定节点（NodeName）">固定节点（NodeName）</h3><p>指定Pod调度到某个节点上并且固定</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: node-name-test</span><br><span class="line">  labels:</span><br><span class="line">    app: node-name-test</span><br><span class="line">spec:</span><br><span class="line">  replicas: 5</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: node-name-test</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: node-name-test</span><br><span class="line">    spec:</span><br><span class="line">      nodeName: master # 指定节点名即可</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br></pre></td></tr></table></figure><h3 id="标签选择器">标签选择器</h3><p>根据标签选择可以调度的节点</p><p>给节点打标签</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubect label nodes master disk-type=ssd # 给名为master的节点打上名为disk-type，值为ssd的标签</span><br></pre></td></tr></table></figure><p>去除标签</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl label nodes master disk-type- # 最后一个杠表示取消节点上的特定标签</span><br></pre></td></tr></table></figure><p>只有具备这个标签的节点才会被 Deployment 选择来部署 Pod。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: node-name-test</span><br><span class="line">  labels:</span><br><span class="line">    app: node-name-test</span><br><span class="line">spec:</span><br><span class="line">  replicas: 5</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: node-name-test</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: node-name-test</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br><span class="line">      nodeSelector:</span><br><span class="line">        disk-type: ssd</span><br></pre></td></tr></table></figure><h3 id="污点（Taints）和容忍度（Tolerations）">污点（Taints）和容忍度（Tolerations）</h3><p>节点污点以及pod对于污点的容忍度⽤于限制哪些pod可以被调度到某⼀个节点。只有当⼀个pod容忍某个节点的污点，这个pod才能被调度到该节点。</p><p>容忍度是通过明确的<strong>在pod中</strong>添加的信息，来决定⼀个pod可以或者不可以被调度到哪些节点上。</p><p>污点则是在不修改已有pod信息的前提下，通过在<strong>节点上</strong>添加污点信息，来拒绝pod在某些节点上的部署。</p><p>使用<code>kubectl describe node &lt;node-name&gt;</code>来查看污点<code>Taints</code></p><p>污点的表现形式为<code>&lt;key&gt;=&lt;value&gt;:&lt;effect&gt;</code></p><h4 id="在节点上打上污点">在节点上打上污点</h4><p>如果我想给节点打上一个污点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl taint node master node-role.kubernetes.io/master=:NoSchedule # node-role.kubernetes.io/master是社区推荐的标签命名约定</span><br><span class="line"></span><br><span class="line">kubectl taint node master node-role.kubernetes.io/master- # 在键名后加-可以去除污点</span><br></pre></td></tr></table></figure><p>这会给master节点打上污点，阻止一般Pod被调度到该节点上。一般可以容忍这个污点的Pod都是系统级别的Pod（比如某些系统组件以Pod形式运行）</p><p>而effect有三种</p><ul><li>NoSchedule表⽰如果pod没有容忍这些污点，pod则不能被调度到包含这些污点的节点上。</li><li>PreferNoSchedule是NoSchedule的⼀个宽松的版本，表⽰尽量阻⽌pod被调度到这个节点上，但是如果没有其他节点可以调度，pod依然会被调度到这个节点上。</li><li>NoExecute不同于NoSchedule以及PreferNoSchedule，后两者只在调度期间起作⽤，⽽NoExecute也会影响正在节点上运⾏着的pod。如果在⼀个节点上添加了NoExecute污点，那些在该节点上运⾏着的pod，如果没有容忍这个NoExecute污点，将会从这个节点去除。</li></ul><p><em><strong>污点有什么用？</strong></em></p><p>比如有⼀个单独的Kubernetes集群，上⾯同时有⽣产环境和⾮⽣产环境的流量。其中最重要的⼀点是，⾮⽣产环境的pod不能运⾏在⽣产环境的节点上。我们就可以通过在⽣产环境的节点上添加污点来满⾜这个要求。</p><h4 id="在Pod上添加污点容忍度">在Pod上添加污点容忍度</h4><p>为了将⽣产环境的Pod部署到生产环境节点上，Pod需要能容忍那些你添加在节点上的污点。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: taint-test</span><br><span class="line">  labels:</span><br><span class="line">    app: taint-test</span><br><span class="line">spec:</span><br><span class="line">  replicas: 5</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: taint-test</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: taint-test</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br><span class="line">      tolerations: # 添加容忍度</span><br><span class="line">      - key: node-type</span><br><span class="line">        operator: Equal</span><br><span class="line">        value: production</span><br><span class="line">        effect: NoSchedule</span><br></pre></td></tr></table></figure><p>Equal操作符要求污点的键和值必须与容忍度规则中指定的键和值完全匹配。也就是说只有当节点上设置了 key 为 node-type，并且这个 key 对应的值为 production时，才会使得 Pod 具有容忍度，并且可以被调度到带有对应污点的节点上。其他任何不符合该要求的污点都将不会影响 Pod 的调度。</p><h3 id="节点亲和性">节点亲和性</h3><p>污点可以⽤来让pod远离特定的节点。而节点亲和性（node affinity）这种机制允许你通知Kubernetes将pod只调度到某个⼏点⼦集上⾯。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用首选的节点亲和性调度 Pod</span><br><span class="line">本清单描述了一个 Pod，它有一个节点亲和性设置 preferredDuringSchedulingIgnoredDuringExecution，disktype: ssd。 这意味着 Pod 将首选具有 disktype=ssd 标签的节点。</span><br><span class="line"></span><br><span class="line">pods/pod-nginx-preferred-affinity.yaml 复制 pods/pod-nginx-preferred-affinity.yaml 到剪贴板</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 1</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: disktype</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - ssd          </span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br></pre></td></tr></table></figure><h2 id="Helm">Helm</h2><blockquote><p><a href="https://helm.sh/zh/docs/">Helm | Docs</a></p></blockquote><p>Helm是一款开源的K8s包管理器，类似于apt，yum或者Python中的 pip 一样，能快速查找、下载和安装软件包。Helm能够将一组K8S资源打包统一管理, 是查找、共享和使用为Kubernetes构建的软件的最佳方式。</p><p><em><strong>为什么要使用Helm？</strong></em></p><p>假如现在需要部署一个复杂且庞大的服务，我需要很多个yaml文件一个一个配好每一种资源对象，这样做很麻烦。Helm很好地解决了这个问题，它能够把这些零零散散的应用资源文件放在一起进行统一配置，从而方便其他人地部署与使用，就和<code>apt install</code>一样，仅仅一句<code>helm install</code>就可以部署好一个现成的服务了。</p><h3 id="安装">安装</h3><p>使用脚本安装，它可以让你知道在执行之前脚本做了什么</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3</span><br><span class="line"></span><br><span class="line">chmod 700 get_helm.sh</span><br><span class="line"></span><br><span class="line">./get_helm.sh</span><br></pre></td></tr></table></figure><p>或者直接执行安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash</span><br></pre></td></tr></table></figure><h3 id="基本概念">基本概念</h3><p><em>Chart</em> 代表着 Helm 包。它包含在 Kubernetes 集群内部运行应用程序，工具或服务所需的所有资源定义。你可以把它看作是 Apt dpkg，或 Yum RPM 在Kubernetes 中的等价物。</p><p><em>Repository（仓库）</em> 是用来存放和共享 charts 的地方。官方仓库是<a href="https://link.zhihu.com/?target=https%3A//hub.helm.sh">hub.helm.sh</a>，你也可以用Harbor来存放charts。</p><p><em>Release</em> 是运行在 Kubernetes 集群中的 chart 的实例。一个 chart 通常可以在同一个集群中安装多次，每一个release指定不同的名称即可。每一次安装都会创建一个新的 <em>release</em>。</p><p>Helm的工作流程：Helm 安装 <em>charts</em> 到 Kubernetes 集群中，每次安装都会创建一个新的 <em>release</em>。你可以在 Helm 的 chart <em>repositories</em> 中寻找新的 chart。</p><h3 id="基本命令使用">基本命令使用</h3><h4 id="helm-search">helm search</h4><p>用来查找Charts</p><p><code>helm search hub wordpress</code>查找Artifact Hub中搜索到所有的wordpress charts</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405122144183.png" alt="image-20240512214450115"></p><p><code>helm search repo</code>从你添加的仓库中查找chart</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202405122145227.png" alt="image-20240512214521155"></p><h4 id="helm-install">helm install</h4><p>用来安装helm包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm search repo wordpress</span><br><span class="line">helm install wordpress bitnami/wordpress # 从bitnami这个仓库中安装wordpress的chart，把这个release命名为wordpress，它被安装在default下</span><br></pre></td></tr></table></figure><p><code>helm status</code>可以用来追踪release的状态</p><p>使用<code>helm uninstall -n &lt;namespace&gt;</code> 来卸载release</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm uninstall wordpress # 指定release名称</span><br><span class="line">helm list # 查看当前命名空间部署的所有release</span><br></pre></td></tr></table></figure><h4 id="自定义安装配置">自定义安装配置</h4><p>很多时候我们需要自定义chart来指定我们想要的配置。</p><p>使用 <code>helm show values</code> 可以查看 chart 中的可配置选项</p><p>你可以<code>helm pull  &lt;chart.tgz&gt;</code>手动拉取chart包，解压后手动修改其中的<code>values.yaml</code>中的任意配置项，然后在安装时指定我们自定义的配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm install -f values.yaml bitnami/wordpress</span><br></pre></td></tr></table></figure><p>如果配置不多，可以直接使用命令行<code>-- set</code>来对指定项进行覆盖</p><p><code>--set</code>有一些格式限制：</p><p>最简单用法（键值对形式）：–set name=value，等价于如下yaml格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: value</span><br></pre></td></tr></table></figure><p>多个值用逗号分隔：–set outer.inner=value，他被转化为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">outer:</span><br><span class="line">  inner: value</span><br></pre></td></tr></table></figure><p>列表使用花括号：–set name={a, b, c}，等价于</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name:</span><br><span class="line">  - a</span><br><span class="line">  - b</span><br><span class="line">  - c</span><br></pre></td></tr></table></figure><p>某些键值可以设置为null或空：–set name=[],a=null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: []</span><br><span class="line">a: null</span><br></pre></td></tr></table></figure><p>从2.5.0版本开始，还可以使用数组下标的方式访问列表中的元素。例如：–set servers[0].port=80</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">servers:</span><br><span class="line">  - port: 80</span><br></pre></td></tr></table></figure><p>多个值（逗号分隔）：–set servers[0].port=80,servers[0].host=example</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">servers:</span><br><span class="line">  - port: 80</span><br><span class="line">    host: example</span><br></pre></td></tr></table></figure><p>如果要使用特殊字符，使用反斜线来转义：–set name=value1,value2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: &quot;value1,value2&quot;</span><br></pre></td></tr></table></figure><p>更复杂的话就不要使用–set了，直接修改values.yaml</p><h4 id="helm-upgrade和helm-rollback">helm upgrade和helm rollback</h4><p>用来升级release和失败时恢复</p><p>一次升级操作会使用已有的 release 并根据你提供的信息对其进行升级。由于 Kubernetes 的 chart 可能会很大而且很复杂，Helm 会尝试执行最小侵入式升级。即它只会更新自上次发布以来发生了更改的内容。</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">helm upgrade -f panda.yaml happy-panda bitnami/wordpress</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>happy-panda</code> 这个 release 使用相同的 chart 进行升级，但是使用了一个新的 YAML 文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mariadb.auth.username:</span> <span class="string">user1</span></span><br></pre></td></tr></table></figure><p>这样配置中会更新这一项配置</p><p>如果发布过程中出现不符合预期的事情，helm可以像deployment一样进行回滚到之前的版本</p><h4 id="helm-repo">helm repo</h4><p>可以查看仓库</p><p><code>helm repo list</code>列出当前已经添加的仓库</p><p><code>helm repo add</code>添加新的仓库</p><p><code>helm repo update</code>更新仓库</p><h3 id="创建自己的charts">创建自己的charts</h3><h4 id="快速开始">快速开始</h4><p>你可以通过<code>helm create</code>来快速生成一个chart模板</p><p>在编辑chart时，可以通过<code>helm lint</code>验证格式是否正确</p><p>编辑完成后，使用<code>helm package</code>来打包chart，然后这个chart就可以install安装，还可以上传到chart仓库中。</p><p>当你想测试模板渲染的内容但又不想安装任何实际应用时，可以使用<code>helm install --debug --dry-run goodly-guppy ./mynginx</code>。这样不会安装应用(chart)到你的kubenetes集群中，只会渲染模板内容到控制台（用于测试）。</p><h4 id="编写相关文件">编写相关文件</h4><p>Helm chart的结构如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mychart/</span><br><span class="line">  Chart.yaml</span><br><span class="line">  values.yaml</span><br><span class="line">  charts/</span><br><span class="line">  templates/</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><code>templates/</code> 目录包括了模板文件。也就是Deployment、Service、ConfigMap等的yaml文件，helm会将这些发送给Kubernetes，Kubernetes根据这些创建资源。和一般的创建资源方式不同的是，这些yaml文件中的一些参数和变量会在安装时由 Helm 进行替换或填充，然后在values.yaml集中设置。</p><p><code>values.yaml</code> 文件也导入到了模板。这个文件包含了chart的 <em>默认值</em> 。</p><p><code>Chart.yaml</code> 文件包含了该chart的描述。</p><p><em><strong>创建一个自己的nginx chart</strong></em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm create mynginx</span><br></pre></td></tr></table></figure><p>可以看到<code>mynginx/templates/</code> 目录下一些文件已经存在了：</p><ul><li><code>NOTES.txt</code>: chart的&quot;帮助文本&quot;。这会在你的用户执行<code>helm install</code>时展示给他们。</li><li><code>deployment.yaml</code>: 创建Kubernetes <a href="https://kubernetes.io/docs/user-guide/deployments/">工作负载</a>的基本清单</li><li><code>service.yaml</code>: 为你的工作负载创建一个 <a href="https://kubernetes.io/docs/user-guide/services/">service终端</a>基本清单。</li><li><code>_helpers.tpl</code>: 放置可以通过chart复用的模板辅助对象</li></ul><p>我们先把它们都删掉，然后自己创作相关文件。</p><p>我们的<code>templates/</code>下主要需要<code>deployment.yaml</code>和<code>service.yaml</code></p><p>模板文件可以像平时手动编写资源清单yaml文件的格式一样，但是将某些值硬编码到一个键中不是一个很好的方式。helm提倡使用插入的方式来生成某些字段，这样可以提高配置的灵活性和可维护性。</p><p>helm中以<code>&#123;&#123; xxx &#125;&#125;</code>的形式来进行插入。</p><p>我们以这两个正常的资源文件作为基础，然后按照插入的方式来对某些字段进行修改，使它们变得有helm的风格。</p><p><strong>内置对象</strong></p><p>对象可以通过模板引擎传递到模板中。以下是一些内置的对象。</p><ul><li><code>Release</code>：<code>Release</code>对象描述了版本发布本身。<a href="http://xn--Release-i22m936anj8aupvlxd.Name">比如常用的Release.Name</a>，代表了release的名称。</li><li><code>Values</code>：<code>Values</code>对象是从<code>values.yaml</code>文件和用户提供的文件传进模板的。默认为空。</li><li><code>Chart</code>：<code>Chart.yaml</code>文件内容。 <code>Chart.yaml</code>里的所有数据在这里都可以可访问的。比如 <code>&#123;&#123; .Chart.Name &#125;&#125;-&#123;&#123; .Chart.Version &#125;&#125;</code> 会打印出 <code>mychart-0.1.0</code></li></ul><p><strong>Values文件</strong></p><p>它的内容可以来自多个位置</p><ul><li>chart中的<code>values.yaml</code>文件</li><li>使用<code>-f</code>参数(<code>helm install -f myvals.yaml ./mychart</code>)传递到 <code>helm install</code> 或 <code>helm upgrade</code>的values文件</li><li>使用<code>--set</code> (比如<code>helm install --set foo=bar ./mychart</code>)传递的单个参数</li></ul><p>以上列表有明确顺序：默认使用<code>values.yaml</code>，优先级为<code>values.yaml</code>最低，<code>--set</code>参数最高。</p><p><strong>模板函数</strong></p><p>到目前为止，我们已经知道了如何将信息传到模板中。 但是传入的信息并不能被修改。 有时我们希望以一种更有用的方式来转换所提供的数据。</p><p>helm中通常倒置命令，借用管道符来使用函数，这种感觉就像使用管道符把参数“发送”给函数。</p><p>比如<code>quote</code>函数把<code>.Values</code>对象中的字符串属性用引号引起来，然后放到模板中</p><p>本来应该这样写</p><p>首先在<code>values.yaml</code>中定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favourite: rice</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; quote .Values.favorite.food &#125;&#125;  # 转换为&quot;rice&quot;，就是加了个引号</span><br></pre></td></tr></table></figure><p>但helm提倡这样写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; .Values.favorite.food | quote &#125;&#125;</span><br></pre></td></tr></table></figure><p>模板中频繁使用的一个函数是<code>default</code>，这个函数允许你在模板中指定一个默认值，以防这个值被忽略。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace: &#123;&#123; .Values.namespace | default &quot;default&quot; &#125;&#125;</span><br><span class="line"># 指定命名空间，如果values.yaml里没有指定（没有namespace这个键），就默认指定default</span><br></pre></td></tr></table></figure><p><strong>流控制</strong></p><p>有时我们在<code>values.yaml</code>中会利用<code>enable: true/false</code>来开启或关闭某些功能<br>这是可以利用控制结构<code>if/else</code>块来实现。<br><code>values.yaml</code>中开启NodePort</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NodePort:</span><br><span class="line">  enable: true # or flase 使用布尔值</span><br><span class="line">  type: NodePort</span><br><span class="line">  nodePort: 30001</span><br><span class="line">  port: 9376</span><br></pre></td></tr></table></figure><p><code>templates/NodePort.yaml</code>首尾加上<code>&#123;&#123; if .Values.NodePort.enable &#125;&#125;</code>和<code>&#123;&#123; end &#125;&#125;</code>即可</p><p>还有其他的控制结构</p><ul><li>with：用来指定变量范围</li><li>range：用做循环</li></ul><p><strong>命名模板</strong></p><p>在编写模板细节之前，文件的命名惯例需要注意：</p><ul><li><code>templates/</code>中的大多数文件被视为包含Kubernetes清单</li><li><code>NOTES.txt</code>是个例外</li><li>命名以下划线(<code>_</code>)开始的文件则假定 <em>没有</em> 包含清单内容。这些文件不会渲染为Kubernetes对象定义，但在其他chart模板中都可用。</li></ul><p>当我们第一次创建<code>mynginx</code>时，会看到一个名为<code>_helpers.tpl</code>的文件，这个文件是模板局部的默认位置。</p><p><strong>define和template</strong></p><p>我们可以使用<code>define</code>和<code>template</code>来声明和使用模板</p><p>比如我在<code>_helpers.tpl</code>中创建一个模板。按照惯例<code>define</code>方法会有个简单的文档块(<code>&#123;&#123;/* ... */&#125;&#125;</code>)来描述要做的事。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- define &quot;MY.NAME&quot; &#125;&#125;</span><br><span class="line">  # body of template here</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;/* Generate basic labels */&#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;mynginx.labels&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>template</code>来使用模板</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: &#123;&#123; .Release.Name &#125;&#125;-deployment </span><br><span class="line">  namespace: &#123;&#123; .Values.namespace | default &quot;default&quot; &#125;&#125;</span><br><span class="line">  &#123;&#123;- template &quot;mynginx.labels&quot; &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>include方法</strong></p><p>假设我们刚才的模板是这样的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- define &quot;mynginx.labels&quot; &#125;&#125;</span><br><span class="line">app: nginx # 顶格没有空格</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p>这时插入模板文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: &#123;&#123; .Release.Name &#125;&#125;-deployment </span><br><span class="line">  namespace: &#123;&#123; .Values.namespace | default &quot;default&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">  &#123;&#123;- template &quot;mynginx.labels&quot; &#125;&#125;</span><br></pre></td></tr></table></figure><p>这时它的输出如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: &#123;&#123; .Release.Name &#125;&#125;-deployment </span><br><span class="line">  namespace: &#123;&#123; .Values.namespace | default &quot;default&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">app: nginx  </span><br></pre></td></tr></table></figure><p>注意到<code>app: nginx</code>的缩进不对。因为被替换的模板中文本是左对齐的。由于<code>template</code>是一个行为，不是方法，无法将 <code>template</code>调用的输出传给其他方法，数据只是简单地按行插入。</p><p>为了处理这个问题，Helm提供了一个<code>template</code>的可选项，可以将模板内容导入当前管道，然后传递给管道中的其他方法。</p><p>使用<code>indent</code>正确地缩进</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: &#123;&#123; .Release.Name &#125;&#125;-deployment </span><br><span class="line">  namespace: &#123;&#123; .Values.namespace | default &quot;default&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">&#123;&#123;include &quot;mynginx.labels&quot; | indent 4 &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>NOTES.txt文件</strong></p><p>在<code>helm install</code> 或 <code>helm upgrade</code>命令的最后，Helm会打印出对用户有用的信息。这些信息保存在<code>NOTE.txt</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thank you for installing &#123;&#123; .Chart.Name &#125;&#125;.</span><br><span class="line"></span><br><span class="line">Your release is named &#123;&#123; .Release.Name &#125;&#125;.</span><br><span class="line"></span><br><span class="line">To learn more about the release, try:</span><br><span class="line"></span><br><span class="line">  $ helm status &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">  $ helm get all &#123;&#123; .Release.Name &#125;&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thank you for installing mynginx.</span><br><span class="line"></span><br><span class="line">Your release is named nginx1.</span><br><span class="line"></span><br><span class="line">To learn more about the release, try:</span><br><span class="line"></span><br><span class="line">  $ helm status nginx1</span><br><span class="line">  $ helm get all nginx1</span><br></pre></td></tr></table></figure><p><strong>Chart.yaml</strong></p><p>这个文件声明了当前 Chart 的名称、版本等基本信息，这些信息会在该 Chart 被放入仓库后，供用户浏览检索。</p><p>在 Chart.yaml 里有两个跟版本相关的字段，其中 version 指明的是 Chart 的版本，也就是我们应用包的版本，而 appVersion 指明的是内部实际使用的应用版本。这两个字段互不相关，此字段仅供参考，对chart版本计算没有影响。我们可以不关心它。</p><p>比如 <code>nginx</code> chart的版本字段<code>version: 1.2.3</code>按照名称被设置为：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nginx-1.2.3.tgz</span><br></pre></td></tr></table></figure><h3 id="打包chart并上传到Harbor">打包chart并上传到Harbor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打包chart</span><br><span class="line">helm package CHART_PATH</span><br><span class="line"></span><br><span class="line"># 登录harbor</span><br><span class="line">helm registry login reg.redrock.team -u admin -p xxx</span><br><span class="line"></span><br><span class="line"># 推送chart</span><br><span class="line">helm push CHART_PACKAGE oci://reg.redrock.team/library</span><br></pre></td></tr></table></figure><p>也可以把打包好的chart上传到Github上，然后通过<code>helm pull</code>解压安装</p><h2 id="其他">其他</h2><h3 id="Kubeconfig">Kubeconfig</h3><p><a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/organize-cluster-access-kubeconfig/">使用 kubeconfig 文件组织集群访问 | Kubernetes</a></p><p><code>kubectl</code> 命令行工具使用 kubeconfig 文件来查找选择集群所需的信息（指定要操作的集群），并与集群的 API 服务器进行通信。Helm同样使用kubeconfig来指定操作的集群。</p><p>用于配置集群访问的文件称为 <strong>kubeconfig 文件</strong>。 这是引用到配置文件的通用方法，并不意味着有一个名为 <code>kubeconfig</code> 的文件。</p><p>默认情况下，<code>kubectl</code> 在 <code>$HOME/.kube</code> 目录下查找名为 <code>config</code> 的文件。 你可以通过设置 <code>KUBECONFIG</code> 环境变量或者设置 <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl/"><code>--kubeconfig</code></a>参数来指定其他 kubeconfig 文件。</p><p><a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">配置对多集群的访问 | Kubernetes</a></p><p>查看<code>config</code>签发日期</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in /etc/kubernetes/pkki/apiserver.crt -noout -text | grep Not</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Helm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 第二讲</title>
      <link href="/2024/11/08/Kubernetes%20%E7%AC%AC%E4%BA%8C%E8%AE%B2/"/>
      <url>/2024/11/08/Kubernetes%20%E7%AC%AC%E4%BA%8C%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<p>在没有工作负载之前，我们都是直接手动创建一个一个的Pod。但是如果当我们需要将一个复杂的服务部署到庞大的集群上并且实现高可用，我们总不能每个节点上都部署一遍吧。况且如果你可以将所有的Pod手动都创建好，但是如果镜像发生了更新，我们也需要将一个一个的Pod手动进行更新。太麻烦了，这个时候我们就可以使用工作负载，它可以帮助我们更高的管理Pod。</p><h2 id="工作负载">工作负载</h2><blockquote><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/">工作负载 | Kubernetes</a></p></blockquote><p>工作负载是在 Kubernetes 上运行的应用程序。</p><p>为了减轻用户的使用负担，通常不需要用户直接管理每个 Pod。 而是使用<strong>负载资源</strong>来替用户管理一组 Pod。 这些负载资源通过配置<strong>控制器</strong>来确保正确类型的、处于运行状态的 Pod 个数是正确的，与用户所指定的状态相一致。</p><p>Kubernetes 提供若干种内置的工作负载资源</p><ul><li>Deployment和ReplicaSet</li><li>StatefulSet：有状态服务，为 Pod 提供持久存储和持久标识符。</li><li>DaemonSet：守护型应用部署，如日志、监控组价。</li><li>Job和CronJob：定时任务部署，指定时间运行。</li></ul><h3 id="Deployment">Deployment</h3><p>Deployment是Kubernetes中用于定义Pod副本集的对象，它负责管理应用的部署和更新。通过Deployment，可以实现应用的<strong>滚动更新、回滚</strong>以及<strong>自动修复</strong>。</p><h4 id="工作模式">工作模式</h4><p>Deployment并不直接管理Pod，而是管理ReplicaSet，ReplicaSet再管理Pod。在我们创建 Deployment 的时候，它会用自己的 Pod 规范创建一个 ReplicaSet。当更新一个 Deployment 并修改副本数量时，它会把更新内容传递给下游的 ReplicaSet。</p><p>一个 ReplicaSet 对象就是由副本数目的定义和一个 Pod 模板组成的, 它的定义就是 Deployment 的一个子集。它主要关注的是Pod实例的数量，并在Pod出现问题时，维持所需副本数量。</p><p>Deployment则是建立在ReplicaSet之上的更高级别的抽象，用于管理Pod副本集和应用程序的部署。然后它多了滚动更新、回滚以及自动修复这些功能。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404131922989.png" alt="img"></p><h4 id="主要组成部分">主要组成部分</h4><ol><li><strong>模板（Template）</strong>：定义了要创建的Pod的规范，包括镜像、环境变量、卷等。当副本数不足时会根据模板新建Pod。</li><li><strong>副本数（Replica Count）</strong>：指定了希望运行的Pod副本数量。</li><li><strong>升级策略（Update Strategy）</strong>：定义了应用更新的策略，包括滚动更新、Recreate等。</li><li><strong>标签选择器（Label Selector）</strong>：用于选择要进行管理的Pod副本集。</li><li><strong>滚动升级（Rolling Update）</strong>：一种升级策略，通过逐步替换旧的Pod实例来实现平滑的升级。</li></ol><h4 id="特点">特点</h4><ol><li><strong>滚动更新</strong>：保证更新过程不中断服务。</li><li><strong>副本管理</strong>：保证始终有指定数量的实例在运行。</li><li><strong>自动修复</strong>：当Pod发生故障时会自动替换为新的Pod。</li><li><strong>版本回滚</strong>：允许用户回滚到先前的版本，以应对更新带来的问题</li></ol><h4 id="示例：使用Deployment部署Nginx">示例：使用Deployment部署Nginx</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1 # API版本</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata: # 元数据部分</span><br><span class="line">  name: nginx-deployment # 资源名称</span><br><span class="line">  namespace: </span><br><span class="line">  labels: # 给deployment打的标签</span><br><span class="line">    app: nginx # 名为app值为nginx的标签</span><br><span class="line">spec: # 定义部署对象的规范</span><br><span class="line">  replicas: 3 # 副本数量</span><br><span class="line">  selector: # 选择器部分，用于指定哪些Pod副本属于此部署</span><br><span class="line">    matchLabels: # 匹配标签部分。Service通过这里来匹配Pod</span><br><span class="line">      app: nginx # 指定要匹配的标签为app=nginx，用于选取具有这个标签的Pod副本</span><br><span class="line">  template: # 模板部分</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx # 需要与selector设置的标签一致</span><br><span class="line">    spec:</span><br><span class="line">      containers: # 用于定义Pod中的容器</span><br><span class="line">      - name: nginx # 容器名称</span><br><span class="line">        image: reg.redrock.team/library/nginx:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80 # 暴露容器的80端口供外部访问</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f deploy.yaml</span><br></pre></td></tr></table></figure><p>可以看到RS的NAME是在Deployment之后加了一段字符串，而Pod是在RS后又加了一段字符串，说明Pod其实是由RS直接管理的。</p><h5 id="副本伸缩">副本伸缩</h5><p>方式一：命令行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl scale deploy NAME --replicas=pod数量 -n NAMESPACE</span><br></pre></td></tr></table></figure><p>方式二：编辑yaml文件</p><p>修改<code>replicas</code>值即可。</p><p><em>Pod为什么要有副本数？</em></p><ul><li>使用多个副本来运行同一个服务，可以提高应用的可用性。如果一个Pod因为故障而被杀死，其他Pod会立即来替代它，从而保证了服务的稳定性。</li><li>多个副本可以将流量分散到不同的Pod，从而实现负载均衡，避免所有流量集中在一个Pod上导致负载过高。流量高时，我们可以增加副本数，少时可以减少副本数，从而节省资源。</li><li>多个Pod可以实现平滑的滚动更新。</li></ul><h5 id="镜像更新">镜像更新</h5><p>Deployment支持两种镜像更新策略：<strong>重建更新（Recreate）<strong>和</strong>滚动更新（默认）（RollingUpdate）</strong>，可以通过<code>strategy</code>选项进行配置。</p><p><strong>重建更新（Recreate）</strong></p><p>在<code>spec</code>下增加如下字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  strategy:  # 策略</span><br><span class="line">    type: Recreate  # 重建更新策略</span><br></pre></td></tr></table></figure><p><strong>滚动更新（RollingUpdate）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strategy:</span><br><span class="line">  type: RollingUpdate # 滚动更新策略，可以不加，因为默认就是滚动更新</span><br><span class="line">  rollingUpdate:</span><br><span class="line">    maxUnavailable: 25%</span><br><span class="line">    maxSurge: 25%</span><br></pre></td></tr></table></figure><p><code>MaxSurge</code>和<code>MaxUnavailable</code>，这两个参数决定了更新过程的速度。这两个参数可以是 Pod 数量，也可以是 Deployment 的实例数量百分比。</p><p><em>为什么要有这两个参数？为什么要设置更新过程的速度？</em></p><ul><li>我们的服务很重要，对服务的变更需要非常谨慎。因此决定在关闭旧版本Pod之前，需要首先启动新Pod。只有新 Pod 启动、运行并就绪之后，才能杀死旧 Pod。</li><li>假如我们的集群已经满载，无法负担多余的Pod消耗，我们自然需要先关掉旧Pod，然后才启动新Pod。</li></ul><p>当<code>MaxUnavailable</code>设置为 0 意味着：“在新 Pod 启动并就绪之前，不要关闭任何旧 Pod”。</p><p>当<code>MaxSurge</code>设置为 100% 的意思是：“立即启动所有新 Pod”，也就是说我们有足够的资源，我们希望尽快完成更新。</p><p>这两个默认值是25%，假如我们有3个副本，意味着更新时允许 25%（0.75个取整为1） 的Pod处于不可用状态，允许最多增加1个新Pod。</p><h5 id="版本回退">版本回退</h5><p>Deployment支持版本升级过程中的暂停，继续功能以及版本回退等诸多功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl rollout option NAME -n NAMESPACE</span><br><span class="line">kubectl rollout：版本升级相关功能，支持下面的选项：</span><br><span class="line"></span><br><span class="line">status：显示当前升级状态</span><br><span class="line">history：显示升级历史记录</span><br><span class="line">pause：暂停版本升级过程</span><br><span class="line">resume：继续已经暂停的版本升级过程</span><br><span class="line">restart：重启版本升级过程</span><br><span class="line">undo：回滚到上一级版本（可以使用--to-revision回滚到指定版本）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="金丝雀发布">金丝雀发布</h5><p>Deployment支持更新过程中的控制，如&quot;暂停（pause）&quot;或&quot;继续（resume）&quot;更新操作。</p><p>有时我们不想让测试版本影响所有用户，即使是短时间也不行。所以我们可以部分推出新版本。例如我们部署新旧两组实例，1% 的流量发送给新版本，先筛选一小部分的用户请求路由到新的pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的pod资源滚动更新，否则立即回滚更新操作。</p><p>现在的镜像版本是<code>latest</code>，切换版本到<code>1.19.2</code>，变更途中使用<code>pause</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl set image deploy nginx-deployment nginx=reg.redrock.team/library/nginx:1.19.2 -n lesson-demo&amp;&amp; kubectl rollout pause deploy nginx-deployment -n lesson-demo</span><br></pre></td></tr></table></figure><p>发现<code>1.19.2</code>版本只增加了一个RS，而<code>latest</code>版本没有减少</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404132157411.png" alt="image-20240413215726365"></p><p>查看更新状态，发现deployment正在等待更新，并且一个已经更新完成。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404132159933.png" alt="image-20240413215935892"></p><p>然后继续更新</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl rollout resume deploy nginx-deployment -n lesson-demo</span><br></pre></td></tr></table></figure><p>全部更新完成</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404132201230.png" alt=""></p><h2 id="服务发现与负载均衡">服务发现与负载均衡</h2><blockquote><p><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务（Service） | Kubernetes</a></p></blockquote><h3 id="为什么需要服务发现？">为什么需要服务发现？</h3><p>传统的部署应用服务方式都是直接部署在给定的机器上，访问服务时，我们只需要访问该机器的IP即可。但K8s集群中的应用都是通过Pod去部署的，而 pod 生命周期是短暂的。在 Pod 的生命周期过程中，比如它创建或销毁，它的 IP 地址都会发生变化，这样就不能使用传统的部署方式，不能指定 IP 去访问指定的应用。</p><h3 id="Service">Service</h3><p>前面我们通过Deployment创建了一组Pod，这些Pod组需要提供一个统一的访问入口，以及怎么去控制流量负载均衡到这个组里面。其实我们可以在部署时就提供一个模板以及访问方式，使应用服务暴露在外部。这时就需要服务发现，也就是K8s中的Service。</p><h4 id="示例：通过Service暴露Nginx服务">示例：通过Service暴露Nginx服务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">  namespace: lesson-demo</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx # 匹配具有该标签的Pod</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP </span><br><span class="line">      # 服务监听的端口号，当其他服务或外部客户端与该服务通信时，它们将使用这个端口号进行通信，该端口号是服务对外部暴露的入口。即通过clusterIP: port可以访问到某个service</span><br><span class="line">      port: 9376</span><br><span class="line">      # targetPort可以直接指定Pod的端口，也可以指定Pod端口所对应的名称。</span><br><span class="line">      # targetPort一定要与containerPort暴露出的端口对应</span><br><span class="line">      targetPort: 80</span><br></pre></td></tr></table></figure><h4 id="Service的类型">Service的类型</h4><p><strong>ClusterIP</strong></p><ul><li>只在集群内部生效的IP，集群内所有节点都能访问到它。</li><li>ClusterIP类型也是我们不指定类型时的默认Service类型。</li></ul><p><code>apply</code>之后，我们就可以通过访问<code>ClusterIP:PORT</code>的形式来访问到我们的服务。</p><p>访问方式：<code>ClusterIP:PORT</code></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404141722756.png" alt="image-20240414172201653"></p><p>这个 IP 地址就是 Service 的 IP 地址，这个 IP 地址在集群里面可以被其它 pod 所访问，相当于通过这个 IP 地址提供了统一的一个 pod 的访问入口，以及服务发现。而Endpoints是每个Pod的后端IP。</p><p><strong>NodePort</strong></p><p>当需要从集群外部访问Service时，就可以使用NodePort。</p><p>NodePort会在每个NodeIP上启用一个相同的端口来暴露服务。NodeIP就是我们在创建集群时指定的节点IP，端口限定范围为30000-32767。</p><p>当我们访问<code>NodeIP:PORT</code>时，流量会由 kube-proxy 网络组件进一步到给对应的 Pod。</p><p>访问方式：<code>NodeIP:PORT</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">  namespace: lesson-demo</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx </span><br><span class="line">  ports:</span><br><span class="line">    - port: 80</span><br><span class="line">      targetPort: 80</span><br><span class="line">      nodePort: 30007</span><br></pre></td></tr></table></figure><p><strong>LoadBalancer</strong></p><p>NodePort会在每台Node上监听端口接收用户流量，但在实际情况下，对用户暴露的只会有一个IP和端口，那这么多台Node该使用哪台让用户来访问呢？而且如果只访问一个NodeIP，那么这个节点压力会很大。</p><p>这时就需要前面加一个公网负载均衡器为项目提供统一访问入口了。</p><p>LoadBalancer 通常是云服务厂商提供的负载均衡器，我们通过外部的负载均衡器将流量路由到创建的服务商。</p><p>将Service的类型设置为LoadBalancer后，我们有两个选择，一个是设置负载均衡器的IP，另一种负载均衡器会自动为我们分配一个ExternalIP作为出口。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404141947530.png" alt="image"></p><p>访问方式：<code>EXTERNALIP:PORT</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  type: LoadBalancer</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx </span><br><span class="line">  ports:</span><br><span class="line">    - port: 80</span><br><span class="line">      targetPort: 80</span><br></pre></td></tr></table></figure><p><strong>externalIPs</strong></p><p>一般我们的服务只暴露了ClusterIP，而NodePort的端口又有30000-32767的范围限制。这时我们就可以配置上externalIP，表示来自externalIP的流量能进入我们的服务，</p><p>externalIP一般填负载均衡器的IP。</p><p>注意：externalIPs一定不能填NodeIP，不然会导致该节点直接崩溃（calico、kubelet、kube-proxy等组件无法与apiserver进行通信），出现<code>The connection to the server apiserver.cluster.local:6443 was refused - did you specify the right host or port?</code></p><p>原因分析可以看<a href="https://blog.csdn.net/qq_41586875/article/details/124330823">k8s IPVS模式下externalIP导致节点故障浅析_external-ip-CSDN博客</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  externalIPs:</span><br><span class="line">  - 1.2.3.4 </span><br><span class="line">  selector:</span><br><span class="line">    app: nginx </span><br><span class="line">  ports:</span><br><span class="line">    - port: 80</span><br><span class="line">      targetPort: 80</span><br></pre></td></tr></table></figure><h4 id="Service四种类型的对比">Service四种类型的对比</h4><table><thead><tr><th>类型</th><th>用途介绍</th></tr></thead><tbody><tr><td><code>ClusterIP</code></td><td>默认类型，自动分配一个仅<code>clusterIp</code>内部可以访问的虚拟ip地址</td></tr><tr><td><code>NodePort</code></td><td>在<code>ClusterIP</code>基础上为<code>Service</code>机器上绑定一个端口，这样就可以通过<code>NodePort</code>来访问服务</td></tr><tr><td><code>LoadBalancer</code></td><td>在<code>NodePort</code>基础上借助云服务商创建一个外部负载均衡器，并将请求转发到<code>NodePort</code>来访问服务</td></tr><tr><td><code>externalIPs</code></td><td>把集群外部的服务引入到集群内部来，在集群内部直接使用</td></tr></tbody></table><h4 id="Ingress和IngressRoute">Ingress和IngressRoute</h4><p>没有Ingress之前，我们使用NodePort对外暴露服务，但当服务多了以后，会存在一些弊端，比如暴露太多的的端口，无法实现域名转发等等。</p><p><strong>Ingress其实就是从Kubernetes集群外部访问的一个入口，它可以帮助我们通过不同域名来将流量匹配到对应的服务，类似于Nginx。</strong></p><p>Ingress在Service上面一层，可以定义集群外部到集群内Service的HTTP和HTTPS的路由。</p><p><img src="https://pic2.zhimg.com/80/v2-e368751ce503111283b098c90092ba95_720w.webp" alt="img"></p><p><strong>使用方法</strong>：先自行部署IngressController → 再部署Ingress资源。</p><p>IngressController的功能：</p><ul><li>接受外部流量，并将请求负载均衡到内部Pod</li><li>部署Ingress路由转发规则</li><li>监控Pod，并在添加或删除Pod后自动更新负载均衡规则。</li></ul><p>可以把Ingress controller理解为一个监听器，它可以不断地与 kube-apiserver 打交道，实时的感知后端 service、pod 的变化，当得到这些变化信息后，Ingress controller 再结合 Ingress 的配置，更新反向代理负载均衡器，达到服务发现的作用。</p><p>Ingress Controller的实现有多种，比如Ingress-Nginx、Traefik等，由于Ingress-Nginx的配置比较麻烦，所以我们一般使用它的替代品Traefik。</p><h4 id="Traefik-Ingress-Controller">Traefik Ingress Controller</h4><p>优势：</p><ol><li>部署过程简单</li><li>使用Go语言开发，完美贴合K8s</li><li>Traefik衍生的IngressRoute配置更加简洁，我们一般使用IngressRoute</li><li>拥有多种中间件，可以用于将请求路由到目的地之前或之后来调整请求。</li></ol><h5 id="安装">安装</h5><p>使用Helm安装（Helm是K8s中的一个包管理器）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm安装</span><br><span class="line">$ curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3</span><br><span class="line">$ chmod 700 get_helm.sh</span><br><span class="line">$ ./get_helm.sh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add traefik https://traefik.github.io/charts</span><br><span class="line">helm repo list</span><br><span class="line">helm repo update</span><br><span class="line">helm pull traefik/traefik</span><br><span class="line">kubectl create namespace traefik</span><br><span class="line">helm install traefik traefik/traefik -n traefik</span><br></pre></td></tr></table></figure><p>部署完成后，我们就可以把某个域名解析到我们的集群（下面把k8s.yiiong.top解析到172.20.14.20），然后我们可以配置IngressRoute规则，Traefik就可以根据IngressRoute规则来将流量路由到对应的服务，并为每个服务提供独立的域名。</p><h5 id="路由实现">路由实现</h5><p>Traefik有两个服务入口（entryPoint）</p><ul><li>80，对应entryPoint:web</li><li>443，对应entryPoint:websecure</li></ul><p>Traefik默认以NodePort形式暴露，对于如下的Traefik来说，它的外部入口就是<code>30350</code>和<code>31971</code>，从<code>30350</code>进入<code>80</code>入口，从<code>31971</code>进入<code>443</code>入口，具体规则可以在<code>values.yaml</code>中修改。</p><p>如果我们不想通过<code>域名:端口</code>（k8s.yiiong.top:30350）,我们可以通过配置Nginx的反向代理，实现直接访问域名到我们对应的服务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME              TYPE       CLUSTER-IP   EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">service/traefik   NodePort   10.96.1.38   &lt;none&gt;        80:30350/TCP,443:31971/TCP   174d</span><br></pre></td></tr></table></figure><p>路由实现</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404182230217.png" alt="image-20240418223033153"></p><h5 id="IngressRoute">IngressRoute</h5><p>Ingress是官方的东西，而IngressRoute则是Traefik Ingress Controller封装好的一种特殊Ingress资源。</p><p><strong>配置一个HTTP的IngressRoute</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: traefik.containo.us/v1alpha1</span><br><span class="line">kind: IngressRoute</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-http</span><br><span class="line">  namespace: lesson-demo</span><br><span class="line">spec:</span><br><span class="line">  entryPoints: # 入口点，入口点是在我们Ingress控制器中定义的入口端口，表示进入该端口的服务才遵循该IngressRoute的路由</span><br><span class="line">  - web</span><br><span class="line">  routes:</span><br><span class="line">  - match: Host(`k8s.yiiong.top`) # 匹配这个域名</span><br><span class="line">    kind: Rule # 路由类型的规则</span><br><span class="line">    services:</span><br><span class="line">    - name: nginx-service # 匹配名为nginx-service的svc</span><br><span class="line">      port: 9376 # 这个svc暴露在9376，二者要相同</span><br></pre></td></tr></table></figure><p>接下来访问<code>http://k8s.yiiong.top:30350</code>即可访问到我们对应的服务。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404202122243.png" alt="image-20240420212251143"></p><p><strong>配置HTTPS的IngressRoute</strong></p><p>我们这里先使用openssl来生成一个自签证书。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out ca.key 4096</span><br><span class="line"> </span><br><span class="line">openssl req -x509 -new -nodes -sha512 -days 36500 \</span><br><span class="line">  -subj &quot;/C=CN/ST=Chongqing/L=Chongqing/O=Redrock/OU=Personal/CN=k8s.yiiong.top&quot; \</span><br><span class="line">  -key ca.key \</span><br><span class="line">  -out ca.crt</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">openssl genrsa -out tls.key 4096</span><br><span class="line"> </span><br><span class="line">openssl req -sha512 -new \</span><br><span class="line"> -subj &quot;/C=CN/ST=Chongqing/L=Chongqing/O=Redrock/OU=Personal/CN=k8s.yiiong.top&quot; \</span><br><span class="line"> -key tls.key \</span><br><span class="line"> -out tls.csr</span><br><span class="line"> </span><br><span class="line">openssl x509 -req -sha512 -days 3650 \</span><br><span class="line">    -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">    -in tls.csr \</span><br><span class="line">    -out tls.crt</span><br></pre></td></tr></table></figure><p>创建证书的<code>Secret</code>（K8s中一种存储和管理敏感数据的资源类型）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create secret -n lesson-demo generic traefik-tls --from-file=tls.crt --from-file=tls.key</span><br></pre></td></tr></table></figure><p>配置Yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: traefik.containo.us/v1alpha1</span><br><span class="line">kind: IngressRoute</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-https</span><br><span class="line">  namespace: lesson-demo</span><br><span class="line">spec:</span><br><span class="line">  # 这里指定https只能走443端口</span><br><span class="line">  entryPoints:</span><br><span class="line">  # 使用websecure作入口</span><br><span class="line">    - websecure</span><br><span class="line">  routes:</span><br><span class="line">    - kind: Rule</span><br><span class="line">      match: Host(`k8s.yiiong.top`)</span><br><span class="line">      services:</span><br><span class="line">        - name: nginx-service</span><br><span class="line">          port: 9376</span><br><span class="line">  # tls相关配置</span><br><span class="line">  tls:</span><br><span class="line">  # 指定证书，是我们前面创建的证书</span><br><span class="line">    secretName: traefik-tls</span><br></pre></td></tr></table></figure><p>接下来访问<code>https://k8s.yiiong.top:31971</code></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404202207503.png" alt="image-20240420220702430"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404202208545.png" alt="image-20240420220839470"></p><p><strong>不在集群里使用HTTPS</strong></p><ul><li>在集群中使用HTTPS太麻烦了，要配这么多东西，有没有什么更好的办法可以把它绕开，然后我们也能使用HTTPS请求呢？</li><li>答案是在集群中配置一个网关机，让这个网关机来控制流量的进入，我们只需要关注流量进入网关后，把tls给卸载掉，最后用http的流量进入我们的集群，这种方案即安全，还方便，不过缺点是只适合在多节点的集群中使用</li></ul><h5 id="中间件middleware">中间件middleware</h5><p>主要用来对HTTP请求做一些修改</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404202214163.webp" alt="img"></p><p><em><strong>HTTP强制跳转HTTPS</strong></em></p><p>实现效果：访问<code>http://k8s.yiiong.top:30350</code>自动跳转至<code>https://k8s.yiiong.top:31971</code></p><p>先<code>apply</code>刚才的HTTPS的IngressRoute。</p><p>然后配置一个中间件</p><p>这里会用到<code>RedirectScheme</code>的内置中间件，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: traefik.containo.us/v1alpha1</span><br><span class="line">kind: Middleware</span><br><span class="line">metadata:</span><br><span class="line">  name: redirect-https-middleware</span><br><span class="line">  namespace: lesson-demo</span><br><span class="line">spec:</span><br><span class="line">  redirectScheme:</span><br><span class="line">    scheme: https</span><br><span class="line">    port: &quot;31971&quot; # 由于我的HTTPS在31971端口，指定一下端口，让其重定向到31971</span><br></pre></td></tr></table></figure><p>然后在HTTP的Yaml文件里最后添加刚刚创建的中间件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">middlewares:</span><br><span class="line">  - name: redirect-https-middleware</span><br></pre></td></tr></table></figure><p>可见HTTP被成功重定向到HTTPS</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404202232356.png" alt="image-20240420223215246"></p><p><em><strong>去除请求前缀</strong></em></p><p>有时候我们只有一个域名，但我们想通过这一个域名访问不同的应用。</p><p>在Nginx中，我们可以配置<code>Location</code>来匹配流量，Traefik也可以这么做。</p><p>但是定制不同的前缀后，由于应用本身并没有这些前缀，导致请求返回<code>404</code>，这时候我们就需要对请求的<code>path</code>进行处理。</p><p>先创建一个带前缀的IngressRoute</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: traefik.containo.us/v1alpha1</span><br><span class="line">kind: IngressRoute</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-http</span><br><span class="line">  namespace: lesson-demo</span><br><span class="line">spec:</span><br><span class="line">  entryPoints:</span><br><span class="line">  - web</span><br><span class="line">  routes:</span><br><span class="line">  - match: Host(`k8s.yiiong.top`) &amp;&amp; PathPrefix(`/nginx`)</span><br><span class="line">    kind: Rule</span><br><span class="line">    services:</span><br><span class="line">    - name: nginx-service</span><br><span class="line">      port: 9376</span><br></pre></td></tr></table></figure><p>直接访问会返回<code>404</code></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404202250871.png" alt="image-20240420225042831"></p><p>配置中间件<code>stripPrefix</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: traefik.containo.us/v1alpha1</span><br><span class="line">kind: Middleware</span><br><span class="line">metadata:</span><br><span class="line">  name: prefix-url-middleware</span><br><span class="line">  namespace: lesson-demo</span><br><span class="line">spec:</span><br><span class="line">  stripPrefix:</span><br><span class="line">    prefixes:</span><br><span class="line">      - /nginx</span><br></pre></td></tr></table></figure><p>修改IngressRoute，使用中间件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">middlewares:</span><br><span class="line">   - name: prefix-url-middleware</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202404202353374.png" alt="image-20240420235338285"></p><p><em><strong>灰度发布</strong></em></p><p>灰度发布我们有时候也会称为金丝雀发布（Canary），主要就是让一部分测试的服务也参与到线上去，经过测试观察看是否符合上线要求。</p><p>假设一个应用现在运行着<code>V1</code>版本，新的<code>V2</code>版本需要上线，这时候我们需要在集群中部署好<code>V2</code>版本，然后通过<code>Traefik</code>提供的<code>带权重的轮询(WRR)</code>来实现该功能。</p><p>这和我们之前讲Nginx带权重的负载均衡很类似。</p><p>需要两个及以上的Service，然后再加一个TraefikService</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: traefik.containo.us/v1alpha1</span><br><span class="line">kind: TraefikService</span><br><span class="line">metadata:</span><br><span class="line">  name: app</span><br><span class="line">spec:</span><br><span class="line">  weighted:</span><br><span class="line">    services:</span><br><span class="line">      - name: appv1 # 服务1</span><br><span class="line">        weight: 3</span><br><span class="line">        port: 80</span><br><span class="line">        kind: Service</span><br><span class="line">      - name: appv2 # 服务2</span><br><span class="line">        weight: 1</span><br><span class="line">        port: 80</span><br><span class="line">        kind: Service</span><br></pre></td></tr></table></figure><p>我们给v1版本配置权重3，给要上线的v2版本配置权重1.也就是说我们3次访问<code>domain.com</code>都会是v1版本，第4次就是v2版本。和我们当时Nginx举的8881和8882的那个例子一模一样。</p><p>创建TraefikService类型后，我们在IngressRoute类型中将service写为traefikService即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: traefik.containo.us/v1alpha1</span><br><span class="line">kind: IngressRoute</span><br><span class="line">metadata:</span><br><span class="line">  name: app-ingressroute-canary </span><br><span class="line">spec:</span><br><span class="line">  entryPoints:</span><br><span class="line">    - web</span><br><span class="line">  routes:</span><br><span class="line">  - match: Host(`domain.com`)</span><br><span class="line">    kind: Rule</span><br><span class="line">    services:</span><br><span class="line">    - name: app</span><br><span class="line">      kind: TraefikService</span><br></pre></td></tr></table></figure><p>待v2版本测试没问题后，就可以将流量全切到v2了。</p><p>Traefik的中间件还有很多，比如Basic Auth（用户身份认证）、ipWhiteList（定义IP白名单）、mirroring（流量复制）等等</p><p>大家可以通过<a href="https://doc.traefik.io/traefik/middlewares/overview/">Traefik Proxy Middleware Overview - Traefik</a>进行学习更多的中间件，甚至可以自行开发自定义中间件。</p><h3 id="总结：服务暴露模式">总结：服务暴露模式</h3><table><thead><tr><th>暴露模式</th><th>访问方式</th></tr></thead><tbody><tr><td>Service (NodePort) + Deployment</td><td>NodeIP:NodePort</td></tr><tr><td>IngressRoute + Service（CluserIP） + Deployment</td><td>域名</td></tr><tr><td>LoadBalancer + Service + Deployment</td><td>负载均衡器IP:PORT</td></tr></tbody></table><p>第二种方式是最常用的，之所以Service被设置成ClusterIP，是因为流量进入集群后直接就由Ingress Controller管理，不再通过kube-proxy管理。我们常常将域名解析到集群主机，然后IngressRoute设置相同的主机名，就能实现流量匹配</p><p>作业：</p><p>1.将第三节课课后作业使用FastAPI开发的Web项目部署在K8s上，并通过**IngressRoute + Service（CluserIP） + Deployment + Middleware（去前缀）**的方式暴露服务。</p><p>2.部署2个以上的服务在K8s上，利用IngressRoute用域名区分访问。</p><p>最终将服务地址（要求能访问到）和整个部署流程记录文档提交到<strong>yiiong@redrock.team</strong></p><p>截止时间<strong>5月5日</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计算机网络（第七版）谢希仁</p></blockquote><h2 id="1-概述">1.概述</h2><p>互联网的两个基本特点：<strong>连通性</strong>和<strong>共享</strong></p><h3 id="互联网概述">互联网概述</h3><p>计算机网络又若干**节点（node）<strong>和连接这些节点的</strong>链路(link)**组成。</p><p>网络之间可以通过路由器互连起来，这样的网络成为<strong>互连网（internetwork）</strong>，互连网是“网络的网络”（network of networks）</p><p>网络把许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。与网络相连的计算机称为主机。</p><p><strong>互连网与互联网的区别：</strong></p><p>互连网（internet）是一个通用名词，泛指多个计算机网络互连而成的计算机网络。这些网络之间的通信规则可以任意选择，不一定非要使用TCP/IP协议</p><p>互联网（Internet）是一个专有名词，指的是当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用TCP/IP协议族作为通信的规则，且其前身是美国的ARPANET(一个单个的分组交换网)</p><p>第一阶段：从单个网络ARPANET向互联网发展的过程</p><p>第二阶段：建成了<strong>三级结构的互联网</strong>，分为主干网、地区网、校园网（或企业网）</p><p>第三阶段：形成了多层次的ISP结构的网络</p><p>ISP（Internet Service Provider）：互连网服务提供者，例如中国电信、中国联通等</p><p>所谓“上网”就是指“（通过某ISP获得的IP地址）接入到互联网“</p><p>互联网交换点IXP（Internet eXchange Point）：允许两个网络直接相连并交换分组，而不需要通过第三个网络来转发分组。</p><p>典型的IXP由一个或多个网络交换机组成，许多ISP再连接到这些网络交换机的相关端口上。</p><p>IXP常采用工作在数据链路层的网络交换机，这些网络交换机都用局域网互连起来。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312122030927.png" alt="img"></p><h3 id="互联网的组成">互联网的组成</h3><p>从工作方式，分为两大块：</p><ol><li><strong>边缘部分</strong>：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传输数据、音频或视频）和资源共享</li><li><strong>核心部分</strong>：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的。</li></ol><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312122030702.png" alt="image-20231212203022616"></p><h4 id="边缘部分">边缘部分</h4><p>处在互联网边缘的部分就是<strong>连接在互联网上的所有主机</strong>。这些主机又称为<strong>端系统（end system）</strong></p><p>主机A 与 主机B进行通信指的是”主机A的某个进程和主机B上的另一个进程进行通信“，简称<strong>计算机之间的通信</strong></p><p>计算机通信的对象是应用层中的应用进程</p><p>在网络边缘的端系统之间的通信方式通常分为两大类：</p><ol><li>客户-服务器方式（C/S方式）</li><li>对等方式（p2p方式）</li></ol><p><strong>客户-服务器方式</strong></p><p>在互联网最常用，最传统的方式</p><p>客户（client）和服务器（server）是指通信中所涉及的两个<strong>应用进程</strong>，客户是服务请求方，服务器是服务提供方</p><p>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312122047344.png" alt="image-20231212204740251"></p><p>客户程序的特点：</p><ol><li>被用户调用后运行，在通信时主动向原地服务器发起通信</li><li>不需要特殊的硬件和很复杂的操作系统</li></ol><p>服务器程序的特点：</p><ol><li>是一种专门用来提供某种服务的程序，<strong>可同时处理多个远地或本地客户的请求</strong></li><li>系统启动后即可自动调用并一直不断地运行，被动地等待并接受来自各地的客户的通信请求</li><li>一般需要有强大的硬件和高级的操作系统支持</li></ol><p>如上的客户和服务器本来都指的是计算机进程（软件）</p><p>在表示机器时，我们也使用”客户端“（或客户机）”服务端“（服务机）来表示”运行客户（服务器）程序的机器“</p><p><strong>对等连接方式</strong></p><p>对等连接（peer-to-peer），简写为p2p，是指两台主机在通信时并不区分哪一个时服务请求方哪一个是服务提供方。只要两台机器都运行了对等连接软件，他们就可以进行平等的、对等连接通信。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312122117656.png" alt="image-20231212211703575"></p><h4 id="核心部分">核心部分</h4><p>在网络核心部分起特殊作用的是<strong>路由器（router）</strong>，它是一种专用计算机。路由器是实现<strong>分组交换（packet switching）<strong>关键，其任务是</strong>转发收到的分组</strong></p><ol><li>电路交换的主要特点：</li></ol><p>从通信资源分配的角度，**交换（switching）**就是按照某种方式动态分配传输线路的资源</p><p>电路交换：建立连接（占用通信资源）—通话（一直占用通信资源）—释放连接（归还通信资源）</p><p>重要特点：在通话的全部时间内，通话的两个用户始终占用端对端的通信资源</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312122127083.png" alt="image-20231212212749045"></p><p>2.分组交换的特点</p><p>分组交换采用存储转发技术</p><ul><li>报文（message）：要发送的整块数据</li><li>首部（header）：发送报文之前把较长的报文分为一个个更小的等长数据段，每个数据段前加上一些必要的控制信息</li><li>分组（packet）：分组又称为包，由首部和数据段组成，分组的首部也可以称为”包头“。</li></ul><p>分组是在互联网中传送的数据单元。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312122225186.png" alt="image-20231212222517102"></p><p>位于网络边缘的主机是<strong>为用户进行信息处理的</strong>，并且可以和其他主机通过网络交换信息</p><p>位于网络核心的路由器则是用来<strong>转发分组的，及进行分组交换的</strong>。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312122229008.png" alt="image-20231212222922924"></p><p>当讨论互联网的核心部分中的路由器转发分组的过程时，往往把单个的网络简化成一条<strong>链路</strong>，而路由器成为核心部分的<strong>结点</strong></p><p>互联网的核心部分通常采用网络拓扑结构</p><p>分组交换的优点：高效、灵活、迅速、可靠</p><p>缺点：</p><ol><li>时延：各路由器存储转发时需要排队</li><li>开销（overhead）：各分组必须携带控制信息</li></ol><p>数据传送的主要特点：</p><ul><li>电路交换：整个报文的比特流连接地从源点直达终点</li><li>报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点</li><li>分组交换：单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312162028929.png" alt="image-20231216202829818"></p><h3 id="计算机网络的类别">计算机网络的类别</h3><h4 id="计算机网络的定义">计算机网络的定义</h4><p>计算机网络主要是由一些通用的、可编程的硬件互连而成，这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛和日益增长的应用</p><h4 id="计算机网络的类别-v2">计算机网络的类别</h4><ol><li><p>按网络的作用范围进行分类</p><ul><li>广域网WAN（Wide Area Network）：有时被称为远程网。互联网的核心，其任务是通过长距离运送主机所发送的数据。</li><li>城域网MAN（Metropolitan Area Network）：用来互连多个局域网</li><li>局域网LAN（Local Area Network）</li><li>个人局域网PAN（Personal Area Network）</li><li>若中央处理机之间的距离非常近，则一般称其为多处理机系统</li></ul></li><li><p>按网络的使用者进行分类</p><ul><li>公用网（public network）：指电信公司主出资建造的大型网络。又称为公众网</li><li>专用网（private network）：满足本单位的特殊业务工作的需要而建造的网络</li></ul></li><li><p>用来把用户接入到互联网的网络</p><p>接入网AN（Access Network）：又称本地接入网或居民接入网</p></li></ol><h3 id="计算机网络的性能">计算机网络的性能</h3><h4 id="计算机网络的性能指标">计算机网络的性能指标</h4><ol><li><p>速率</p><p>比特：代表一个“二进制数字”。网络技术中的速率指的是数据的传送速率，也称为<strong>数据率</strong>或<strong>比特率</strong>，单位是bit/s。当提到网络的速率时，往往指的是额定速率或标称速率</p></li><li><p>带宽（bandwid）</p><ol><li><p>带宽本来指某个<strong>信号具有的频率带宽</strong>。信号的带宽是指该<strong>信号所包含的各种不同频率成分所占据的频率范围。</strong></p><p>表示某信道允许通过的信号频率范围就成为该信道的带宽（或通频带）</p></li></ol><p>单位赫（或千赫、兆赫）</p><ol start="2"><li>在计算机网络中，带宽用来<strong>表示网络中某通道传送数据的能力</strong></li></ol></li></ol><p>​<strong>表示单位时间内网络中的某信道所能通过的“最高数据率”</strong></p><p>​单位是数据率的单位bit/s</p><p>3.吞吐量（throughput）</p><p>​表示单位时间内通过某个网络（或信道、接口）的实际的数据量。吞吐量受网络的带宽或网络的额定频率的限制</p><p>4.时延（delay）</p><p>​指数据（一个报文或分组、甚至比特）从网络（或链路）的一端传送到另一端所需的时间</p><p>​有时也被称为<strong>延迟</strong>或<strong>迟延</strong></p><p>​1.发送时延（transmission delay）是主机或路由器发送数据帧所需要的时间。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312162139641.png" alt="image-20231216213939579"></p><p>​2.传播时延（propagation delay）是电磁波在信道中传播一定的距离需要花费的时间</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312162141297.png" alt="image-20231216214116217"></p><p>​3.处理时延：主机或路由器在收到分组时要花费一定的时间进行处理</p><p>​4.排队时延：分组进入路由器后要现在输入队列中排队等待处理。在路由器确定了转发接口后，还有在输入队列中排队等待转发。</p><p>​**总时延为四种时延的和 **</p><p>​不能笼统地认为“数据的发送速率越高，其传送的总时延越小”，因为总时延是由四个时延决定的</p><p>​对于告诉网络链路，我们提高的仅仅是数据的发送速率而非比特在链路上的传播速率</p><p>​提高数据的发送速率知识减小了数据的发送时延</p><p>​数据的发送速率的单位是每秒发送了多少个比特，这是指在某个点或某个接口上的发送速率。而传播速率的单位是每秒传播多少公里，是指在某一段传输线路上比特的传播速率</p><p>5.时延带宽积=传播时延*带宽</p><p>6.往返时间RTT</p><p>7.利用率</p><p>非性能特征：费用、质量、标准化、可靠性、可扩展性和可升级性、易于管理和维护</p><h3 id="计算机网络体系结构">计算机网络体系结构</h3><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312162214502.png" alt="image-20231216221452377"></p><p>分层：可以将庞大的问题转化为小的问题</p><p><strong>开放系统互连基本参考模型OSI/RM(Open Interconnection Reference Model)</strong></p><p>简称OSI</p><h4 id="协议与划分层次">协议与划分层次</h4><p>网络协议（network protocol）：为进行网络中的数据交换而建立的规则、标准或约定</p><p>三要素：</p><ul><li>语法：即数据与控制信息的结构或格式</li><li>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：即事件实现顺序的详细说明</li></ul><p>分层的好处：</p><ol><li>各层之间是独立的</li><li>灵活性好</li><li>结构上可以分割开</li><li>易于实现和维护</li><li>能促进标准化工作</li></ol><p>各层应该要实现的功能：</p><ol><li>差错控制</li><li>流量控制</li><li>分段和重装</li><li>复用和分用</li><li>连接建立和释放</li></ol><p>体系结构：计算机网络的各层及其协议的集合，就是这个计算机网络及其构建所应完成的功能的精确定义</p><h4 id="具有五层结构的体系结构">具有五层结构的体系结构</h4><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312162227929.png" alt="image-20231216222732795"></p><ol><li><p><strong>应用层（application layer）</strong></p><p>体系中的最高层</p><p>任务是<strong>通过应用进程间的交互来完成特定网络应用</strong></p><p>应用层协议定义是<strong>应用进程间通信和交互的规则</strong></p><p><strong>网络上的应用层协议举例：域名系统DNS，支持万维网应用的HTTP协议、SMTP</strong><br>我们把应用层交互的数据单元称为报文（message）</p></li><li><p><strong>运输层（transport layer）</strong></p><p>负责向两台主机中进程之间的通信提供通用的数据传输服务。</p><p>应用层具有复用和分用的功能<br>复用是多个应用层进程可以同时使用下面运输层的服务，分用时运输层把收到的信息分别交付上面应用层中的相应进程</p><p>主要协议：</p><ul><li><strong>传输控制协议TCP（Transmission Control Protocol）</strong><br>提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段（segement）</strong></li><li><strong>用户数据报协议UDP（User Datagram Protocol）</strong><br>提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是<strong>用户数据报</strong></li></ul></li><li><p><strong>网络层（network layer）</strong></p><p>负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送<br>分组又叫IP数据报<br>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来。互联网使用的网络协议时无连接的<strong>网际IP和许多中路由选择协议</strong></p></li><li><p><strong>数据链路层（data link layer）</strong></p><p>数据链路层将网络层交下来的IP数据报组装成帧(framiing)，在两个相邻结点间链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）</p></li><li><p><strong>物理层（physcial layer）</strong></p><p>在物理层上传输的数据单位是比特。</p><p>物理层要考虑用多大的电压代表1或0，以及接收方如何识别发送的比特<br>还要确定连接电缆的插头应当有多少根引脚以及各引脚如何连接</p></li></ol><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312162256945.png" alt="image-20231216225611789"></p><p>​比喻：有一封信从最高层向下传送。每经过一层就包上一个新的信封，协商必要的地址信息。包有多个信封的信件传送到目的站后，从第一层其，每层拆开一个信封后就把信封中的信件交给他的上一层。传到最高层后，取出发信人所发的信交给收信人。</p><p>​OSI参考模型把对等层次之间传送的数据称为该层的<strong>协议数据单元PDU</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312182016383.png" alt="20231218201628"></p><p>​        我们以前经常提到的各层协议，实际上就是各个对等层之间传递数据时的各项规定。</p><p>​几个层次画在一起很像一个栈（stack）的结构，称为<strong>协议栈（peer layers）</strong></p><p><strong>实体（entity）：表示任何可发送或接收信息的硬件或软件进程</strong></p><p><strong>协议是控制两个对等实体（或多个实体）进行通信的规则的集合</strong></p><ul><li>语法方面的规则定义了所交换的信息的格式</li><li>语义方面的规则定义了发送者或接收者所要求的操作</li></ul><p>在协议的控制下两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</p><p><strong>协议与服务的区别</strong></p><ul><li>协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议</li><li>协议是“水平的”，即协议是控制对等实体之间通信的规则</li><li>服务是“垂直的”，即服务是由下层向上层通过层间接口提供的</li><li>只有那些能被高一层实体“看得见”的功能才能称为服务</li></ul><p>上层使用下层所提供的服务必须通过与下一层交换一些命令，这些命令在OSI中称为服务原语</p><p>在同一实体中相邻两层实体进行交互的地方，通常称为<strong>服务访问点SAP（Service Access Point）</strong>。它实际上就是一个逻辑接口。</p><p>OSI把层与层之间交换的数据的单位称为<strong>服务数据单元SDU（Service Data Unit）</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312182039790.png" alt="image-20231218203921704"></p><p>第n层向上面的第n+1层所提供的服务实际上已经包括了在它一下各层所提供的服务</p><p><strong>计算机网络的协议还有一个重要的特点：必须把所有不利的条件事先都估计到，而不能假定一切都是正常和的非常理想的。</strong></p><p>因此检查一台计算机网络协议是否正常，必须要非常仔细地检查这个协议是否能应付各种异常情况</p><h4 id="TCP-IP的体系结构">TCP/IP的体系结构</h4><p>路由器在转发分组时最高只用到网络层而没有使用运输层和应用层。</p><p>表示：</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312182051491.png" alt="image-20231218205141383"></p><p>数据链路层也就是属于网络接口层</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312182052249.png" alt="image-20231218205200169"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312182052294.png" alt="image-20231218205208209"></p><p>TCP/IP可以为各式各样的应用提供服务，TCP/IP允许IP协议在各式各样的网络构成的互联网上运行</p><h3 id="本章重要概念">本章重要概念</h3><ul><li>计算机网络把许多计算机连接起来，而互联网把许多网络连接在一起，是网络的网络</li><li>internet（互连网）泛指多个计算机网络互连而成的网络。网络之间的通信协议可以是任意的</li><li>Internet（互连网）指当前全球最大的、开放的、有众多网络连接而成的特定互连网，使用TCP/IP协议族为通信规则</li><li>互联网现在采用存储转发的分组交换技术，以及三层ISP结构</li><li>互联网按工作方式可以划分为边缘部分与核心部分，主机在网络的边缘部分，其作用是进行信息处理。路由器位于网络的核心部分，作用是按存储转发方式进行分组交换</li><li>计算机通信是计算机中的进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式和对等连接方式</li><li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方</li><li>按作用范围的不同，计算机网络分为广域网WAN、城域网MAN、局域网LAN和个人区域网PAN</li><li>计算机网络最常用的性能指标是：速率、带宽、吞吐量、时延、时延带宽积、往返时间和信道（或网络）利用率</li><li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构</li><li>五层协议的体系结构由应用层、运输层、网络层（网际层）、数据链路层和物理层组成。运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议</li></ul><h2 id="2-物理层">2.物理层</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312182231922.png" alt="image-20231218223159796"><img src="https://gitee.com/beatrueman/images/raw/master/img/202312182232598.png" alt="image-20231218223212419"></p><h2 id="3-数据链路层">3.数据链路层</h2><p>信道：一般都是用来表示向某一个方向传送信息的媒体</p><p>点对点信道。采用一对一的点对点通信方式</p><p>广播信道。这种信道使用一对多的广播通信方式</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312182232633.png" alt="image-20231218223234504"></p><h3 id="使用点对点信道的数据链路层">使用点对点信道的数据链路层</h3><h4 id="数据链路和帧">数据链路和帧</h4><p>链路（link）：一个结点到相邻结点的一段物理线路（有线或无线），而中间没有任何其他的交换节点</p><p>数据链路（data link）：数据传输时，除了必须要有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输</p><p>把这些协议的硬件和软件加到链路上，就构成了数据链路</p><p>最常用的方法是使用网络适配器来实现这些协议。一般的适配器都包括数据链路层和物理层的功能</p><p><strong>数据链路层的协议数据单元-帧</strong></p><p>数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。网络层协议数据单元就是IP数据报（或简称数据报、分组或包）</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312211936567.png" alt="image-20231221193604370"></p><h4 id="三个基本问题">三个基本问题</h4><p><strong>封装成帧、透明传输和差错检测</strong></p><ul><li><strong>封装成帧</strong>：就是把一段数据的前后分别添加首部和尾部，这样就构成了一个帧。由分组交换可知：所有在互联网上传送的数据都以分组（即IP数据报）为传送单位，网络层的IP数据报传送到数据链路层就成为帧的数据部分。<br>一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。<br>首部和尾部的一个重要作用就是进行帧定界<br>为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种数据链路层协议都规定了所能传送的帧的数据部分长度上限-最大传送单元MTU（Maximum Transfer Unit）</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312211952593.png" alt="image-20231221195241484"></p><p>​当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的帧定界符。控制字符SOH（Start Of Header）放在一帧的最前面，表示帧的首部开始。另一个控制字符EOT（End Of Transmission）表示帧的结束。SOH和EOT都是控制字符的名称。他们的十六进制编码分别是01和04</p><ul><li><p><strong>透明传输</strong>：当传送的帧是用文本文件组成的帧时，其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。</p><p><strong>透明</strong>表示某一个实际存在的事物看起来却好像不存在一样<br>在数据链路层透明传送数据表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。因此对所传送地数据来说，这些数据就看不见数据链路层有什么妨碍数据传输的东西。</p><p>为了解决透明传输问题。就必须设法使数据中可能出现的控制字符SOH和EOT在接收端不被解释为控制字符。发送端的数据链路层在数据中出现控制字符SOH和EOT的前面插入一个转义字符ESC（十六进制1B，二进制00011011）。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为<strong>字节填充</strong></p></li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312212043160.png" alt="image-20231221204301038"></p><ul><li><p><strong>差错检测</strong><br>比特差错：比特在传输过程中1可能会变成0，0可能会变成1<br>误码率BER：一段时间内，传输错误的比特占所传输比特总数的比率<br>使用<strong>循环冗余检验CRC</strong>的检错技术：在数据M的后面添加提供差错检测用的n位冗余码，这种为了进行检错而添加的冗余码常称为<strong>帧检验序列FCS</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312212120032.png" alt="image-20231221212048983"></p><p>传输差错：比特差错、帧丢失、帧重复或帧失序</p></li></ul><h3 id="点对点协议PPP">点对点协议PPP</h3><h4 id="PPP协议的特点">PPP协议的特点</h4><p>PPP（Point-to-Point Protocol）协议是计算机和ISP进行通信时所使用的数据链路层协议</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312212121018.png" alt="image-20231221212101914"></p><ul><li>PPP协议应满足的需求</li></ul><ol><li>简单：接收方每接收一个帧，就进行CRC检验，如果正确就接受，不正确就丢弃。其他什么也不做</li><li>封装成帧</li><li>透明性</li><li>多层网络协议：PPP协议必须能够在同一条物理链路上同时支持多种网络层协议</li><li>多种类型链路：串行（一次发一个bit）的或并行的、同步的或异步的、低速的或高速的、电的或光的、交换的或非交换的</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元：最大传送单元MTU是帧可以载荷的数据部分的最大长度而不是帧的总长度</li><li>网络层地址协商</li><li>数据压缩协商</li></ol><p>PPP协议不需要进行纠错，不需要设置序号，不需要进行流量控制。不支持多点线路（即一个主站轮流和链路上的多个从站进行通信），而只支持点对点的链路通信。只至此全双工链路</p><p>**PPPoE（PPP over Ethernet）**是为宽带上网的主机使用的链路层协议。这个协议把PPP帧再封装到以太网帧中。</p><ul><li>PPP协议的组成<ol><li>一个将IP数据报封装到串行链路的方法。PPP既支持异步链路（无奇偶检验的8比特数据），也支持面向比特的同步链路。IP数据报在PPP帧中就是其信息部分。这个信息部分的长度受MTU的限制</li><li>一个用来建立、配置和测试数据链路连接的链路控制协议LCP（Link Control Protocol）</li><li>一套网络控制协议NCP（Network Control Protocol），其中的每一个协议支持不同的网络层协议</li></ol></li></ul><h4 id="PPP协议的帧格式">PPP协议的帧格式</h4><ol><li><p>各个字段的意义</p><p>PPP帧的首部和尾部分别为四个字段和两个字段</p><p>首部的第一个字段和尾部的第二个字段都是标志字段F（Flag），规定为0x7E，标志字段就是PPP帧的定界符。如果连续出现两个F，表示这是一个空帧，应当丢弃</p><p>协议部分</p><ul><li>当为0x0021时为IP数据报</li><li>0xc021为LCP的数据</li><li>0x8021为网络层的控制数据</li></ul><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312212159310.png" alt="image-20231221215954202"></p></li></ol><p>2.字节填充</p><p>3.零比特填充</p><h4 id="※PPP协议的工作状态">※PPP协议的工作状态</h4><p>流程</p><p>在这种情况下，拨号是指使用电话线或调制解调器通过拨打ISP（互联网服务提供商）的号码来建立连接。这种连接方式被称为拨号接入，它是一种电路交换技术，电话线路建立一个临时的点对点连接。</p><p><strong>当用户拨号接入ISP后，就建立了一条从用户个人电脑到ISP的物理连接。这时，用户个人电脑向ISP发送一系列的链路控制协议LCP分组（封装成多个PPP帧），以便建立LCP连接。这些分组及其响应选择了将要使用的一些PPP参数。</strong></p><p><strong>接着还要进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一个临时的IP地址。这样用户个人电脑就成为互联网上的一个有IP地址的主机</strong></p><p><strong>当用户通信完毕后，NCP释放网络层连接，收回原来分配出去的IP地址。接着LCP释放数据链路层的连接，最后释放物理层的连接</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202312252124404.png" alt="image-20231225212458278"></p><ol><li><p>PPP协议的起始和终止状态始终是<strong>链路静止（Link Dead）</strong></p></li><li><p>当用户个人电脑通过或调制解调器呼叫路由器时，路由器就能够检测调制解调器发出的载波信号。建立物理层连接后，PPP就进入<strong>链路建立（Link Establish）</strong>，目的是为了建立链路层的LCP连接</p></li><li><p>接下来LCP开始协商一些配置选项，即发送LCP的<strong>配置请求帧（Configure-Request）</strong></p><ul><li><p>配置确认帧</p></li><li><p>配置否定帧</p></li><li><p>配置拒绝帧</p><p>配置选项包括</p><ul><li>链路上的最大帧长</li><li>所使用的**鉴别协议（authentication protocol）**的规约</li><li>不使用PPP帧中的地址和控制字段（固定无信息量即可省略）</li></ul></li></ul><p>4.结束后建立LCP链路，接着进入**”鉴别“**，这一状态下只允许传送LCP协议的分组、鉴别协议的分组以及检测链路质量的分组</p></li></ol><ul><li>口令鉴别协议PAP：需要发起通信的一方发送身份标识符和口令</li><li>口令握手鉴别协议CHAP</li></ul><p>5.若鉴别身份失败，则转入<strong>链路中止</strong>。鉴别成功后，进入<strong>网络层协议</strong></p><p>6.在网络层协议状态， PPP两端的NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。意思是PPP协议两端的网络层可以运行不同的网络层协议，但仍然可以使用同一份PPP协议进行通信</p><p>如果PPP运行IP协议，则对PPP的每一端配置IP协议模块时就要使用NCP中支持IP的协议-<strong>IP控制协议</strong>。IPCP分组也封装成PPP帧在PPP链路上传送</p><p>7.网络层配置完毕后，链路就进入可进行数据通信的<strong>链路打开</strong>状态。链路的两个PPP端点可以彼此向对方发送分组。PPP端点之间可以发送<strong>回送请求LCP分组</strong>和回送回答LCP分组，用来检查链路的状态</p><p>8.数据传输结束后，可以由链路的一段发出<strong>终止请求LCP分组</strong>请求终止链路连接，在收到对方发来的终止确认LCP分组，转到”链路终止“</p><p>如果链路故障，也会从链路打开转到链路终止，调制解调器载波停止后，则会链路静止</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构练习记录</title>
      <link href="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/"/>
      <url>/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Q1">Q1</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411062347086.jpg" alt="IMG_20241106_234634"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411062348173.jpg" alt="IMG_20241106_234640"></p><h2 id="Q2-1">Q2.1</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410150005291.jpeg" alt="d13ba04bc05f597a991a9af08b26920a"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *elem;</span><br><span class="line">    int length; // 当前长度</span><br><span class="line">    int listsize; // 当前分配的存储空间</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line">// 初始化顺序表</span><br><span class="line">int initList(SqList *L, int listsize)</span><br><span class="line">&#123;</span><br><span class="line">    L-&gt;elem = (int *)malloc(sizeof(int) * listsize);</span><br><span class="line">    if(!L-&gt;elem)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length = 0;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 有序插入</span><br><span class="line">void OrderedList_Insert(SqList *L, int x)</span><br><span class="line">&#123;</span><br><span class="line">    // 寻找x的前一个元素和后一个元素</span><br><span class="line">    //int prior = 0, next = 0, pos;</span><br><span class="line">    //for(int i = 0; i &lt; L-&gt;listsize; i++) &#123;</span><br><span class="line">    //    if(x &gt; L-&gt;elem[i]) &#123;</span><br><span class="line">    //       prior = L-&gt;elem[i];</span><br><span class="line">    //       next = L-&gt;elem[i+1];</span><br><span class="line">    //       pos = i + 1;</span><br><span class="line">    //    &#125;</span><br><span class="line">    //&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //printf(&quot;前%d，后%d，位置是 %d\n&quot;,prior, next, pos);</span><br><span class="line"></span><br><span class="line">    // 寻找插入位置</span><br><span class="line">    int pos;</span><br><span class="line">    for(pos = 0; pos &lt; L-&gt;length; pos++) &#123;</span><br><span class="line">        if(x &lt;= L-&gt;elem[pos]) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入</span><br><span class="line">    for(int j = L-&gt;length; j &gt;= pos; j--) &#123;</span><br><span class="line">        L-&gt;elem[j+1] = L-&gt;elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;elem[pos] = x;</span><br><span class="line">    ++L-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化顺序表</span><br><span class="line">    SqList L;</span><br><span class="line">    printf(&quot;请设置表长：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;L.listsize);</span><br><span class="line">    int result = initList(&amp;L, L.listsize);</span><br><span class="line">    if (result == -1) &#123;</span><br><span class="line">        printf(&quot;初始化失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;初始化成功！\n&quot;);</span><br><span class="line">        printf(&quot;当前分配的存储容量为：%d\n&quot;, L.listsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 顺序表赋值</span><br><span class="line">    for(int i = 0; i &lt; L.listsize; i++) &#123;</span><br><span class="line">        if (L.length &lt; L.listsize) &#123;</span><br><span class="line">                L.elem[i] = i * 2;</span><br><span class="line">                ++L.length;</span><br><span class="line">                printf(&quot;%d &quot;, L.elem[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;超出分配空间，无法向顺序表中赋值！&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int x;</span><br><span class="line">    printf(&quot;\n请插入元素:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    OrderedList_Insert(&amp;L, x);</span><br><span class="line">    printf(&quot;插入后顺序表为:&quot;);</span><br><span class="line">    for(int j = 0; j &lt; L.length; j++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;,L.elem[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清理内存</span><br><span class="line">    free(L.elem);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Q2-2">Q2.2</h2><p>题目</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410240002287.jpeg" alt="7b59c5e18da5eda1f30db6f2c8c4f1f1"></p><p>OrderedList(LinkList L, int min, int max)的时间复杂度：</p><p>最好：整个链表没有大于min小于max的结点，遍历链表一次。即O(n)</p><p>最坏：所有节点都需要删除，遍历链表一次。即O(n)</p><p>平均：O(n)</p><p>n为链表长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define ERROR -1</span><br><span class="line"></span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList InitList()</span><br><span class="line">&#123;</span><br><span class="line">    LinkList L = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">    if(L == NULL) &#123;</span><br><span class="line">        printf(&quot;链表初始化失败！\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = NULL;</span><br><span class="line">    printf(&quot;链表初始化成功！\n&quot;);</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 后插法</span><br><span class="line">int CreateList_R(LinkList *L, int n)</span><br><span class="line">&#123;</span><br><span class="line">    *L = InitList();</span><br><span class="line">    LinkList r = *L;</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkList p = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除表中所有大于min小于max的结点</span><br><span class="line">void OrderedList(LinkList *L, int min, int max)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    LinkList pre = NULL; // 跟踪前一个结点</span><br><span class="line">    int flag = 0;</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        // 找所有大于min小于max的结点</span><br><span class="line">        if(p-&gt;data &gt; min &amp;&amp; p-&gt;data &lt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            LinkList q = p;</span><br><span class="line">            if(pre == NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                *L = p-&gt;next; // 如果删除的是头结点，更新头指针</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = p-&gt;next; // 跳过当前结点</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            free(q);</span><br><span class="line">            flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(!flag)</span><br><span class="line">        printf(&quot;没有大于min且小于max的结点，没有删除任何元素！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出链表</span><br><span class="line">void PrintList(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d -&gt;&quot;, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;NULL\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LinkList list;</span><br><span class="line">    int n;</span><br><span class="line">    printf(&quot;请输入链表长度：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    if(n &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;链表长度必须大于0&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int result = CreateList_R(&amp;list, n);</span><br><span class="line">    if(result == 0) &#123;</span><br><span class="line">        printf(&quot;创建链表成功！\n&quot;);</span><br><span class="line">        int max, min;</span><br><span class="line">        printf(&quot;请输入最大值与最小值(空格分隔)：&quot;);</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;max, &amp;min);</span><br><span class="line">        printf(&quot;原链表：\n&quot;);</span><br><span class="line">        PrintList(list);</span><br><span class="line">        printf(&quot;正在删除表中所有大于min小于max的结点\n&quot;);</span><br><span class="line">        OrderedList(&amp;list, min, max);</span><br><span class="line">        PrintList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;创建链表失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410240001043.png" alt="image-20241024000137983"></p><h2 id="Q3-1">Q3.1</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410271456948.png" alt="image-20241027145604833"></p><p>栈特点：先入后出，后入先出</p><p><img src="../AppData/Roaming/Typora/typora-user-images/image-20241027150821174.png" alt="image-20241027150821174"></p><h2 id="Q3-2">Q3.2</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411052342458.png" alt="1EDD8C92D0005790DB415ED2C4B514B2"></p><h2 id="Q3-3">Q3.3</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410271506714.jpg" alt="1730012083214"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define ERROR -1</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    char *base;</span><br><span class="line">    char *top;</span><br><span class="line">    int stacksize;</span><br><span class="line">&#125;SqStack, *Stack;</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">Stack InitStack()</span><br><span class="line">&#123;</span><br><span class="line">    // 给栈这个结构分配内存，也就是实现一个栈的结构框架</span><br><span class="line">    Stack s = (Stack)malloc(sizeof(SqStack));</span><br><span class="line">    if(s == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈内存分配失败！\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 给栈的实际数据分配空间</span><br><span class="line">    s-&gt;base = (char *)malloc(MAXSIZE * sizeof(char));</span><br><span class="line">    if(s-&gt;base == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        free(s);</span><br><span class="line">        printf(&quot;栈内存分配失败！\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;top = s-&gt;base;</span><br><span class="line">    s-&gt;stacksize = MAXSIZE;</span><br><span class="line">    printf(&quot;栈初始化成功！\n&quot;);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入栈</span><br><span class="line">int Push(Stack s, char e)</span><br><span class="line">&#123;</span><br><span class="line">    if(s-&gt;top - s-&gt;base == s-&gt;stacksize) &#123;</span><br><span class="line">        printf(&quot;栈满！\n&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *s-&gt;top = e;</span><br><span class="line">    s-&gt;top++;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">int Pop(Stack s, char *e)</span><br><span class="line">&#123;</span><br><span class="line">    if(s-&gt;top == s-&gt;base)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈空！\n&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;top--;</span><br><span class="line">    *e = *s-&gt;top;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 清空栈</span><br><span class="line">void DestroyStack(Stack s)</span><br><span class="line">&#123;</span><br><span class="line">    if(s != NULL) &#123;</span><br><span class="line">        free(s-&gt;base);</span><br><span class="line">        s-&gt;base = NULL;</span><br><span class="line">        s-&gt;top = NULL;</span><br><span class="line">        s-&gt;stacksize = 0;</span><br><span class="line">        free(s);</span><br><span class="line">        printf(&quot;栈已销毁!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取栈顶元素</span><br><span class="line">char GetTop(Stack s)</span><br><span class="line">&#123;</span><br><span class="line">    if(s-&gt;top != s-&gt;base) &#123;</span><br><span class="line">        return *(s-&gt;top - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断栈是否为空</span><br><span class="line">int StackEmpty(Stack s)</span><br><span class="line">&#123;</span><br><span class="line">    return s-&gt;top == s-&gt;base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Symmetry(char a[])</span><br><span class="line">&#123;</span><br><span class="line">    Stack s = InitStack();</span><br><span class="line">    int flag = 1; // 标记匹配结果以及控制循环</span><br><span class="line">    int length = strlen(a);</span><br><span class="line">    int mid = -1; // 记录&amp;位置</span><br><span class="line"></span><br><span class="line">    // 检查字符串是否以@结尾</span><br><span class="line">    if(a[length - 1] != &#x27;@&#x27;) &#123;</span><br><span class="line">        printf(&quot;字符序列没有以 @ 结尾，请重新输入！\n&quot;);</span><br><span class="line">        flag = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历字符串，找到&amp;后，将其前半部分压入栈中</span><br><span class="line">    for(int i = 0; i &lt; length - 1 &amp;&amp; flag; i++) &#123;</span><br><span class="line">        if(a[i] == &#x27;&amp;&#x27;) &#123;</span><br><span class="line">            if(mid == -1) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                printf(&quot;只能有一个 &amp; 出现！\n&quot;);</span><br><span class="line">                flag = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有遇到&amp;，入栈</span><br><span class="line">        else if(mid == -1) &#123;</span><br><span class="line">            Push(s, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查对称， &amp; 后的字符是否和栈内的元素匹配</span><br><span class="line">    if(flag) &#123;</span><br><span class="line">        for(int i = mid + 1; i &lt; length - 1; i++) &#123;</span><br><span class="line">            char topElem = GetTop(s);</span><br><span class="line">            if(topElem == a[i]) &#123;</span><br><span class="line">                Pop(s, &amp;topElem); // 匹配成功后出栈</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                flag = 0; // 如果不匹配，退出循环</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DestroyStack(s);</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char a[MAXSIZE];</span><br><span class="line">    printf(&quot;请输入一个以@结尾的字符序列：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, a);</span><br><span class="line">    if(Symmetry(a)) &#123;</span><br><span class="line">        printf(&quot;字符序列是对称的！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;字符序列不对称！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410280033465.png" alt="image-20241028003318402"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410280033567.png" alt="image-20241028003337536"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410280033275.png" alt="image-20241028003354234"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410280034041.png" alt="image-20241028003431009"></p><h2 id="Q3-4">Q3.4</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411012305868.jpeg" alt="dc928775388115a25212b2773e4c0b40"></p><p>当<em><strong>front = rear &amp;&amp; flag = 0</strong></em>为队空<br>当<em><strong>front = rear &amp;&amp; flag = 1</strong></em>为队满</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MaxQSize 5</span><br><span class="line">#define ERROR -1</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *base;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">    int flag;</span><br><span class="line">&#125;SqQueue, *Queue;</span><br><span class="line"></span><br><span class="line">// 当front = rear &amp;&amp; flag = 0为队空</span><br><span class="line">// 当front = rear &amp;&amp; flag = 1为队满</span><br><span class="line"></span><br><span class="line">Queue InitQueue()</span><br><span class="line">&#123;</span><br><span class="line">    Queue q = (Queue)malloc(sizeof(SqQueue));</span><br><span class="line">    q-&gt;base = (Queue)malloc(MaxQSize * sizeof(SqQueue));</span><br><span class="line">    if(!q-&gt;base) &#123;</span><br><span class="line">        printf(&quot;队列初始化失败！&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;rear = 0;</span><br><span class="line">    q-&gt;front = q-&gt;rear;</span><br><span class="line">    q-&gt;flag = 0; // 初始化队空</span><br><span class="line">    return q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EnQueue(Queue q, int e)</span><br><span class="line">&#123;</span><br><span class="line">    // 队满</span><br><span class="line">    if((q-&gt;front == q-&gt;rear) &amp;&amp; q-&gt;flag == 1) &#123;</span><br><span class="line">            printf(&quot;队满！\n&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;base[q-&gt;rear] = e;</span><br><span class="line">    q-&gt;rear = (q-&gt;rear + 1) % MaxQSize;</span><br><span class="line">    if(q-&gt;front == q-&gt;rear)</span><br><span class="line">        q-&gt;flag = 1; // 设置标准为1表示队满</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Queue q = InitQueue();</span><br><span class="line">    int n, e;</span><br><span class="line">    printf(&quot;输入队列长度（最多%d）：&quot;, MaxQSize);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        printf(&quot;入队元素：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;e);</span><br><span class="line">        int result = EnQueue(q, e);</span><br><span class="line">        if(result == 0) &#123;</span><br><span class="line">            printf(&quot;入队成功！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;入队失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;再次尝试入队一个元素：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;e);</span><br><span class="line">    int result = EnQueue(q, e);</span><br><span class="line">    if (result == 0) &#123;</span><br><span class="line">        printf(&quot;入队成功！\n&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;入队失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411020039068.png" alt="image-20241102003937016"></p><h2 id="Q5-1">Q5.1</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411020041203.jpeg" alt="6b21fb7e4ef5139a3346f952d894c98f"></p><p><strong>二维数组：</strong></p><p>假设每个数据元素占L个存储单元，则二维数组A[0…m-1, 0…n-1]（即下标从0开始，共有m行n列）中任一元素aij的存储位置可下式确定</p><p><code>LOC(i, j) = LOC(0, 0) + (n*i + j)L</code></p><p>LOC(i, j)是aij的存储位置；LOC(0, 0)是a00的存储位置，即二维数组A的起始位置（基地址）</p><p><strong>n维数组：</strong></p><p>LOC(j1, j2,  … , jn) = LOC(0, 0, …, 0) + (b2*…*bn*j1 + b3*…*bn*j2 + … + bn*…*jn-1 + jn )  L</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411022302956.png" alt="8038EF1F9402CB579955E4BF8231A1BF"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构学习记录</title>
      <link href="/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1>数据结构</h1><h2 id="绪论">绪论</h2><p>数据：所有能输入到计算机中并可以被计算机处理的信号。</p><p>数据元素：用于完整地描述一个对象，<strong>是数据的基本单位</strong>。</p><p>数据项：组成数据元素的、有独立含义的、不可分割的<strong>最小单位</strong>。</p><p>数据对象：性质相同的数据元素的集合，是数据的一个子集。</p><p>数据结构：相互之间存在一个或多种特定关系的数据元素的集合。</p><p>逻辑结构：从具体问题抽象出来的数学模型。</p><p>存储结构：逻辑结构在计算机中的存储表示。分顺序存储结构和链式存储结构。</p><p>抽象数据类型：由用户定义的，表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称。</p><h3 id="时间复杂度">时间复杂度</h3><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n*n) &lt; O(n*n*n)</p><p>O(2的n次方) &lt; O(n!) &lt; O(n的n次方)</p><p>冒泡排序</p><p>最好时间复杂度：O(n) -&gt; 一轮冒泡就排好</p><p>最坏时间复杂度：O(n*n)</p><h2 id="线性表">线性表</h2><h3 id="顺序表的基本操作">顺序表的基本操作</h3><p><strong>顺序表的存储结构</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define OVERFLOW -1</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *elem; // 存储空间的基地址</span><br><span class="line">    int length; // 当前长度</span><br><span class="line">&#125;SqList; // 顺序表的结构类型为SqList</span><br></pre></td></tr></table></figure><h4 id="初始化">初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">int InitList(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    L-&gt;elem = (int *)malloc(sizeof(int) * MAXSIZE); // 分配内存</span><br><span class="line">    if (!L-&gt;elem) &#123;</span><br><span class="line">        exit(OVERFLOW);</span><br><span class="line">    &#125; // 分配内存失败退出程序</span><br><span class="line">    L-&gt;length = 0; // 创建一个空顺序表</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int L;</span><br><span class="line">    int result = InitList(&amp;L);</span><br><span class="line">    if (result==0) &#123;</span><br><span class="line">        printf(&quot;Init successfully!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;Init error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取值（按位置查找值）">取值（按位置查找值）</h4><p>时间复杂度O(1)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 取值</span><br><span class="line">// 使用 int *value 而不是 int value 的原因是函数需要将找到的元素值返回给调用者。</span><br><span class="line">// 使用指针可以实现这一点，而不需要通过函数的返回值来传递多个结果。</span><br><span class="line">int GetElem(SqList *L, int i, int *e)</span><br><span class="line">&#123;</span><br><span class="line">    if (i &lt; 1 || i &gt; L-&gt;length) &#123;</span><br><span class="line">        return -1; // 判断i的合法性</span><br><span class="line">    &#125;</span><br><span class="line">    *e = L-&gt;elem[i-1]; // 第i-1个位置存储的第i个数据元素</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 主函数调用</span><br><span class="line">int main() &#123;</span><br><span class="line">// 顺序表赋值</span><br><span class="line">    L.elem[0] = 10;</span><br><span class="line">    L.elem[1] = 20;</span><br><span class="line">    L.length = 2;</span><br><span class="line"></span><br><span class="line">    int value, result2 = 1;</span><br><span class="line">    result2 = GetElem(&amp;L, 1, &amp;value); // 查找顺序表第一个元素</span><br><span class="line">    if (result2 == 0) &#123;</span><br><span class="line">        printf(&quot;索引1处的值为%d\n&quot;,value);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;索引超出范围&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查找（按值查找位置）">查找（按值查找位置）</h4><p>O(n)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 按值查找位置</span><br><span class="line">int LocateElem(SqList *L, int e)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i &lt; L-&gt;length; i++) &#123;</span><br><span class="line">        if(L-&gt;elem[i] == e) &#123;</span><br><span class="line">            return i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">L.elem = 20;</span><br><span class="line">L.length = 2;</span><br><span class="line">// 按值查找</span><br><span class="line">    int elem = 20;</span><br><span class="line">    int pos = LocateElem(&amp;L, elem);</span><br><span class="line">    if ( pos != 0 ) &#123;</span><br><span class="line">        printf(&quot;%d在顺序表中的位置是%d&quot;, elem, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;值未找到&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入">插入</h4><p>最好：O(1)  在最后一个位置插入</p><p>最坏：O(n)  在第一个位置插入</p><p>平均：O(n)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 插入</span><br><span class="line">int ListInsert(SqList *L, int i, int e)</span><br><span class="line">&#123;</span><br><span class="line">    if( i&lt;1 || i&gt;L-&gt;length+1 ) &#123; // 位置不合法</span><br><span class="line">        printf(&quot;位置不合法！\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if( L-&gt;length == MAXSIZE ) &#123; // 存储空间已满</span><br><span class="line">        printf(&quot;存储空间已满！\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j = L-&gt;length-1; j &gt;= i-1; j-- ) // 将i后的元素依次向后移动</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;elem[j+1] = L-&gt;elem[j]; // 插入位置之后元素后移</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;elem[i-1] = e; // 插入元素</span><br><span class="line">    ++L-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用</span><br><span class="line">int main() &#123;</span><br><span class="line">// 插入元素</span><br><span class="line">    int position = 3;</span><br><span class="line">    int a = 6;</span><br><span class="line">    L.length = 5;</span><br><span class="line">    printf(&quot;原先的顺序表元素为:\n&quot;);</span><br><span class="line">    for(int j = 0; j &lt; 5; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[j] = j+1;</span><br><span class="line">        printf(&quot;%d&quot;, L.elem[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n插入后的顺序表元素为:\n&quot;);</span><br><span class="line">    int r = ListInsert(&amp;L, position, a);</span><br><span class="line">    if (r == 0) &#123;</span><br><span class="line">        printf(&quot;插入成功！\n&quot;);</span><br><span class="line">        for(int k = 0; k &lt; 6; k++) &#123;</span><br><span class="line">            printf(&quot;%d&quot;,L.elem[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">         printf(&quot;插入失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><p>最好：O(1)  删除最后一个位置</p><p>最坏：O(n)  删除第一个位置</p><p>平均：O(n)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 删除</span><br><span class="line">void ListDelete(SqList *L, int i)</span><br><span class="line">&#123;</span><br><span class="line">    if( i &lt; 1 || i &gt; L-&gt;length) &#123;</span><br><span class="line">        printf(&quot;位置不合法!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j = i; j &lt;= L-&gt;length-1; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;elem[j-1] = L-&gt;elem[j]; // 前移</span><br><span class="line">    &#125;</span><br><span class="line">    --L-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">// 删除元素</span><br><span class="line">    int d = 3;</span><br><span class="line">    ListDelete(&amp;L, d);</span><br><span class="line">    printf(&quot;删除后的顺序表内容为:\n&quot;);</span><br><span class="line">    for(int i = 0; i &lt; L.length; i++) &#123;</span><br><span class="line">        printf(&quot;%d&quot;,L.elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表的基本操作">链表的基本操作</h3><h4 id="单链表">单链表</h4><h5 id="单链表操作完整代码">单链表操作完整代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int data; // 数据域</span><br><span class="line">    struct LNode *next; // 指针域，指向下一个节点</span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line">typedef LNode* LinkList; // 定义链表类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">LinkList InitList()</span><br><span class="line">&#123;</span><br><span class="line">    LinkList L = (LinkList)malloc(sizeof(LNode)); // 生成头结点</span><br><span class="line">    if(L == NULL) &#123;</span><br><span class="line">        printf(&quot;链表初始化失败！\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = NULL; // 头指针设置为空</span><br><span class="line">    printf(&quot;链表初始化成功！\n&quot;);</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 前插法创建单链表</span><br><span class="line">void CreateList_H(LinkList *L, int n)</span><br><span class="line">&#123;</span><br><span class="line">    // 先创建一个空链表</span><br><span class="line">    *L = InitList();</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        LNode *p = (LinkList)malloc(sizeof(LNode)); // 生成新结点</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p-&gt;data); // 输入元素值赋给新结点的数据域</span><br><span class="line">        p-&gt;next = (*L)-&gt;next;  // 将新结点*p插入到头结点之后</span><br><span class="line">        (*L)-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 尾插法创建单链表</span><br><span class="line">void CreateList_R(LinkList *L ,int n)</span><br><span class="line">&#123;</span><br><span class="line">    *L = InitList();</span><br><span class="line">    LNode *r = *L; // 尾指针r指向头结点</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        LNode *p = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p-&gt;data); // 输入元素值赋给新结点的数据域</span><br><span class="line">        p-&gt;next = NULL; // 新结点的下个结点指向空，也就是新结点为尾结点</span><br><span class="line">        r-&gt;next = p; // 原来的尾结点的下一个结点指向新结点</span><br><span class="line">        r = p; // 尾指针指向新结点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取值</span><br><span class="line">int GetElem(LinkList L, int i, int *e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    int j = 1; // 计数器</span><br><span class="line">    while(p &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!p || j &gt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找</span><br><span class="line">LinkList *LocateListElem(LinkList L, int e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    while(p &amp;&amp; p-&gt;data != e)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入</span><br><span class="line">int ListInsert(LinkList *L, int i, int e)</span><br><span class="line">&#123;// 在带头结点的单链表L中第i个位置插入值为e的新结点</span><br><span class="line">    //LNode *p = *L;</span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p &amp;&amp; (j &lt; i-1))</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next; // 查找第i-1个结点，p指向该结点</span><br><span class="line">        ++j; //</span><br><span class="line">    &#125;</span><br><span class="line">    if( !p || j &gt; i - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //LNode *s = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">    LinkList s = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">    if (s == NULL) &#123;</span><br><span class="line">        return -1; // 内存分配失败</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">int ListDelete(LinkList *L, int i)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while( (p-&gt;next) &amp;&amp; (j &lt; i-1) )</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当i&gt;n或者i&lt;1时，位置不合理</span><br><span class="line">    if( !(p-&gt;next) || (j &gt; i-1) )</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next; // 临时保存被删除结点的地址以备释放</span><br><span class="line">    p-&gt;next = q-&gt;next; // 改变删除结点前驱结点的指针，也就是让i-1个结点直接指向被删除结点（q）的下一个结点（q-&gt;next）</span><br><span class="line">    free(q);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印链表</span><br><span class="line">void PrintList(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    LNode *p = L-&gt;next; // 从首元结点</span><br><span class="line">    while(p != NULL) &#123;</span><br><span class="line">        printf(&quot;%d -&gt; &quot;, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;NULL\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放链表</span><br><span class="line">void DestroyList(LinkList *L)</span><br><span class="line">&#123;</span><br><span class="line">    if(*L == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LNode *p = (*L)-&gt;next;</span><br><span class="line">    while(p != NULL)&#123;</span><br><span class="line">        LNode *temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(*L); // 释放头结点</span><br><span class="line">    *L = NULL; // 设置链表指针为NULL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LinkList list;</span><br><span class="line">    int n;</span><br><span class="line">    printf(&quot;请输入链表中元素的数量：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">    printf(&quot;创建链表，请输入%d个元素：\n&quot;,n);</span><br><span class="line">    //CreateList_H(&amp;list, n);</span><br><span class="line">    CreateList_R(&amp;list, n);</span><br><span class="line"></span><br><span class="line">    printf(&quot;插入的元素为：\n&quot;);</span><br><span class="line">    PrintList(list);</span><br><span class="line"></span><br><span class="line">    int m = 2;</span><br><span class="line">    int e;</span><br><span class="line">    if (GetElem(list, m, &amp;e) == 0) &#123;</span><br><span class="line">        printf(&quot;第%d个位置的元素为：%d\n&quot;, m, e);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;获取元素失败\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查找数据为m的位置</span><br><span class="line">    printf(&quot;数据为%d的地址是%p\n&quot;, m , LocateListElem(list, m));</span><br><span class="line"></span><br><span class="line">    // 插入</span><br><span class="line">    int pos = 3;</span><br><span class="line">    int elem = 18;</span><br><span class="line">    int result = ListInsert(&amp;list, pos, elem);</span><br><span class="line">    if(result == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;插入成功！\n&quot;);</span><br><span class="line">        printf(&quot;在第%d位置插入了%d\n&quot;,pos, elem);</span><br><span class="line">        PrintList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;插入失败\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除</span><br><span class="line">    int r = ListDelete(&amp;list, pos);</span><br><span class="line">    if(result == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;删除成功！\n&quot;);</span><br><span class="line">        printf(&quot;删除了第%d个位置\n&quot;,pos);</span><br><span class="line">        PrintList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;删除失败\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DestroyList(&amp;list); // 释放链表</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>链表包括两个域：</p><ul><li>数据域：存储数据元素信息</li><li>指针域：存储直接后继存储位置</li></ul><p><strong>单链表的存储结构</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int data; // 数据域</span><br><span class="line">    struct LNode *next; // 指针域，指向下一个节点</span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line">typedef LNode* LinkList; // 定义链表类型</span><br><span class="line"></span><br><span class="line">LNode：</span><br><span class="line">用于表示链表中的一个节点。</span><br><span class="line">用于创建新的节点。</span><br><span class="line">用于访问节点的成员（如 data 和 next）。</span><br><span class="line">LinkList：</span><br><span class="line">用于表示链表的头指针。</span><br><span class="line">用于传递和返回链表的头指针。</span><br><span class="line">用于遍历链表。</span><br><span class="line">整个程序中LNode*等价于LinkList</span><br></pre></td></tr></table></figure><h5 id="单链表初始化">单链表初始化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">LinkList InitList()</span><br><span class="line">&#123;</span><br><span class="line">    LinkList L = (LinkList)malloc(sizeof(LNode)); // 生成头节点</span><br><span class="line">    if(L == NULL) &#123;</span><br><span class="line">        printf(&quot;链表初始化失败！\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = NULL; // 头指针设置为空</span><br><span class="line">    printf(&quot;链表初始化成功！\n&quot;);</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LinkList list = InitList();</span><br><span class="line"></span><br><span class="line">    free(list);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="取值（按位置查找值）-v2">取值（按位置查找值）</h5><p>步骤：</p><ol><li>指针p指向首元节点，用j做计数器初值赋值为1</li><li>从首元节点开始依次顺着链域向下访问，只要指向当前结点的指针p不为空，并且没有到达序号为i的结点，则做以下循环<ul><li>p指向下一个结点</li><li>计数器j相应加1</li></ul></li><li>退出循环时，如果p为空，或者计数器j大于i，说明指定的序号i值不合法（即i大于表长n或者i小于等于0），取值失败返回-1.</li><li>当j=i时，p所指向的结点就是要找的第i个结点，用e来保存当前的数据域。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 取值</span><br><span class="line">int GetElem(LinkList L, int i, int *e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    int j = 1; // 计数器</span><br><span class="line">    while(p &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!p || j &gt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用</span><br><span class="line">int m = 2;</span><br><span class="line">    int e;</span><br><span class="line">    if (GetElem(list, m, &amp;e) == 0) &#123;</span><br><span class="line">        printf(&quot;第%d个位置的元素为：%d\n&quot;, m, e);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;获取元素失败\n&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410201910026.png" alt="image-20241020191017945"></p><h5 id="查找（按值查找结点地址）">查找（按值查找结点地址）</h5><p>步骤：</p><ol><li>用p指向首元结点</li><li>从首元结点依次顺着链域next向下查找，只要当前结点指针p不为空，并且p所指向结点的数据域不等于e，则执行p指向下一个结点操作</li><li>返回p。若查找成功，p此时即为结点的地址值。否则p为NULL。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查找</span><br><span class="line">LinkList *LocateListElem(LinkList L, int e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    while(p &amp;&amp; p-&gt;data != e)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="前插法创建单链表">前插法创建单链表</h5><p>步骤：</p><ol><li>创建一个只有头结点的空链表，就是InitList()做的事情</li><li>根据带创建链表，循环n次，执行以下操作<ul><li>生成新结点*p</li><li>输入元素赋值给*p的数据域</li><li>将新结点*p插入到头结点之后</li></ul></li></ol><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410192312435.png" alt="image-20241019231229290"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 前插法创建单链表</span><br><span class="line">void CreateList_H(LinkList *L, int n)</span><br><span class="line">&#123;</span><br><span class="line">    // 先创建一个空链表</span><br><span class="line">    *L = InitList();</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        // LNode *p = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">        LNode *p = (LinkList)malloc(sizeof(LNode)); // 生成新结点</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p-&gt;data); // 输入元素值赋给新结点的数据域</span><br><span class="line">        p-&gt;next = (*L)-&gt;next;  // 将新结点*p插入到头结点之后</span><br><span class="line">        (*L)-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410200014761.png" alt="image-20241020001431711"></p><h5 id="后插法创建单链表">后插法创建单链表</h5><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410200050143.png" alt="image-20241020005025039"></p><p>步骤：</p><ol><li>创建一个只有头结点的空链表，就是InitList()做的事情</li><li>尾指针r初始化，指向头结点</li><li>根据创建链表，循环n次以下操作<ul><li>生成新结点*p</li><li>输入元素赋值给*p的数据域</li><li>将新结点*p插入到尾结点*r之后</li><li>尾指针r指向新的尾结点*p</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 尾插法创建单链表</span><br><span class="line">void CreateList_R(LinkList *L ,int n)</span><br><span class="line">&#123;</span><br><span class="line">    *L = InitList();</span><br><span class="line">    LNode *r = *L; // 尾指针r指向头结点</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        LNode *p = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p-&gt;data); // 输入元素值赋给新结点的数据域</span><br><span class="line">        p-&gt;next = NULL; // 新结点的下个结点指向空，也就是新结点作为尾结点</span><br><span class="line">        r-&gt;next = p; // 原来的尾结点的下一个结点指向新结点</span><br><span class="line">        r = p; // 尾指针指向新结点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410200049170.png" alt="image-20241020004932108"></p><h5 id="插入-v2">插入</h5><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410202107474.png" alt="image-20241020210718374"></p><p>步骤：</p><ol><li>找第i-1个位置的结点，然后指针p指向该结点</li><li>生成一个新结点*s</li><li>将*s的数据域置为e</li><li>*s的指针域指向第i个结点（s-&gt;next = p-&gt;next）</li><li>*p的指针域指向新结点*s（p-&gt;next = s）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 插入</span><br><span class="line">int ListInsert(LinkList *L, int i, int e)</span><br><span class="line">&#123;// 在带头结点的单链表L中第i个位置插入值为e的新结点</span><br><span class="line">    //LNode *p = *L;</span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p &amp;&amp; (j &lt; i-1))</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next; // 查找第i-1个结点，p指向该结点</span><br><span class="line">        ++j; //</span><br><span class="line">    &#125;</span><br><span class="line">    if( !p || j &gt; i - 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //LNode *s = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">    LinkList s = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">    if (s == NULL) &#123;</span><br><span class="line">        return -1; // 内存分配失败</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用</span><br><span class="line"></span><br><span class="line">    int pos = 3;</span><br><span class="line">    int elem = 18;</span><br><span class="line">    int result = ListInsert(&amp;list, pos, elem);</span><br><span class="line">    if(result == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;插入成功！\n&quot;);</span><br><span class="line">        printf(&quot;在第%d位置插入了%d\n&quot;,pos, elem);</span><br><span class="line">        PrintList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;插入失败\n&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="删除-v2">删除</h5><p>步骤：</p><ol><li>找ai-1，指针p指向该结点</li><li>临时保存待删除结点ai的地址在q中，以备释放</li><li>将结点*p的指向ai的后继节点</li><li>释放ai的空间</li></ol><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410202125812.png" alt="70CD5A3828CDBD510E1CCBA6B86EF146"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 删除</span><br><span class="line">int ListDelete(LinkList *L, int i)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while( (p-&gt;next) &amp;&amp; (j &lt; i-1) )</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当i&gt;n或者i&lt;1时，位置不合理</span><br><span class="line">    if( !(p-&gt;next) || (j &gt; i-1) )</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next; // 临时保存被删除结点的地址以备释放</span><br><span class="line">    p-&gt;next = q-&gt;next; // 改变删除结点前驱结点的指针，也就是让i-1个结点直接指向被删除结点（q）的下一个结点（q-&gt;next）</span><br><span class="line">    free(q);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为什么循环条件使用p-&gt;next而不是p？</span><br><span class="line">如果使用p作为循环条件，即while(p &amp;&amp; j &lt; i-1)，这可能会导致以下问题：</span><br><span class="line">1.当i为1时：如果要删除第一个节点，即i=1，那么在第一次迭代之前，j已经等于0了，此时j &lt; i-1就不成立了，循环不会执行，p仍然是头指针。这意味着我们无法进入循环去访问p-&gt;next，也就不能进行删除操作。</span><br><span class="line">2.遍历至链表末尾：使用p-&gt;next作为条件可以保证我们在到达链表的最后一个元素时停止，因为最后一个元素的next是指向NULL的。如果我们只检查p，则会一直遍历到p为NULL为止，这样我们就无法访问p-&gt;next来进行删除操作。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 删除</span><br><span class="line">    int r = ListDelete(&amp;list, pos);</span><br><span class="line">    if(result == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;删除成功！\n&quot;);</span><br><span class="line">        printf(&quot;删除了第%d个位置\n&quot;,pos);</span><br><span class="line">        PrintList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;删除失败\n&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410202127882.png" alt="image-20241020212727818"></p><h5 id="查看链表元素">查看链表元素</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 打印链表</span><br><span class="line">void PrintList(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    LNode *p = L-&gt;next; // 从首元结点</span><br><span class="line">    while(p != NULL) &#123;</span><br><span class="line">        printf(&quot;%d -&gt; &quot;, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;NULL\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="释放单链表">释放单链表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 释放链表</span><br><span class="line">void DestroyList(LinkList *L)</span><br><span class="line">&#123;</span><br><span class="line">    if(*L == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LNode *p = (*L)-&gt;next;</span><br><span class="line">    while(p != NULL)&#123;</span><br><span class="line">        LNode *temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(*L); // 释放头结点</span><br><span class="line">    *L = NULL; // 设置链表指针为NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表">双向链表</h4><h5 id="双向链表初始化">双向链表初始化</h5><p><strong>双向链表结构体</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct DuLNode</span><br><span class="line">&#123;</span><br><span class="line">    int data; // 数据域</span><br><span class="line">    struct DuLNode *prior; // 直接前驱</span><br><span class="line">    struct DuLNode *next; // 直接后驱</span><br><span class="line">&#125;DuLNode;</span><br><span class="line"></span><br><span class="line">typedef DuLNode* DuList;</span><br></pre></td></tr></table></figure><h5 id="从后向前查看链表元素">从后向前查看链表元素</h5><p>先设置头结点，然后找尾结点</p><p>从前向后就不用找尾结点了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  从后向前打印双向链表</span><br><span class="line">void PrintList_E(DuList L)</span><br><span class="line">&#123;</span><br><span class="line">    DuList p = L-&gt;next; // 头结点</span><br><span class="line">    // 找最后一个结点</span><br><span class="line">    while (p-&gt;next != NULL) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(p != NULL) &#123;</span><br><span class="line">        printf(&quot;%d -&gt; &quot;, p-&gt;data);</span><br><span class="line">        p = p-&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;NULL\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410202332981.png" alt="image-20241020233232915"></p><h5 id="插入-v3">插入</h5><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410202356843.png" alt="07FA394B659E8C3504E0A898E1C97426"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 插入</span><br><span class="line">int ListInsert(DuList *L, int i, int e)</span><br><span class="line">&#123;</span><br><span class="line">    DuList p = LocateListElem(*L, i);</span><br><span class="line">    if(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    DuList s = (DuList)malloc(sizeof(DuLNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line"></span><br><span class="line">    if (p-&gt;prior != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;prior-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    p-&gt;prior = s;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用，第三个位置插入19</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    DuList list;</span><br><span class="line">    //InitDuList();</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    printf(&quot;请输入双向链表中元素的数量：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    CreateList_H(&amp;list, n);</span><br><span class="line">    PrintList(list);</span><br><span class="line"></span><br><span class="line">    int pos = 3;</span><br><span class="line">    int e = 19;</span><br><span class="line">    // 插入</span><br><span class="line">    int result = ListInsert(&amp;list, pos, e);</span><br><span class="line">    if(result == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;\n插入成功！\n&quot;);</span><br><span class="line">        printf(&quot;在第%d个位置插入了%d\n&quot;, pos, e);</span><br><span class="line">        PrintList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;插入失败！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410240012621.png" alt="image-20241024001227554"></p><h5 id="删除-v3">删除</h5><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410240038344.png" alt="02BD4CDC64CB027E813EAA28B5D38ED9"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 删除</span><br><span class="line">void ListDelete_DuL(DuList *L, int i)</span><br><span class="line">&#123;</span><br><span class="line">    DuList p = LocateListElem(*L, i);</span><br><span class="line">    if(!p)</span><br><span class="line">        return;</span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410240026634.png" alt="image-20241024002658578"></p><h2 id="栈和队列">栈和队列</h2><h3 id="顺序栈的基本操作">顺序栈的基本操作</h3><h4 id="完整代码">完整代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define ERROR -1</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *base; // 栈底指针</span><br><span class="line">    int *top; // 栈顶指针</span><br><span class="line">    int stacksize; // 栈可用的最大容量</span><br><span class="line">&#125;SqStack, *Stack;</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">Stack InitStack()</span><br><span class="line">&#123;</span><br><span class="line">    Stack s = (Stack)malloc(sizeof(SqStack));</span><br><span class="line">    if (s == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈内存分配失败！\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为栈底分配内存</span><br><span class="line">    s-&gt;base = (int *)malloc(MAXSIZE * sizeof(int));</span><br><span class="line">    if(s-&gt;base == NULL) &#123;</span><br><span class="line">        free(s);</span><br><span class="line">        printf(&quot;栈内存分配失败！\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;top = s-&gt;base;</span><br><span class="line">    s-&gt;stacksize = MAXSIZE;</span><br><span class="line">    printf(&quot;栈初始化成功！\n&quot;);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入栈</span><br><span class="line">int Push(Stack s, int e)</span><br><span class="line">&#123;</span><br><span class="line">    // 插入元素e为新的栈顶元素</span><br><span class="line">    if(s-&gt;top-s-&gt;base == s-&gt;stacksize)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈满！\n&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *s-&gt;top = e;</span><br><span class="line">    s-&gt;top++; // 栈顶上移</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">int Pop(Stack s, int *e)</span><br><span class="line">&#123;</span><br><span class="line">    if(s-&gt;top == s-&gt;base)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈空！\n&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;top--; // 栈顶指针下移</span><br><span class="line">    *e = *s-&gt;top; // 栈顶元素赋值给e</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取栈顶元素</span><br><span class="line">int GetTop(Stack s, int *e)</span><br><span class="line">&#123;</span><br><span class="line">    // 返回栈顶元素，不修改栈顶指针</span><br><span class="line">    if(s-&gt;top != s-&gt;base) // 如果栈非空</span><br><span class="line">    &#123;</span><br><span class="line">        *e = *(s-&gt;top - 1);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Stack s = InitStack();</span><br><span class="line">    int n; // 栈长</span><br><span class="line">    printf(&quot;请输入栈长：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    // 入栈</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int e;</span><br><span class="line">        printf(&quot;输入入栈元素：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;e);</span><br><span class="line">        if(Push(s, e) == 0) &#123;</span><br><span class="line">            printf(&quot;入栈成功：%d\n&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot;入栈失败：%d&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 出栈</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int e;</span><br><span class="line">        if(Pop(s, &amp;e) == 0)&#123;</span><br><span class="line">            printf(&quot;出栈成功，元素为%d\n&quot;,e);</span><br><span class="line">            int topElem;</span><br><span class="line">            if(GetTop(s, &amp;topElem) == 0) &#123;</span><br><span class="line">                printf(&quot;此时栈顶元素为：%d\n&quot;, topElem);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                printf(&quot;栈空，无法获取栈顶元素！\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;出栈失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：先入后出，后入先出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define ERROR -1</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *base; // 栈底指针</span><br><span class="line">    int *top; // 栈顶指针</span><br><span class="line">    int stacksize; // 栈可用的最大容量</span><br><span class="line">&#125;SqStack, *Stack;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410242300961.png" alt="image-20241024230013912"></p><h4 id="初始化-v2">初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Stack InitStack()</span><br><span class="line">&#123;</span><br><span class="line">    Stack s = (Stack)malloc(sizeof(SqStack));</span><br><span class="line">    if (s == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈内存分配失败！\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为栈底分配内存</span><br><span class="line">    s-&gt;base = (int *)malloc(MAXSIZE * sizeof(int));</span><br><span class="line">    if(s-&gt;base == NULL) &#123;</span><br><span class="line">        free(s);</span><br><span class="line">        printf(&quot;栈内存分配失败！\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;top = s-&gt;base;</span><br><span class="line">    s-&gt;stacksize = MAXSIZE;</span><br><span class="line">    printf(&quot;栈初始化成功！\n&quot;);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入栈">入栈</h4><p>步骤：</p><ol><li>判断栈是否满（s-&gt;top - s-&gt;base == 0）</li><li>将新元素压入栈顶，栈顶指针加一</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 入栈</span><br><span class="line">int Push(Stack s, int e)</span><br><span class="line">&#123;</span><br><span class="line">    // 插入元素e为新的栈顶元素</span><br><span class="line">    if(s-&gt;top-s-&gt;base == s-&gt;stacksize)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈满！\n&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *s-&gt;top = e;</span><br><span class="line">    s-&gt;top++; // 栈顶上移</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈">出栈</h4><p>步骤：</p><ol><li>判断栈是否为空（s-&gt;top == s-&gt;base）</li><li>栈顶指针减一，栈顶元素出栈</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 出栈</span><br><span class="line">int Pop(Stack s, int *e)</span><br><span class="line">&#123;</span><br><span class="line">    if(s-&gt;top == s-&gt;base)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;栈空！\n&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;top--; // 栈顶指针下移</span><br><span class="line">    *e = *s-&gt;top; // 栈顶元素赋值给e</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取栈顶元素">获取栈顶元素</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 取栈顶元素</span><br><span class="line">int GetTop(Stack s, int *e)</span><br><span class="line">&#123;</span><br><span class="line">    // 返回栈顶元素，不修改栈顶指针</span><br><span class="line">    if(s-&gt;top != s-&gt;base) // 如果栈非空</span><br><span class="line">    &#123;</span><br><span class="line">        *e = *(s-&gt;top - 1);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 出栈</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int e;</span><br><span class="line">        if(Pop(s, &amp;e) == 0)&#123;</span><br><span class="line">            printf(&quot;出栈成功，元素为%d\n&quot;,e);</span><br><span class="line">            int topElem;</span><br><span class="line">            if(GetTop(s, &amp;topElem) == 0) &#123;</span><br><span class="line">                printf(&quot;此时栈顶元素为：%d\n&quot;, topElem);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                printf(&quot;栈空，无法获取栈顶元素！\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;出栈失败！\n&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410242336546.png" alt="image-20241024233650488"></p><h3 id="循环队列的基本操作">循环队列的基本操作</h3><h4 id="完整代码-v2">完整代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MAXQSIZE 100</span><br><span class="line">#define ERROR -1</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *base; // 存储空间基地址</span><br><span class="line">    int front; // 头指针</span><br><span class="line">    int rear; // 尾指针</span><br><span class="line">&#125;SqQueue, *Queue;</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">Queue InitQueue()</span><br><span class="line">&#123;</span><br><span class="line">    Queue q = (Queue)malloc(sizeof(SqQueue));</span><br><span class="line">    q-&gt;base = (Queue)malloc(MAXQSIZE * sizeof(SqQueue));</span><br><span class="line">    if(!q-&gt;base)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;队列初始化失败！\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;rear = 0;</span><br><span class="line">    q-&gt;front = q-&gt;rear;</span><br><span class="line">    return q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 求队列长度</span><br><span class="line">int QueueLength(Queue q)</span><br><span class="line">&#123;</span><br><span class="line">    // 对于非循环队列，差值可能为负数，所以需要和MAXQSIZE求余</span><br><span class="line">    return (q-&gt;rear - q-&gt;front + MAXQSIZE) % MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入队</span><br><span class="line">int EnQueue(Queue q, int e)</span><br><span class="line">&#123;</span><br><span class="line">    if(( q-&gt;rear + 1 ) % MAXQSIZE == q-&gt;front)</span><br><span class="line">        return ERROR;</span><br><span class="line">    q-&gt;base[q-&gt;rear] = e; // 新元素插入队尾</span><br><span class="line">    q-&gt;rear = (q-&gt;rear + 1) % MAXQSIZE; // 队尾指针加1</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出队</span><br><span class="line">int DeQueue(Queue q, int *e)</span><br><span class="line">&#123;</span><br><span class="line">    if( q-&gt;front == q-&gt;rear)</span><br><span class="line">        return ERROR;</span><br><span class="line">    *e = q-&gt;base[q-&gt;front]; // 保存队头元素</span><br><span class="line">    q-&gt;front = (q-&gt;front + 1) % MAXQSIZE; // 队头指针加1</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取循环队列队头元素</span><br><span class="line">int GetHead(Queue q)</span><br><span class="line">&#123;</span><br><span class="line">    if(q-&gt;front != q-&gt;rear)</span><br><span class="line">        return q-&gt;base[q-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Queue q = InitQueue();</span><br><span class="line"></span><br><span class="line">    int n, e;</span><br><span class="line">    printf(&quot;请输入队列的长度：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;入队元素：&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;e);</span><br><span class="line">        int result = EnQueue(q, e);</span><br><span class="line">        if(result == 0) &#123;</span><br><span class="line">            printf(&quot;成功入队！\n&quot;);</span><br><span class="line">            printf(&quot;此时队列长度为：%d\n&quot;, QueueLength(q));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;入队失败！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 出队</span><br><span class="line">    for(int j = 0; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(DeQueue(q, &amp;e) == 0) &#123;</span><br><span class="line">            printf(&quot;此时队列长度为：%d\n&quot;, QueueLength(q));</span><br><span class="line"></span><br><span class="line">            // 显示当前队列元素</span><br><span class="line">            int head = GetHead(q);</span><br><span class="line">            if(head != ERROR) &#123;</span><br><span class="line">                printf(&quot;出队元素：%d\n&quot;, e);</span><br><span class="line">                printf(&quot;当前队头元素为：%d\n&quot;,head);</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                printf(&quot;队列为空，无法取队头元素！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;出队失败！\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(q-&gt;base);</span><br><span class="line">    free(q);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>特点：先入先出，后入后出</p><p><strong>循环队列判断</strong></p><p>队空：Q.front = Q.rear</p><p>队满：(Q.rear + 1)%MAXSIZE == Q.front</p><p>少用一个存储位置，约定一个位置为空</p><p>结构体</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define MAXQSIZE 100</span><br><span class="line">#define ERROR -1</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *base; // 存储空间基地址</span><br><span class="line">    int front; // 头指针</span><br><span class="line">    int rear; // 尾指针</span><br><span class="line">&#125;SqQueue, *Queue;</span><br></pre></td></tr></table></figure><h4 id="初始化-v3">初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Queue InitQueue()</span><br><span class="line">&#123;</span><br><span class="line">    Queue q = (Queue)malloc(sizeof(SqQueue));</span><br><span class="line">    q-&gt;base = (Queue)malloc(MAXQSIZE * sizeof(SqQueue));</span><br><span class="line">    if(!q-&gt;base)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;队列初始化失败！\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;rear = 0;</span><br><span class="line">    q-&gt;front = q-&gt;rear;</span><br><span class="line">    return q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求队列长度">求队列长度</h4><p>对于非循环队列，差值可能为负数，所以需要和MAXQSIZE求余</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 求队列长度</span><br><span class="line">int QueueLength(Queue q)</span><br><span class="line">&#123;</span><br><span class="line">    // 对于非循环队列，差值可能为负数，所以需要和MAXQSIZE求余</span><br><span class="line">    return (q-&gt;rear - q-&gt;front + MAXQSIZE) % MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队">入队</h4><p>步骤：</p><ol><li>判断队列是否为满</li><li>将新元素插入队尾</li><li>队尾指针加1（q-&gt;rear + 1） % MAXSIZE</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 入队</span><br><span class="line">int EnQueue(Queue q, int e)</span><br><span class="line">&#123;</span><br><span class="line">    if(( q-&gt;rear + 1 ) % MAXQSIZE == q-&gt;front)</span><br><span class="line">        return ERROR;</span><br><span class="line">    q-&gt;base[q-&gt;rear] = e; // 新元素插入队尾</span><br><span class="line">    q-&gt;rear = (q-&gt;rear + 1) % MAXQSIZE; // 队尾指针加1</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出队">出队</h4><p>步骤：</p><ol><li>判断队空</li><li>保存队头元素</li><li>队头指针加1</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 出队</span><br><span class="line">int DeQueue(Queue q, int *e)</span><br><span class="line">&#123;</span><br><span class="line">    if( q-&gt;front == q-&gt;rear)</span><br><span class="line">        return ERROR;</span><br><span class="line">    *e = q-&gt;base[q-&gt;front]; // 保存队头元素</span><br><span class="line">    q-&gt;front = (q-&gt;front + 1) % MAXQSIZE; // 队头指针加1</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取队头元素">取队头元素</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 取循环队列队头元素</span><br><span class="line">int GetHead(Queue q)</span><br><span class="line">&#123;</span><br><span class="line">    if(q-&gt;front != q-&gt;rear)</span><br><span class="line">        return q-&gt;base[q-&gt;front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202411012347185.png" alt="image-20241101234738130"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoLang学习记录</title>
      <link href="/2024/11/08/GoLang%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/11/08/GoLang%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>GoLang记录</h1><h2 id="goroute、select、channel练习">goroute、select、channel练习</h2><p>请写出一个场景：<code>二营长的意大利炮</code></p><blockquote><p>为了高效的打鬼子，二营长搬出了他珍藏的一门意大利炮，并命令一堆手下来操作意大利炮</p></blockquote><ul><li>发射一下意大利炮需要经过三个步骤：<code>装填</code>→<code>瞄准</code>→<code>发射</code></li><li>每个阶段打印出这个阶段的名称即可</li><li>每一个手下都是一个 goroutine<ul><li>每个手下只负责一个步骤</li></ul></li><li>需要使用 channel 来同步各个手下的操作</li><li>作为指挥的二营长，他希望一个命令就可以停止打炮<ul><li>按下 <code>q</code> 就停止打炮了，kill 进程不算</li><li>可以使用 <code>&quot;github.com/eiannone/keyboard&quot;</code> 来监听键盘按键事件</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com/eiannone/keyboard&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var (</span><br><span class="line">// 创建用于同步的通道</span><br><span class="line">aim    = make(chan struct&#123;&#125;)</span><br><span class="line">load   = make(chan struct&#123;&#125;)</span><br><span class="line">launch = make(chan struct&#123;&#125;)</span><br><span class="line">stop   = make(chan struct&#123;&#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">go handleLoad(load, aim, stop)</span><br><span class="line">go handleAim(aim, launch, stop)</span><br><span class="line">go handleLaunch(launch, stop)</span><br><span class="line"></span><br><span class="line">go listenQuit(stop)</span><br><span class="line"></span><br><span class="line">// 空结构体通常用于在 goroutine 之间传递信号,适用于只需要信号不需要数据的场景</span><br><span class="line">load &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">//  监听多个信道</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-launch:</span><br><span class="line">fmt.Println(&quot;任务完成！&quot;)</span><br><span class="line">case &lt;-stop:</span><br><span class="line">fmt.Println(&quot;停止打炮！&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handleAim(load chan struct&#123;&#125;, aim chan struct&#123;&#125;, stop chan struct&#123;&#125;) &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-load:</span><br><span class="line">fmt.Println(&quot;正在瞄准！&quot;)</span><br><span class="line">time.Sleep(5 * time.Second)</span><br><span class="line">aim &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">case &lt;-stop:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handleLoad(aim chan struct&#123;&#125;, launch chan struct&#123;&#125;, stop chan struct&#123;&#125;) &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-aim:</span><br><span class="line">fmt.Println(&quot;正在装填！&quot;)</span><br><span class="line">time.Sleep(10 * time.Second)</span><br><span class="line">launch &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">case &lt;-stop:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handleLaunch(launch chan struct&#123;&#125;, stop chan struct&#123;&#125;) &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-launch:</span><br><span class="line">fmt.Println(&quot;发射！&quot;)</span><br><span class="line">case &lt;-stop:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func listenQuit(stop chan struct&#123;&#125;) &#123;</span><br><span class="line">defer keyboard.Close()</span><br><span class="line">if err := keyboard.Open(); err != nil &#123;</span><br><span class="line">fmt.Println(&quot;Failed to open keyboard!&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">char, _, err := keyboard.GetSingleKey()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;Failed to read keyboard input!&quot;)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">if char == &#x27;q&#x27; || char == &#x27;Q&#x27; &#123;</span><br><span class="line">close(stop)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结构体练习">结构体练习</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Movie struct &#123;</span><br><span class="line">Name     string</span><br><span class="line">Director string</span><br><span class="line">Time     string</span><br><span class="line">Score    float64</span><br><span class="line">UserRate []float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *Movie) AddUserRate(rate float64) &#123;</span><br><span class="line">m.UserRate = append(m.UserRate, rate)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a := Movie&#123;Name: &quot;西线无战事&quot;,</span><br><span class="line">Director: &quot;爱德华·贝尔格&quot;,</span><br><span class="line">Time:     &quot;148 minutes&quot;,</span><br><span class="line">Score:    8.8,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;请输入你的命令：\n1.获得名字\n2.获得导演名\n3.获得片长\n4.获得评分\n5.用户评分\n6.退出程序\n&quot;)</span><br><span class="line">var option int</span><br><span class="line">for &#123;</span><br><span class="line">fmt.Scanf(&quot;%d &quot;, &amp;option)</span><br><span class="line">switch option &#123;</span><br><span class="line">case 1:</span><br><span class="line">fmt.Println(a.Name)</span><br><span class="line">case 2:</span><br><span class="line">fmt.Println(a.Director)</span><br><span class="line">case 3:</span><br><span class="line">fmt.Println(a.Time)</span><br><span class="line">case 4:</span><br><span class="line">if len(a.UserRate) == 0 &#123;</span><br><span class="line">fmt.Println(&quot;暂无评分！&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for i, rate := range a.UserRate &#123;</span><br><span class="line">fmt.Printf(&quot;用户 %d 评分: %.1f\n&quot;, i+1, rate)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">case 5:</span><br><span class="line">var rate float64</span><br><span class="line">fmt.Println(&quot;请输入评分（0-10.0）：&quot;)</span><br><span class="line">fmt.Scanln(&amp;rate)</span><br><span class="line">if rate &lt; 0 || rate &gt; 10 &#123;</span><br><span class="line">fmt.Println(&quot;无效评分！请重新输入。&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">a.AddUserRate(rate)</span><br><span class="line">fmt.Println(&quot;评分已添加！&quot;)</span><br><span class="line">&#125;</span><br><span class="line">case 6:</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;无效的选项，请重新输入。&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;\n请输入你的命令：\n1.获得名字\n2.获得导演名\n3.获得片长\n4.获得评分\n5.用户评分\n6.退出程序\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="database-mysql连接数据库">database/mysql连接数据库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;database/sql&quot;                     //标准库</span><br><span class="line">_ &quot;github.com/go-sql-driver/mysql&quot; //我们使用的mysql，需要导入相应驱动包，否则会报错</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var db *sql.DB</span><br><span class="line"></span><br><span class="line">func InitDB() &#123;</span><br><span class="line">var err error</span><br><span class="line">// 设置一下dns charset:编码方式 parseTime:是否解析time类型 loc:时区</span><br><span class="line">dsn := &quot;root:123456@tcp(192.168.10.104:3306)/demo?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br><span class="line">// 打开mysql驱动</span><br><span class="line">db, err = sql.Open(&quot;mysql&quot;, dsn)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">// 尝试与数据库建立连接（校验dsn是否正确）</span><br><span class="line">err = db.Ping()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(&quot;DB connect success&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目录规范">目录规范</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------- go目录 ----------------------------</span><br><span class="line">/cmd：项目的可执行文件名称相符，通常有一个简短的main函数。从/internal和/pkg目录导入代码。其他没有了</span><br><span class="line">/internal： 私有应用程序和库代码</span><br><span class="line">/pkg：外部应用可以导入的库代码</span><br><span class="line">/vendor：应用程序依赖项</span><br><span class="line">-----------------服务应用程序目录 ---------------</span><br><span class="line">/api：协议文件</span><br><span class="line">/web:  静态web组件</span><br><span class="line">-----------------通用应用目录 ---------------</span><br><span class="line">/configs：项目的默认配置</span><br><span class="line">/init：system init （systemd，upstart，sysv) 配置</span><br><span class="line">/scripts：执行各种构建、安装、分析等操作的脚本</span><br><span class="line">/build：打包和持续集成</span><br><span class="line">/deployments：部署配置</span><br><span class="line">/test：测试</span><br><span class="line">-----------------其他目录 ---------------</span><br><span class="line">/docs：文档</span><br><span class="line">/tools：项目支持的工具</span><br><span class="line">/examples：应用程序和公共库实例</span><br><span class="line">/third_party：外部工具</span><br><span class="line">/githooks: - </span><br><span class="line">/assets: 图片和其他存储的文件</span><br><span class="line">/website：-</span><br><span class="line">不应该有的目录</span><br><span class="line">/src：请不要将项目级别的src目录和工作空间的src目录混淆。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习记录</title>
      <link href="/2024/11/08/C%E8%AF%AD%E8%A8%80%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/11/08/C%E8%AF%AD%E8%A8%80%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>Q1</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编程利用循环打印如下字符图形：</span><br><span class="line">12345678987654321</span><br><span class="line"> 234567898765432</span><br><span class="line">  3456789876543</span><br><span class="line">   45678987654</span><br><span class="line">    567898765</span><br><span class="line">     6789876</span><br><span class="line">      78987</span><br><span class="line">       898</span><br><span class="line">        9</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">for(i=1;i&lt;=9;i++)&#123; // 控制行数（1-9行）</span><br><span class="line">        for(j=1;j&lt;i;j++) &#123; // 打印每行开头的空格，空格与当前行数有关</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for(j=i;j&lt;=9;j++)&#123; // 打印递增数字</span><br><span class="line">            printf(&quot;%d&quot;,j);</span><br><span class="line">        &#125;</span><br><span class="line">        for(j=8;j&gt;=i;j--) &#123; // 打印从9递减至当前行数</span><br><span class="line">            printf(&quot;%d&quot;,j);</span><br><span class="line">        &#125;</span><br><span class="line">        for(j=1;j&lt;i;j++) &#123; // 打印每行结尾的空格</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;); // 下一行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Q2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二分法。用二分法求一元方程2x^3-4x^2+3x-6=0在(x1,x2)区间的根。</span><br><span class="line">**输入格式要求：&quot;%f,%f&quot; 提示信息：&quot;Enter x1,x2:&quot;</span><br><span class="line">**输出格式要求：&quot;x=%6.2f\n&quot;</span><br><span class="line">程序运行示例如下：</span><br><span class="line">Enter x1,x2:-10,10</span><br><span class="line">x=  2.00</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">main()</span><br><span class="line">&#123;float x0,x1,x2,fx0,fx1,fx2;</span><br><span class="line"> do</span><br><span class="line"> &#123;  printf(&quot;Enter x1,x2:&quot;);</span><br><span class="line">    scanf(&quot;%f,%f&quot;,&amp;x1,&amp;x2);</span><br><span class="line">    fx1=2*x1*x1*x1-4*x1*x1+3*x1-6;</span><br><span class="line">    fx2=2*x2*x2*x2-4*x2*x2+3*x2-6;</span><br><span class="line">  &#125; while(fx1*fx2&gt;0);</span><br><span class="line"> do</span><br><span class="line"> &#123;  x0=(x1+x2)/2;</span><br><span class="line">    fx0=2*x0*x0*x0-4*x0*x0+3*x0-6;</span><br><span class="line">    if((fx0*fx1)&lt;0)</span><br><span class="line">    &#123;  x2=x0;</span><br><span class="line">       fx2=fx0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;  x1=x0;</span><br><span class="line">       fx2=fx0;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;while(fabs((double)fx0)&gt;=1e-5);</span><br><span class="line"> printf(&quot;x=%6.2f\n&quot;,x0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Q3</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编程计算s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，a和相加的项数由用户输入控制。</span><br><span class="line">**输入格式要求：&quot;%d,%d&quot; 提示信息：&quot;please input a and n\n&quot; </span><br><span class="line">**输出格式要求：&quot;a=%d,n=%d\n&quot;  &quot;a+aa+...=%ld\n&quot;</span><br><span class="line">程序运行示例如下：</span><br><span class="line">please input a and n</span><br><span class="line">3,5</span><br><span class="line">a=3,n=5</span><br><span class="line">a+aa+...=37035</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int b=0, a, n;</span><br><span class="line">    long int s=0;</span><br><span class="line">    printf(&quot;please input a and n\n&quot;);</span><br><span class="line">    scanf(&quot;%d,%d&quot;,&amp;a,&amp;n);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        b = b * 10 + a;</span><br><span class="line">        s += b;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;a=%d,n=%d\n&quot;, a, n);</span><br><span class="line">    printf(&quot;a+aa+...=%ld\n&quot;,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Q4</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用求阶乘函数Fact()，编程计算并输出1! + 2! + …+ n!的值。</span><br><span class="line">**输入格式要求：&quot;%u&quot;  提示信息：&quot;Input n(n&gt;0):&quot;</span><br><span class="line">**输出格式要求：&quot;sum = %lu\n&quot;</span><br><span class="line">程序运行示例：</span><br><span class="line">Input n(n&gt;0):5</span><br><span class="line">sum = 153</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned long Fact(unsigned int n) &#123;</span><br><span class="line">    unsigned long result = 1;</span><br><span class="line">    for (unsigned int i = 1;i&lt;=n;i++) &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned int n;</span><br><span class="line">printf(&quot;Input n(n&gt;0):&quot;);</span><br><span class="line">scanf(&quot;%u&quot;,&amp;n);</span><br><span class="line">unsigned long sum = 0;</span><br><span class="line">for (unsigned int i = 1;i&lt;=n;i++) &#123;</span><br><span class="line">        sum += Fact(i);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;sum = %lu\n&quot;,sum);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Q5</h1><p>判断1-100的素数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fun(int n);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m, k = 0;</span><br><span class="line">    for (m = 1; m &lt;= 100; m++)</span><br><span class="line">        if (fun(m) == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%4d&quot;, m);</span><br><span class="line">            k++;</span><br><span class="line">            if (k % 5 == 0)</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fun(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, k = 1;</span><br><span class="line">    if (n &lt;= 1) &#123;</span><br><span class="line">        k = 0;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 2; i &lt; n; i++) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            k = 0;</span><br><span class="line">            return k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>找素数函数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int fun(int n);</span><br><span class="line"></span><br><span class="line">int fun(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if (n &lt;= 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 2; i &lt; n; i++) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>利用辗转相除法求最大公约数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int MaxCommonFactor(int a, int b);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, x;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Input a,b:&quot;);</span><br><span class="line">    scanf(&quot;%d,%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    x = MaxCommonFactor(a,b);</span><br><span class="line">    printf(&quot;MaxCommonFactor = %d\n&quot;, x);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int MaxCommonFactor(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int r;</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;while (r != 0);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>pow函数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">double myPOW(int x,int n);</span><br><span class="line">double myPOW(int x, int n) &#123;</span><br><span class="line">    double result = 1.0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        result *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x, n;</span><br><span class="line">    double result;</span><br><span class="line">    printf(&quot;Enter x and n\n&quot;);</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;x,&amp;n);</span><br><span class="line">    result = myPOW(x,n);</span><br><span class="line">    printf(&quot;mypow(%d,%d) = %.2f\n&quot;,x,n,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>找完数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下程序功能是实现求10000 以内的自然数中的完数及其个数（所谓完数，指它恰好等于除它本身之外的因子之和，如：6=1+2+3，28=1+2+4+7+14），并显示结果。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define LEN 10000</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i,k,m,n,s,p=0;</span><br><span class="line">    int a[100];</span><br><span class="line">    printf(&quot;Number as follows:&quot;);</span><br><span class="line">    for (i=2; i&lt;= LEN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s=0;</span><br><span class="line">        m=0;</span><br><span class="line">        k=1;</span><br><span class="line">        while(k&lt;=i/2)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i%k==0)</span><br><span class="line">            &#123;</span><br><span class="line">                s=s+k;</span><br><span class="line">                a[m]=k;</span><br><span class="line">                m=m+1;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s==i)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p+1;</span><br><span class="line">            printf(&quot;\n%d=%d&quot;,s,a[0]);</span><br><span class="line">            n=1;</span><br><span class="line">            while (n &lt; m)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;+%d&quot;,a[n]);</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\nTotal Num： %d&quot;,p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int IsPerfect(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x == 1 || x ==0)</span><br><span class="line">        return 0;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i=1;i&lt;=x/2;i++) &#123;</span><br><span class="line">        if(x%i==0)</span><br><span class="line">            sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum == x)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>递归逆序数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">long Func(int n);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    long n;</span><br><span class="line">    printf(&quot;Enter number:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    Func(n);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">long Func(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int m;</span><br><span class="line">    if(n==0)</span><br><span class="line">        return -1;</span><br><span class="line">    else &#123;</span><br><span class="line">        m = n % 10;</span><br><span class="line">        printf(&quot;%d&quot;,m);</span><br><span class="line">        Func(n / 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找1000内的完数并且输出因子</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int is_find(int x);</span><br><span class="line">void find(int x);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for(int i=1;i&lt;=1000;i++) &#123;</span><br><span class="line">        result = is_find(i);</span><br><span class="line">        if(result == 1)</span><br><span class="line">            find(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int is_find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x == 1 || x ==0)</span><br><span class="line">        return 0;</span><br><span class="line">    int i, sum=1;</span><br><span class="line">    for(i=2;i&lt;=x/2;i++) &#123;</span><br><span class="line">        if(x%i==0)</span><br><span class="line">            sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum == x)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">void find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int i, sum=0;</span><br><span class="line">    printf(&quot;\n%5d\n&quot;,x);</span><br><span class="line">    for(i=1;i&lt;x;i++) &#123;</span><br><span class="line">        if(x%i==0)&#123;</span><br><span class="line">            printf(&quot;%5d&quot;,i);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>汉诺塔问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">汉诺塔（Hanoi）是必须用递归方法才能解决的经典问题。它来自于印度神话。上帝创造世界时作了三根金刚石柱子，在第一根柱子上从下往上按大小顺序摞着64片黄金圆盘，如图7-3所示。上帝命令婆罗门把圆盘从下面开始按大小顺序重新摆放到第二根柱子上，并且规定，每次只能移动一个圆盘，在小圆盘上不能放大圆盘。有人预言说，这件事完成时宇宙会在一瞬间闪电式毁灭，也有人相信婆罗门至今仍在一刻不停地搬动着圆盘。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void Func(int n, char a, char b, char c);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    printf(&quot;Input the number of disks:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;Steps of moving %d disks from A to B by means of C:\n&quot;,n);</span><br><span class="line">    Func(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void Func(int n, char a, char b, char c)</span><br><span class="line">&#123;</span><br><span class="line">    if(n == 1) &#123;</span><br><span class="line">        printf(&quot;Move 1: from %c to %c\n&quot;,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        Func(n-1,a,c,b); // 将n-1个盘子从起始柱子移动到辅助柱子</span><br><span class="line">        printf(&quot;Move %d: from %c to %c\n&quot;,n,a,b);</span><br><span class="line">        Func(n-1,c,b,a); // 将之前移动到辅助柱子上的n-1个盘子从辅助柱子移动到目标柱子</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>查找车牌</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    for(a=1;a&lt;=9;a++) &#123;</span><br><span class="line">        for(b=1;b&lt;=9;b++) &#123;</span><br><span class="line">                if(a!=b &amp;&amp; (a*1000+a*100+b*10+b)==sqrt(a*1000+a*100+b*10+b)*sqrt(a*1000+a*100+b*10+b)) &#123;</span><br><span class="line">                    printf(&quot;31%d%d%d%d¡£&quot;,a,a,b,b);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>查找数组元素下标</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int Search(int a[], int n, int x);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[10];</span><br><span class="line">    int x;</span><br><span class="line">    int result = -1;</span><br><span class="line">    printf(&quot;Input 10 numbers:\n&quot;);</span><br><span class="line">    for(int i=0;i&lt;10;i++) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        a[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Input x:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    result = Search(a,10,x);</span><br><span class="line">    if(result != -1)</span><br><span class="line">        printf(&quot;Subscript of x is %d\n&quot;,result);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;Not found!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int Search(int a[], int n, int x)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        if(a[i]==x) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num[12] = &#123; 1, 0 &#125;;</span><br><span class="line">    int total = 1;</span><br><span class="line">    printf(&quot;%4d&quot;,num[0]);</span><br><span class="line"></span><br><span class="line">    for(int i=1 ;i &lt; 12;i++) &#123;</span><br><span class="line">        num[i] = num[i-1] + num[i-2];</span><br><span class="line">        total += num[i];</span><br><span class="line">        printf(&quot;%4d&quot;,num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\nTotal = %d\n&quot;,total);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>找素数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int func(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;2)</span><br><span class="line">        return 0;</span><br><span class="line">    for (int i=2;i*i&lt;=n;i++) &#123;</span><br><span class="line">        if(n%i == 0)</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>递归法找最大公约数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Gcd(int a, int b) &#123;</span><br><span class="line">    if (a == b) &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125; else if (a &gt; b) &#123;</span><br><span class="line">        return Gcd(a - b, b);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return Gcd(a, b - a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>二维数组的冒泡排序</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k, temp;</span><br><span class="line">    int a[3][4] = &#123;1,2,3,4,9,8,7,6,10,-2,-4,4&#125;;</span><br><span class="line">    for(i=0;i&lt;3;i++) &#123; // 遍历每一行</span><br><span class="line">        for(j=0;j&lt;4;j++) &#123; // 遍历每行的每个元素</span><br><span class="line">            for(k=j+1;k&lt;4;k++) // 用来与j控制的循环当前元素之后的元素比较</span><br><span class="line">                if(a[i][k]&lt;a[i][j])&#123; // 比较每一行相邻的元素</span><br><span class="line">                    temp = a[i][k];</span><br><span class="line">                    a[i][k] = a[i][j];</span><br><span class="line">                    a[i][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;max=%d\n&quot;,a[2][3]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>矩阵相乘</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define M 3</span><br><span class="line">#define S 4</span><br><span class="line">#define N 2</span><br><span class="line"></span><br><span class="line">void multiply(int A[M][S], int B[S][N], int C[M][N])</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    for(i=0;i&lt;M;i++) &#123;</span><br><span class="line">        for(j=0;j&lt;N;j++) &#123;</span><br><span class="line">            C[i][j] = 0;</span><br><span class="line">            for(k=0;k&lt;S;k++) &#123;</span><br><span class="line">                C[i][j] += A[i][k] * B[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>一维数组的冒泡排序</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; N-1; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; N-1-i; j++) &#123;</span><br><span class="line">            if (a[j] &gt; a[j+1]) &#123;</span><br><span class="line">                // 交换元素</span><br><span class="line">                temp = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">// i用来控制交换轮数，j控制相邻元素</span><br><span class="line">// N-1-i 是因为在每一轮排序之后，数组中最后的 i 个元素已经处于正确的位置，不需要再次参与比较。</span><br></pre></td></tr></table></figure><h1>杨辉三角</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;=i;j++) &#123;</span><br><span class="line">            if(j == 0 || j == i)</span><br><span class="line">                a[i][j] = 1;</span><br><span class="line">        else</span><br><span class="line">            a[i][j] = a[i-1][j-1] + a[i-1][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">            printf(&quot;%4d&quot;, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>等腰三角形式杨辉三角</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define N 10</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[N][N] = &#123;0&#125;;</span><br><span class="line">    for(int i=0;i&lt;N;i++) &#123;</span><br><span class="line">        for(int j=0;j&lt;=i;j++) &#123;</span><br><span class="line">            if( i == j || j == 0 )</span><br><span class="line">                a[i][j] = 1;</span><br><span class="line">            if( i &gt; 1 )</span><br><span class="line">                a[i][j] = a[i-1][j-1] + a[i-1][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;N;i++) &#123;</span><br><span class="line">        for(int j=0;j&lt;N-1-i;j++)</span><br><span class="line">            printf(&quot;  &quot;);</span><br><span class="line">        for(int j=0;j&lt;=i;j++)</span><br><span class="line">            printf(&quot;%4d&quot;,a[i][j]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>逆序任意数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int inverse(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int b, c[100];</span><br><span class="line">    int p = 0;</span><br><span class="line">    int T = 0;</span><br><span class="line">    int temp = a;</span><br><span class="line"></span><br><span class="line">    // 计算a的位数</span><br><span class="line">    while (temp &gt; 0)&#123;</span><br><span class="line">        p++;</span><br><span class="line">        temp /= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重新将a赋值给temp</span><br><span class="line">    temp = a;</span><br><span class="line"></span><br><span class="line">    // 从个位提取a的每一位数字，保存在c[]中</span><br><span class="line">    for(int i = 0; i &lt; p; i++) &#123;</span><br><span class="line">        b = temp % 10;</span><br><span class="line">        c[i] = b;</span><br><span class="line">        temp /= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出逆序数</span><br><span class="line">    for(int i = 0; i &lt; p; i++) &#123;</span><br><span class="line">        T += c[i] * pow(10 , p - 1 - i);</span><br><span class="line">    &#125;</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>39阶梯问题</h1><p>有人要爬39级台阶。每一步只能走1到2步。先左脚，然后左右交替，最后一步是右脚，也就是说，走偶数步。写一个递归函数来输出39步中有多少种不同的方法？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int sum = 0; // 方法数</span><br><span class="line">void up(int stair, int walk) // stair用于记录上升的台阶数，walk用于记录步数</span><br><span class="line">&#123;</span><br><span class="line">    if(stair &gt;= 40)</span><br><span class="line">        return ; // 如果到达40阶时为基线情况</span><br><span class="line"></span><br><span class="line">    if(stair==39 &amp;&amp; walk%2==0) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        return ;</span><br><span class="line">    &#125; // 上升39阶，并且步数为偶数，满足情况，方法数加一</span><br><span class="line"></span><br><span class="line">    up(stair+1,walk+1); // 向上走一步</span><br><span class="line">    up(stair+2,walk+1); // 向上走两步</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    up(0,0); // 初始条件</span><br><span class="line">    printf(&quot;一共有%d种方法&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>寻找子串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int func(char a[], char b[])</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int flag;</span><br><span class="line">    for(i=0;a[i]!=&#x27;\0&#x27;;i++) &#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">        for(j=i,k=0;b[k]!=&#x27;\0&#x27;;j++,k++) &#123;</span><br><span class="line">            if(a[j]!=b[k]) &#123;</span><br><span class="line">                flag = 0; </span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag &amp;&amp; b[k] == &#x27;\0&#x27;) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>蛇形矩阵</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int a[10][10] = &#123;0&#125;;</span><br><span class="line">    printf(&quot;Input n(n&lt;10): &quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">    int num = 1;</span><br><span class="line">    int top = 0;</span><br><span class="line">    int bottom = n - 1;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = n - 1;</span><br><span class="line"></span><br><span class="line">    while (num &lt;= n * n) &#123;</span><br><span class="line">        for (int j = left; j &lt;= right; j++) &#123;</span><br><span class="line">            a[top][j] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line"></span><br><span class="line">        for (int i = top; i &lt;= bottom; i++) &#123;</span><br><span class="line">            a[i][right] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">        for (int j = right; j &gt;= left; j--) &#123;</span><br><span class="line">            a[bottom][j] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--;</span><br><span class="line"></span><br><span class="line">        for (int i = bottom; i &gt;= top; i--) &#123;</span><br><span class="line">            a[i][left] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Snake matrix:\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            printf(&quot;%3d&quot;, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>拉丁矩阵</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i,j,t,n,m;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">t=i%n;//记录第i行的第一个元素</span><br><span class="line">for(j=0;j&lt;n;j++)&#123;</span><br><span class="line">m=(j+t)%n+1;</span><br><span class="line">printf(&quot;%d &quot;,m);//按照环形规律进行输出</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>逆序字符串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void reverse(char *s)</span><br><span class="line">&#123;     </span><br><span class="line">    char *t = s + strlen(s) - 1;</span><br><span class="line">    char temp;</span><br><span class="line"></span><br><span class="line">    while (s &lt;= t)</span><br><span class="line">    &#123;     </span><br><span class="line">        temp = *t;</span><br><span class="line">        *t = *s;</span><br><span class="line">        *s = temp;</span><br><span class="line">        s++;</span><br><span class="line">        t--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *func(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    char *start = s; // 指向s字符数组第一个字符</span><br><span class="line">    char *t = s + strlen(s) - 1; // 指向最后一个字符</span><br><span class="line">    char temp;</span><br><span class="line"></span><br><span class="line">    while( start&lt;t ) &#123;</span><br><span class="line">        temp = *t;</span><br><span class="line">        *t = *start;</span><br><span class="line">        *start = temp;</span><br><span class="line">        start++;</span><br><span class="line">        t--;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 代码记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全国艾滋病数据可视化分析</title>
      <link href="/2024/11/08/%E5%85%A8%E5%9B%BD%E8%89%BE%E6%BB%8B%E7%97%85%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90-README/"/>
      <url>/2024/11/08/%E5%85%A8%E5%9B%BD%E8%89%BE%E6%BB%8B%E7%97%85%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90-README/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Beatrueman/analysis">Beatrueman/analysis: A data visualization project related to HIV.</a></p><h1><strong>全国艾滋病数据可视化分析</strong></h1><h2 id="整体效果">整体效果</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410070052428.png" alt="image-20241007005222002"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410070053508.png" alt="image-20241007005358077"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410070100656.png" alt="image-20241007010047310"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410082259896.png" alt="image-20241008225909478"></p><h2 id="技术栈">技术栈</h2><p><em><strong>Python</strong></em>：使用<em>pandas</em>做数据处理，使用[<em>pyecharts</em>](<a href="https://pyecharts.org/#/zh-cn/intro">简介 - pyecharts - A Python Echarts Plotting Library built with love.</a>)做数据可视化生成，使用<em>flask</em>制作接口（用于根据年份更新对应的数据）</p><p>数据来源于<a href="https://www.phsciencedata.cn/Share/">公共卫生科学数据中心 (phsciencedata.cn)</a></p><p><em><strong>HTML + CSS  + JS</strong></em>：用于前端页面的渲染。</p><ul><li>使用<em>jQuery</em>库实现AJAX发送请求到服务器用来更新各年份对应的数据以及生成对应省份的3D图。</li><li>使用<em>Bootstrap</em>库实现图片的轮播以及3D模态框的展示。</li></ul><p>参考<a href="https://help.aliyun.com/zh/model-studio/use-cases/add-an-ai-assistant-to-your-website-in-10-minutes?spm=a2c4g.11186623.0.0.613365dfLQUfDC#80d3029cb9q06">10分钟在网站上增加一个AI助手</a>，利用[阿里云百炼](<a href="https://bailian.console.aliyun.com/?spm=a2c4g.11186623.0.0.12dc65dfmbl1gr#/home">阿里云百炼 (aliyun.com)</a>)，将通义千问接入项目，提供艾滋病相关知识的科普。</p><h3 id="接口介绍">接口介绍</h3><p><code>POST /update_year</code></p><p>传入前端选择框中的year，根据year执行对应的生成统计图表的Python文件。</p><p><code>GET /generate_3d_map</code></p><p>前端通过监听鼠标点击事件，识别用户点击的哪一个省份。将省份province传入该接口，province作为参数传入生成3D图的函数，生成对应省份的3D html文件到<code>fe/template/static/province</code></p><h3 id="逻辑介绍">逻辑介绍</h3><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410171524698.png" alt="image-20241017152422575"></p><h2 id="功能介绍">功能介绍</h2><h3 id="统计图展示">统计图展示</h3><p>整个页面展示了五个统计图</p><ul><li>饼图（Pie）：分年龄段展示本年艾滋病人数</li><li>象形柱状图（PictorialBar）：展示本年艾滋病全国发病数/死亡数前十名</li><li>折线图（Line）：2010-2020年全国发病率/死亡率走势图</li><li>地图（Map）：展示本年艾滋病全国分布情况</li><li>3D地图（Map3D）：展示每个省份的3D效果</li></ul><h3 id="根据年份更新数据">根据年份更新数据</h3><p>点击年份选择框，可以更新对应年份的数据。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410082254625.png" alt="image-20241008225445165"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410082255816.png" alt="image-20241008225503436"></p><h3 id="图片轮播">图片轮播</h3><p>页面中心有三张有关艾滋病科普知识的图片进行轮播。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410082255702.png" alt="image-20241008225552527"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410082256681.png" alt="image-20241008225603595"></p><h3 id="AI科普顾问">AI科普顾问</h3><p>点击右下角的小圆圈，可以调出AI（通义千问），用户可以与其对话，了解艾滋病的相关知识。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410082257072.png" alt="image-20241008225732685"></p><h3 id="3D省份展示">3D省份展示</h3><p>点击全国艾滋病分布情况中的任意省份，页面会弹出对应省份的3D图。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410082258562.png" alt="image-20241008225837981"></p><h2 id="部署">部署</h2><h3 id="Linux裸机部署">Linux裸机部署</h3><p><strong>环境</strong></p><ul><li>Python 3.11.2</li><li>node v18.19.0</li><li>Debian bookworm</li></ul><p>先安装依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure><p>然后运行<code>app.py</code>，期间保持其一直运行（建议制作service）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 app.py</span><br></pre></td></tr></table></figure><p>再进入<code>analysis/fe/template</code>，先安装依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>最后运行程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run dev -- --host</span><br></pre></td></tr></table></figure><p>整个程序的入口为以下这些IP</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202410091020708.png" alt="image-20241009102009641"></p><h3 id="Docker部署">Docker部署</h3><p>整个项目已打包为Docker镜像，并推送至仓库。</p><p><code>beatrueman/analisis:1.0.0</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 5173:5173 beatrueman/analisis:1.0.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Achievements </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRE-Web安全寒假考核(社工方向)</title>
      <link href="/2024/11/08/SRE-Web%E5%AE%89%E5%85%A8%E5%AF%92%E5%81%87%E8%80%83%E6%A0%B8(%E7%A4%BE%E5%B7%A5%E6%96%B9%E5%90%91)/"/>
      <url>/2024/11/08/SRE-Web%E5%AE%89%E5%85%A8%E5%AF%92%E5%81%87%E8%80%83%E6%A0%B8(%E7%A4%BE%E5%B7%A5%E6%96%B9%E5%90%91)/</url>
      
        <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230514174928066.png" alt="image-20230514174928066"></p><h2 id="QQ">QQ</h2><p><strong>3585956882</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea:</span><br><span class="line">后面两个==的特征知道是base64解码</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230115002718726.png" alt="image-20230115002718726"></p><h2 id="姓名">姓名</h2><p><strong>陈铁柱</strong></p><p>缩写是ctz</p><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230122174819232.png" alt="image-20230122174819232"></p><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230115003427596.png" alt="image-20230115003427596"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上网搜下Da2kSupr3m3找到了他的CSDN博客，通过简介，一段base64解码进入了他的博客</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230115005508634.png" alt="image-20230115005508634"></p><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230115005518323.png" alt="image-20230115005518323"></p><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230115005538566.png" alt="image-20230115005538566"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目录下有一个robots.txt</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230122185405421.png" alt="image-20230122185405421"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发现目录下有一个zip文件，下载发现要密码</span><br><span class="line">在 https://www.shentoushi.top下生成字典</span><br><span class="line">用ARCHPR进行密码爆破</span><br><span class="line">得密码是：CTZ2003.</span><br><span class="line">登录他的博客</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230122185926257.png" alt="image-20230122185926257"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入博客，发现一个彩蛋：</span><br><span class="line">彩蛋二：原来已经被学长渗透过了。。。redrock&#123;你向往的地方,别人已经进出自如&#125;</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230122191731510.png" alt="image-20230122191731510"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看文章，有一些私密文章，里面有一个是“这几年的四级成绩”，其中有一个zip</span><br><span class="line">解压后是一堆成绩表格</span><br><span class="line">查看，有几个名字的缩写都是ctz</span><br><span class="line">根据生日筛选（20031212）</span><br><span class="line">确定是陈铁柱</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230122193211171.png" alt="image-20230122193211171"></p><h2 id="身份证号">身份证号</h2><p><strong>372522200312120019</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据生日从上面顺便破解</span><br></pre></td></tr></table></figure><h2 id="电话">电话</h2><p><strong>13777777777</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">私密文章里找到一个聊天记录的博文</span><br><span class="line">打开，根据路径下载了一个zip但是有密码</span><br><span class="line">审计私密文章里的其他博文，找到解压密码为如下</span><br><span class="line">解开找到电话信息</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230122204358184.png" alt="image-20230122204358184"></p><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230122204139112.png" alt=""></p><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230122204415117.png" alt="image-20230122204415117"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">还找到了彩蛋五的信息</span><br><span class="line">打开路径</span><br><span class="line">但是不知道小区名字（估计是住在聊城）</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230122204615596.png" alt="image-20230122204615596"></p>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Achievements </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab CICD学习记录</title>
      <link href="/2024/11/08/Gitlab%20CICD%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/11/08/Gitlab%20CICD%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>用Flask在K8s集群编写后端项目</h1><h2 id="编写app-py"><a href="http://xn--app-y11em39r.py">编写app.py</a></h2><p>编写一个最简单的后端项目，<a href="http://xn--app-c88d89xgta.py">命名为app.py</a>，返回hello world!</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;hello world!&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(host=&#x27;0.0.0.0&#x27;, port=8080)</span><br></pre></td></tr></table></figure><h2 id="用pipreqs导出依赖文件">用pipreqs导出依赖文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pipreqs</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipreqs . --encoding=utf8 --force</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306072021854.png" alt="image-20230607202155815"></p><h2 id="构建Docker镜像">构建Docker镜像</h2><p>编写dockerfile</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM python:3.9</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY requirements.txt .</span><br><span class="line">RUN pip install --no-cache-dir -r requirements.txt</span><br><span class="line"></span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line">CMD [&quot;python&quot;,&quot;app.py&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t beatrueman/ci:2.0 .</span><br></pre></td></tr></table></figure><p>上传镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push beatrueman/ci:2.0</span><br></pre></td></tr></table></figure><h2 id="K8s集群部署后端服务">K8s集群部署后端服务</h2><p>使用命令创建Pod。创建一个名为<code>flask-hello-world</code>的Pod，并将容器的端口映射到主机的端口8080。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl run flask-hello-world --image=beatrueman/ci:2.0 --port=8080 </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306091401890.png" alt="image-20230609140113784"></p><p>使用命令暴露服务。以LoadBalancer类型创建服务，映射到Pod的8080端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl expose pod flask-hello-world --type=LoadBalancer --port=80 --target-port=8080</span><br></pre></td></tr></table></figure><p>查看服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get service flask-hello-world</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306091405595.png" alt="image-20230609140541562"></p><p>开放32091端口，访问外部ip</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306091406529.png" alt="image-20230609140631331"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306091406566.png" alt="image-20230609140646482"></p><p>成功</p><h1>安装runner</h1><h2 id="获取registration-token">获取registration-token</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306111745837.png" alt="image-20230611174544623"></p><h2 id="使用docker安装runner">使用docker安装runner</h2><h3 id="安装">安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">  -v /srv/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure><h3 id="注册">注册</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it gitlab-runner bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlab-runner register \</span><br><span class="line">--non-interactive \</span><br><span class="line">--url &quot;https://gitlab.com/&quot; \</span><br><span class="line">--registration-token &quot;GR1348941F_CsNBNspPP2DccgUVcx&quot; \ </span><br><span class="line">--executor &quot;docker&quot; \</span><br><span class="line">--docker-image ubuntu:22.04 \</span><br><span class="line">--description &quot;docker-runner&quot; \</span><br><span class="line">--maintenance-note &quot;Free-form maintainer notes about this runner&quot; \</span><br><span class="line">--tag-list &quot;docker&quot; \</span><br><span class="line">--run-untagged=&quot;true&quot; \</span><br><span class="line">--locked=&quot;false&quot; \</span><br><span class="line">--access-level=&quot;not_protected&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306102222902.png" alt="image-20230610222258752"></p><p>#一直把registration-token当成runner里的token了，导致后面不停报错</p><h2 id="使用helm安装runner（失败）">使用helm安装runner（失败）</h2><h3 id="下载package并解压">下载package并解压</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add gitlab https://charts.gitlab.io</span><br><span class="line">helm pull gitlab/gitlab-runner</span><br><span class="line">tar -zxvf gitlab-runner-0.53.2.tgz</span><br></pre></td></tr></table></figure><p>文件目录如下</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306092249669.png" alt="image-20230609224911559"></p><h3 id="配置token填入和docker鉴权">配置token填入和docker鉴权</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: gitlab-runner-secret</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line"># 配置runner的token</span><br><span class="line">  runner-registration-token: &quot;R1IxMzQ4OTQxRl9Dc05CTnNwUFAyRGNjZ1VWY3gK&quot; # 将token转为base64后写这里</span><br><span class="line">  runner-token: &quot;&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line"># 配置docker的config.json</span><br><span class="line">  .dockerconfigjson: &quot;ewogICAgICAgICJhdXRocyI6IHsKICAgICAgICAgICAgICAgICJodHRwczovL2luZGV4LmRvY2tlci5pby92MS8iOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICJhdXRoIjogIlltVmhkSEoxWlcxaGJqcHNlWGd3TXpBNU1UWT0iCiAgICAgICAgICAgICAgICB9CiAgICAgICAgfQp9Cgo=&quot;</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: regsecret</span><br><span class="line">type: kubernetes.io/dockerconfigjson</span><br></pre></td></tr></table></figure><h3 id="在values-yaml中应用配置文件">在values.yaml中应用配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlabUrl: https://gitlab.com/Beatrueman/test.git</span><br><span class="line"></span><br><span class="line">runners:</span><br><span class="line"># 在这里指定我们刚刚创建的secret</span><br><span class="line">  secret: gitlab-runner-secret</span><br><span class="line">  imagePullSecrets: regsecret</span><br><span class="line">  tags: &quot;k8s&quot;</span><br><span class="line">  config: |</span><br><span class="line">    [[runners]]</span><br><span class="line">      [runners.kubernetes]</span><br><span class="line">        namespace = &quot;&#123;&#123;.Release.Namespace&#125;&#125;&quot;</span><br><span class="line">        image = &quot;ubuntu:20.04&quot;</span><br></pre></td></tr></table></figure><h1>镜像上传</h1><h3 id="自定义kaniko镜像">自定义kaniko镜像</h3><p>提前在<strong>CI/CD &gt; Variables</strong>下设置好变量</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306112242506.png" alt="image-20230611224208441"></p><p>在<code>/root/kaniko</code>下编写dockerfile和build-upload</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306101524465.png" alt="image-20230610152445422"></p><p>dockerfile</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM lonewalkerchr/kaniko:debug</span><br><span class="line"></span><br><span class="line">COPY ./build-upload /kaniko/build-upload</span><br><span class="line"></span><br><span class="line">SHELL [&quot;/busybox/sh&quot;]</span><br><span class="line"></span><br><span class="line">RUN [&quot;/busybox/chmod&quot;, &quot;a+x&quot;, &quot;/kaniko/build-upload&quot;]</span><br></pre></td></tr></table></figure><p>build-upload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf &quot;%s&quot; &quot;$&#123;DOCKER_AUTH&#125;&quot; &gt; /kaniko/.docker/config.json</span><br><span class="line"></span><br><span class="line">/kaniko/executor \</span><br><span class="line">     --force \</span><br><span class="line">     --cache \</span><br><span class="line">     --context &quot;$&#123;CI_PROJECT_DIR&#125;&quot; \</span><br><span class="line">     --dockerfile dockerfile \</span><br><span class="line">     --destination $&#123;destination&#125;</span><br></pre></td></tr></table></figure><p>构建镜像并上传至dockerhub</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t beatrueman/kaniko:1.0 .</span><br><span class="line"></span><br><span class="line">docker push beatrueman/kaniko:1.0</span><br></pre></td></tr></table></figure><h1>上传代码</h1><h2 id="创建并配置-gitlab-ci-yaml">创建并配置.gitlab-ci.yaml</h2><p>添加KUBE_CONFIG变量，内容为<code>~/.kube/config</code>的内容</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306101537195.png" alt="image-20230610153746130"></p><p>创建并配置.gitlab-ci.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - deploy</span><br><span class="line"></span><br><span class="line">imagebuilder:</span><br><span class="line">  image: beatrueman/ci:kaniko</span><br><span class="line">  stage: build</span><br><span class="line">  variables:</span><br><span class="line">    destination: beatrueman/ci:2.0</span><br><span class="line">  script:</span><br><span class="line">    - /kaniko/build-upload</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  image: bitnami/kubectl</span><br><span class="line">  stage: deploy</span><br><span class="line">  script:</span><br><span class="line">    - echo $&#123;KUBE_CONFIG&#125; &gt; kubeconfig</span><br><span class="line">    - kubectl run flask-hello-world --image=beatrueman/ci:2.0 --port=8080 </span><br><span class="line">    - kubectl expose pod flask-hello-world --type=LoadBalancer --port=80 --target-port=8080</span><br></pre></td></tr></table></figure><h2 id="上传到仓库">上传到仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &quot;first&quot;</span><br><span class="line"></span><br><span class="line">git remote add origin https://gitlab.com/Beatrueman/test-ci.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306101557295.png" alt="image-20230610155728095"></p><h1>问题与解决</h1><p>1.构建Docker镜像时CMD的时候少了一个后引号，折腾了半天。#感谢一下杨鑫同学了，多亏了他的慧眼。</p><p>2.安装runner时用的是registration-token，不是创建runner时候的token。</p><p>3.${CI_PROJECT_DIR}变量是自带的，是runner里面的一个不固定的位置，可以通过它来找到绝对路径，不能自行指定，不然会找不到文件导致报错。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306121103792.png" alt="image-20230612110258681"></p><ol start="4"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>pip安装的时候使用-i指定镜像源，下载速度会提升很多很多。</p><p>5…gitlab-ci.yaml里deploy加entrypoint覆盖。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306112238626.png" alt="image-20230611223818531"></p><p>6…gitlab-ci.yaml里deploy阶段执行kubectl命令建议每条命令都加–kuboeconfig=./kubeconfig，保证每条命令都有权限。</p>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> Gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s实践记录</title>
      <link href="/2024/11/08/k8s%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/11/08/k8s%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>Level 0</h1><h2 id="1-在节点上创建一个持久化目录">1.在节点上创建一个持久化目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/nginx/logs #创建多级目录</span><br><span class="line">chmod 777 /data/nginx/logs #为系统上的每个人提供读、写和执行权限</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031235760.png" alt="image-20230505201330833"></p><h2 id="2-创建一个nginx-pod，并在其中配置一个存储卷来将持久化目录挂载到Pod的-var-log-nginx目录中。">2.创建一个nginx pod，并在其中配置一个存储卷来将持久化目录挂载到Pod的<code>/var/log/nginx</code>目录中。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: nginx-logs</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /data/nginx/logs</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: nginx-logs</span><br><span class="line">      mountPath: /var/log/nginx</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031240022.png" alt="image-20230505202801965"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031240035.png" alt="image-20230505203138463"></p><h2 id="3-配置nginx日志保存到指定的目录">3.配置nginx日志保存到指定的目录</h2><p>在nginx配置文件nginx.conf中添加以下配置,将nginx访问日志保存到<code>/var/log/nginx/access.log</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```nginx</span><br><span class="line">http &#123;</span><br><span class="line">    access_log /var/log/nginx/access.log main;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031241179.png" alt="image-20230506165104587"></p><h2 id="4-验证日志持久化">4.验证日志持久化</h2><p>外部访问nginx，在<code>/data/nginx/logs/access.log</code>中保存了访问记录</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031241368.png" alt="image-20230506175652140"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031241644.png" alt="image-20230506175706336"></p><p>进入容器内部，检查日志是否保存在<code>/var/log/nginx/access.log</code>中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl exec -it nginx bash</span><br><span class="line">tail /var/log/nginx/access.log</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031241184.png" alt="image-20230506175903226"></p><p>成功记录</p><h1>Level 1</h1><h2 id="安装NFS服务端">安装NFS服务端</h2><h3 id="1-在主机上安装NFS服务器">1.在主机上安装NFS服务器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y nfs-utils rpcbind</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031241639.png" alt="image-20230507113416717"></p><h3 id="2-创建NFS共享目录并设置权限">2.创建NFS共享目录并设置权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/nfs_logs</span><br><span class="line">chmod 777 /opt/nfs_logs</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031241298.png" alt="image-20230507114113361"></p><h3 id="3-编辑-etc-exports文件，添加NFS共享目录">3.编辑<code>/etc/exports</code>文件，添加NFS共享目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/nfs_logs *(rw,sync,no_subtree_check,no_root_squash)</span><br><span class="line">#rw代表读写访问，sync代表所有数据在请求时写入共享，no_subtree_check代表不检查父目录权限，no_root_squash代表root 用户具有根目录的完全管理访问权限</span><br></pre></td></tr></table></figure><p><img src="../../../AppData/Roaming/Typora/typora-user-images/image-20230507114620628.png" alt="image-20230507114620628"></p><h3 id="4-重启NFS服务器并检查配置结果">4.重启NFS服务器并检查配置结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable rpcbind</span><br><span class="line">systemctl enable nfs-server</span><br><span class="line"></span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl start nfs-server</span><br><span class="line">exportfs -r</span><br><span class="line"></span><br><span class="line">exportfs</span><br></pre></td></tr></table></figure><p><img src="../../../AppData/Roaming/Typora/typora-user-images/image-20230507120545675.png" alt="image-20230507120545675"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031241063.png" alt="image-20230507120704971"></p><h2 id="配置基于NFS的持久卷">配置基于NFS的持久卷</h2><h3 id="1-创建持久卷">1.创建持久卷</h3><p>编写pv.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pv-logs</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  storageClassName: nfs</span><br><span class="line">  nfs:</span><br><span class="line">    server: 172.23.0.239</span><br><span class="line">    path: /opt/nfs_logs</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031241605.png" alt="image-20230507200907759"></p><h3 id="2-创建持久卷声明">2.创建持久卷声明</h3><p>编写pvc.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pvc-logs</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br><span class="line">  storageClassName: nfs</span><br></pre></td></tr></table></figure><p><img src="../../../AppData/Roaming/Typora/typora-user-images/image-20230507201804745.png" alt="image-20230507201804745"></p><h3 id="3-将PVC和PV绑定">3.将PVC和PV绑定</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl patch pvc nfs-pvc-logs -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;volumeName&quot;:&quot;nfs-pv-logs&quot;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242330.png" alt="image-20230507201943022"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242190.png" alt="image-20230507214419776"></p><h2 id="将持久卷声明挂载到nginx容器">将持久卷声明挂载到nginx容器</h2><p>编写nginx-pv.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-pv</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">      - containerPort: 80</span><br><span class="line">        name: nginx-server</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: nfs-pvc-logs</span><br><span class="line">      mountPath: /var/log/nginx</span><br><span class="line">  volumes:</span><br><span class="line">  - name: nfs-pvc-logs</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: nfs-pvc-logs</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242509.png" alt="image-20230507214606997"></p><h2 id="验证是否存储日志">验证是否存储日志</h2><p>外部访问nginx，在<code>/opt/nfs_logs/access.log</code>查看日志</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242917.png" alt="image-20230507214940596"></p><p>成功记录</p><h2 id="遇到的问题">遇到的问题</h2><p>（感谢杨鑫同学）</p><p>#编写pv.yaml时候，要把nfs server的ip地址写到NFS服务器的私网ip</p><p>写成公网ip，最后创建pod的时候，pod状态一直是ContainerCreating，超时了</p><p>用kubectl describe出现以下报错</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242105.png" alt="image-20230507215347502"></p><p>翻译：</p><p>挂载命令：挂载</p><p>装载参数：-t nfs 8.130.111.175:/opt/nfs_logs/var/lib/kubelet/pods/d0abb5e10c87-490f-85dd-be3d00478462/volumes/kubernetes.io~nfs/nfs pv-logs</p><p>输出：mount.nfs:连接超时</p><p>警告失败mount 13m（x3超过18m）kubelet无法连接或装载卷：未安装的卷=[nfs pvc logs]，未连接的卷=[nfs pvc logs kube-api-access-6wfbh]：等待条件超时</p><p>#还有一个就是服务器好卡，重启了好多遍😭😭😭</p><h1>Level 2</h1><p>思路:</p><p>(前提)在NFS服务器上创建好共享目录</p><p>1.为mysql创建PV和PVC并绑定</p><p>2.创建mysql的Deployment和Service</p><p>3.创建wordpress的Deployment和Service</p><p>参考:<a href="https://blog.csdn.net/liaomingwu/article/details/124289352"> Kubernetes(k8s)1.6.0部署 WordPress以及hpa和滚动更新测试_k8s部署wordpress_程序猿（攻城狮）的博客-CSDN博客</a></p><h2 id="创建命名空间">创建命名空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create namespace wordpress</span><br></pre></td></tr></table></figure><p><img src="../../../AppData/Roaming/Typora/typora-user-images/image-20230511094837257.png" alt="image-20230511094837257"></p><h2 id="部署MySQL">部署MySQL</h2><h3 id="1-创建MySQL的PV和PVC并绑定">1.创建MySQL的PV和PVC并绑定</h3><p>编写mysql-pv.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql-pv</span><br><span class="line">  namespace: wordpress</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  persistentVolumeReclaimPolicy: Recycle</span><br><span class="line">  nfs:</span><br><span class="line">    path: /root/data/nfs/pv #共享目录</span><br><span class="line">    server: 124.221.233.12 #nfs服务器</span><br></pre></td></tr></table></figure><p>编写mysql-pvc.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: mysqlpvc</span><br><span class="line">  namespace: wordpress</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  volumeName: mysql-pv</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242809.png" alt="image-20230511183056018"></p><h3 id="2-创建MySQL的Deployment">2.创建MySQL的Deployment</h3><p>编写mysql-deploy.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql-deploy</span><br><span class="line">  namespace: wordpress</span><br><span class="line">  labels:</span><br><span class="line">    apps: mysql</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: mysql</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: mysql</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: mysql</span><br><span class="line">        image: mysql:5.6</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 3306</span><br><span class="line">          name: dbport</span><br><span class="line">        env:</span><br><span class="line">        - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">          value: rootPassWord</span><br><span class="line">        - name: MYSQL_DATABASE</span><br><span class="line">          value: wordpress</span><br><span class="line">        - name: MYSQL_USER</span><br><span class="line">          value: wordpress</span><br><span class="line">        - name: MYSQL_PASSWORD</span><br><span class="line">          value: wordpress</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: db-pv</span><br><span class="line">          mountPath: /var/lib/mysql</span><br><span class="line">      volumes:</span><br><span class="line">      - name: db-pv</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: mysqlpvc</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242536.png" alt="image-20230511183035050"></p><h3 id="3-创建MySQL的Service">3.创建MySQL的Service</h3><p>编写mysql-service-yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql</span><br><span class="line">  namespace: wordpress</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: mysql</span><br><span class="line">  ports:</span><br><span class="line">  - name: mysqlport</span><br><span class="line">    protocol: TCP</span><br><span class="line">    port: 3306</span><br><span class="line">    targetPort: 3306</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242194.png" alt="image-20230511101848905"></p><h2 id="部署WordPress">部署WordPress</h2><h3 id="1-创建WordPress的Deployment">1.创建WordPress的Deployment</h3><p>编写wordpress-deploy.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: wordpress-deploy</span><br><span class="line">  namespace: wordpress</span><br><span class="line">  labels:</span><br><span class="line">    app: wordpress</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: wordpress</span><br><span class="line">  strategy:</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 50%</span><br><span class="line">      maxUnavailable: 0</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: wordpress</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: wordpress</span><br><span class="line">        image: wordpress</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: wdport</span><br><span class="line">        env:</span><br><span class="line">        - name: WORDPRESS_DB_HOST</span><br><span class="line">          value: mysql:3306</span><br><span class="line">        - name: WORDPRESS_DB_USER</span><br><span class="line">          value: wordpress</span><br><span class="line">        - name: WORDPRESS_DB_PASSWORD</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242144.png" alt="image-20230511183029938"></p><h3 id="2-创建WordPress的Service">2.创建WordPress的Service</h3><p>编写wordpress-service.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: wordpress</span><br><span class="line">  namespace: wordpress</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app: wordpress</span><br><span class="line">  ports:</span><br><span class="line">  - name: wordpressport</span><br><span class="line">    protocol: TCP</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: wdport</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242387.png" alt="image-20230511102907462"></p><h2 id="访问-失败">访问(失败)</h2><p>访问<a href="http://124.221.233.12:31585">http://124.221.233.12:31585</a></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242176.png" alt="image-20230511110657765"></p><h2 id="遇到的问题-v2">遇到的问题</h2><p><img src="C:%5CUsers%5C%E6%9D%8E%E9%80%B8%E9%9B%84%5CDesktop%5Cimg_v2_a7f0a3af-db1a-4f03-9d09-c2064a4856bg_MIDDLE_WEBP.jpg" alt="img_v2_a7f0a3af-db1a-4f03-9d09-c2064a4856bg_MIDDLE_WEBP"></p><p>一切都是Running但是还是访问不了</p><h1>Level 6</h1><p>参考:<a href="https://blog.csdn.net/rookie23rook/article/details/114843084">Helm:使用helm部署nginx_helm 部署nginx_zJayLiao的博客-CSDN博客</a></p><p>​        <a href="https://www.cnblogs.com/klvchen/p/13606311.html">Helm templates 中的语法 - klvchen - 博客园 (cnblogs.com)</a></p><p>​        <a href="https://helm.sh/zh/docs/">Helm | Docs</a></p><h2 id="安装helm">安装helm</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://download.osichina.net/tools/k8s/helm/helm-v3.3.1-linux-amd64.tar.gz </span><br><span class="line">cd /opt/helm/</span><br><span class="line">tar zxvf helm-v3.3.1-linux-amd64.tar.gz</span><br><span class="line">cp helm /usr/local/bin</span><br><span class="line">chmod a+x /usr/local/bin/helm</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242146.png" alt="image-20230512205502215"></p><h2 id="创建配置文件和目录">创建配置文件和目录</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242972.png" alt="image-20230512213552003"></p><h3 id="Chart-yaml">Chart.yaml</h3><p><em>Chart</em> 代表着 Helm 包。它包含在 Kubernetes 集群内部运行应用程序，工具或服务所需的所有资源定义。你可以把它看作是 Homebrew formula，apt dpkg，或 yum rpm 在Kubernetes 中的等价物。</p><p>这里定义了chart的基本信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v2</span><br><span class="line">name: nginx</span><br><span class="line">description: A Helm chart for deploying Nginx</span><br><span class="line">version: 0.1.0</span><br></pre></td></tr></table></figure><h3 id="values-yaml">values.yaml</h3><p><code>values.yaml</code>用于定义Nginx服务的各种配置选项，如部署Pod的副本数、容器的镜像、端口号、卷的挂载等等。使用<code>values.yaml</code>文件，用户可以轻松灵活地配置并定制Nginx服务的各种参数，以满足他们在不同环境中的需求，在不同集群上部署Nginx服务，而无需重新编写Helm Chart的模板文件。</p><p>相当于定义了一些变量，可以在后面的文件中进行引用。</p><p>镜像拉取策略<em>pullpolicy</em></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031242924.png" alt="image-20230512214604149"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replicaCount: 1 #Pod副本数</span><br><span class="line">image: #容器镜像</span><br><span class="line">  repository: nginx </span><br><span class="line">  tag: latest</span><br><span class="line">  pullPolicy: IfNotPresent #镜像拉取策略为IFNotPresent</span><br><span class="line">service:</span><br><span class="line">  type: ClusterIP #service的类型</span><br><span class="line">  port: 80</span><br></pre></td></tr></table></figure><h3 id="deployment-yaml">deployment.yaml</h3><p><code>deployment.yaml</code>是用来定义Nginx的部署资源的文件，它描述了Nginx的副本数，容器镜像，端口映射，环境变量，健康检查等信息.它还可以指定Nginx的服务类型，负载均衡器，安全组等。</p><p>和平常普通的deployment基本相似。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; include &quot;nginx.fullname&quot; . &#125;&#125; #引用模板，格式：&#123;&#123; include &quot;模版名字&quot; 作用域&#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    app: &#123;&#123; include &quot;nginx.name&quot; . &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount &#125;&#125; #Values代表的就是values.yaml定义的参数，通过.Values可以引用任意参数</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: &#123;&#123; include &quot;nginx.name&quot; . &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: &#123;&#123; include &quot;nginx.name&quot; . &#125;&#125;</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: nginx</span><br><span class="line">          image: &#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;</span><br><span class="line">          imagePullPolicy: &#123;&#123; .Values.image.pullPolicy &#125;&#125;</span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: 80</span><br></pre></td></tr></table></figure><h3 id="service-yaml">service.yaml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; include &quot;nginx.fullname&quot; . &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    app: &#123;&#123; include &quot;nginx.name&quot; . &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  type: &#123;&#123; .Values.service.type &#125;&#125;</span><br><span class="line">  ports:</span><br><span class="line">    - name: http</span><br><span class="line">      port: &#123;&#123; .Values.service.port &#125;&#125;</span><br><span class="line">      targetPort: http</span><br><span class="line">  selector:</span><br><span class="line">    app: &#123;&#123; include &quot;nginx.name&quot; . &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="helpers-tpl">_helpers.tpl</h3><p>扩展名是<code>.tpl</code>可用于生成非格式化内容的模板文件</p><p>定义的模板(在<code>&#123;&#123; define &#125;&#125;</code>命令中定义的模板)是可全局访问的。这就意味着chart和所有的子chart都可以访问用<code>&#123;&#123; define &#125;&#125;</code>创建的所有模板。</p><p><em>Release</em> 是运行在 Kubernetes 集群中的 chart 的实例。一个 chart 通常可以在同一个集群中安装多次。每一次安装都会创建一个新的 <em>release</em>。以 MySQL chart为例，如果你想在你的集群中运行两个数据库，你可以安装该chart两次。每一个数据库都会拥有它自己的 <em>release</em> 和 <em>release name</em>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;/* 返回部署名称 */&#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;nginx.fullname&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- printf &quot;%s-%s&quot; .Release.Name &quot;nginx&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;/* 返回应用名称 */&#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;nginx.name&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- &quot;nginx&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="验证-失败">验证(失败)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm package nginx #打包</span><br><span class="line"></span><br><span class="line">helm install nginx ./nginx-0.1.0.tgz #安装</span><br></pre></td></tr></table></figure><h2 id="遇到的问题-v3">遇到的问题</h2><p>当用helm打包时报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm package nginx</span><br><span class="line">Error: validation: chart.metadata is required</span><br></pre></td></tr></table></figure><h1>Level 7</h1><p>参考:<a href="https://v2-1.docs.kubesphere.io/docs/zh-CN/installation/install-on-k8s/">在 Kubernetes 安装 KubeSphere | KubeSphere Documents</a></p><p>​         <a href="https://kuboard.cn/install/v3/install-built-in.html#%E9%83%A8%E7%BD%B2%E8%AE%A1%E5%88%92">安装 Kuboard v3 - 内建用户库 | Kuboard</a></p><p>​         [Kuboard-Spray 图形化工具安装kubernetes集群_kubernetes图形化工具_一只懒惰的猿的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_42418589/article/details/129806729#:~:text=kubernetes%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94">https://blog.csdn.net/weixin_42418589/article/details/129806729#:~:text=kubernetes系列（一）———</a> Kuboard-Spray,图形化工具安装kubernetes集群 完整安装k8s集群过程。)</p><h2 id="部署KubeSphere-失败">部署KubeSphere(失败)</h2><p>最小化安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubesphere/ks-installer/v2.1.1/kubesphere-minimal.yaml</span><br></pre></td></tr></table></figure><p>查看Pod状态</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pod --all-namespaces</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243197.png" alt="image-20230509173316688"></p><h2 id="用Kuboard-Spray安装K8s并部署Kuboard">用Kuboard-Spray安装K8s并部署Kuboard</h2><h3 id="1-安装docker-ce">1.安装docker-ce</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> yum-config-manager \</span><br><span class="line">&gt;     --add-repo \</span><br><span class="line">&gt;     https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum update</span><br><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="2-安装Kuboard-Spray">2.安装Kuboard-Spray</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --privileged \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  --name=kuboard-spray \</span><br><span class="line">  -p 80:80/tcp \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  -v ~/kuboard-spray-data:/data \</span><br><span class="line">  eipwork/kuboard-spray:latest-amd64</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243607.png" alt="image-20230509215057597"></p><p>安装完成后访问<a href="https://8.130.175.111">https://8.130.175.111</a>,用户名<code>admin</code>,默认密码 <code>Kuboard123</code>，即可登录 Kuboard-Spray 界面。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243531.png" alt="image-20230509215252089"></p><h3 id="3-下载资源包">3.下载资源包</h3><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243010.png" alt="image-20230509215538378"></p><h3 id="4-创建集群并选择各自的角色">4.创建集群并选择各自的角色</h3><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243836.png" alt="image-20230510164051772"></p><h3 id="5-安装K8s集群">5.安装K8s集群</h3><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243882.png" alt="image-20230510220945628"></p><p>安装成功</p><h3 id="6-部署Kuboard">6.部署Kuboard</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  --name=kuboard \</span><br><span class="line">  -p 80:80/tcp \</span><br><span class="line">  -p 10081:10081/tcp \</span><br><span class="line">  -e KUBOARD_ENDPOINT=&quot;http://10.0.4.12:80&quot; \</span><br><span class="line">  -e KUBOARD_AGENT_SERVER_TCP_PORT=&quot;10081&quot; \</span><br><span class="line">  -v /root/kuboard-data:/data \</span><br><span class="line">  eipwork/kuboard:v3</span><br></pre></td></tr></table></figure><p>访问<a href="http://124.221.233.12/:80">http://124.221.233.12/:80</a></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243978.png" alt="image-20230511000800630"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243074.png" alt="image-20230511001156003"></p><p>成功</p><h2 id="遇到的问题-v4">遇到的问题</h2><p>部署KubeSphere时报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-install -o jsonpath=&#x27;&#123;.items[0].metadata.name&#125;&#x27;) -f</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243196.png" alt="image-20230509174545142"></p><p>提示版本不支持</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl version</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243339.png" alt="image-20230509174623335"></p><p>版本是v1.25.0,按照官方文档提示应该是可以的</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031243693.png" alt="image-20230509174718089"></p><p>不知道为啥</p>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EasyBanner-README</title>
      <link href="/2024/11/08/EasyBanner-README/"/>
      <url>/2024/11/08/EasyBanner-README/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Beatrueman/EasyBanner">Beatrueman/EasyBanner: 通过飞书机器人对特定机器远程封禁恶意IP</a></p><h2 id="功能介绍">功能介绍</h2><p><strong>通过<code>@机器人</code>来触发飞书机器人对特定机器远程封禁恶意IP，依赖于<a href="https://github.com/evilsp/xdp_banner">GitHub - evilsp/xdp_banner: 一个简单的 XDP 小程序，用于 BAN IP</a></strong></p><p>1.当机器人未连接服务器时，提示如下消息。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408271741464.png" alt="image-20240827174105360"></p><p>2.当未发现访问次数超过250次的IP，提示如下消息。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408271741444.png" alt="image-20240827174159408"></p><p>3.当发现访问次数超过250次的恶意IP，罗列出恶意IP以及对应的访问次数，并显示封禁BAN按钮。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408271743440.png" alt="image-20240827174315387"></p><p>点击按钮，可以对远程机器进行封禁恶意IP，然后卡片更新，提示封禁完成。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408271744269.png" alt="image-20240827174403213"></p><h2 id="逻辑介绍">逻辑介绍</h2><h3 id="接口">接口</h3><p>目标机器开放两个接口</p><ul><li>GET /execute：用于查询日志里当前小时内访问量排名前十的IP以及对应的次数。</li><li>POST /ban：用于接收需要封禁的IP，然后执行xdp封禁命令。</li></ul><p>机器人设置两个接口</p><ul><li>POST /webhook：用来处理接收消息事件。</li><li>POST /event：用来处理卡片回调</li></ul><h3 id="运行逻辑">运行逻辑</h3><p>用户给机器人发消息，触发<code>接收消息v2.0</code>事件，飞书服务器返回消息体，通过消息体里<code>messageBody.Event.Message.Mentions</code>的<code>mention.ID.UserID</code>是否为空来判断用户发的消息是否为@机器人，不是则忽略。</p><p>是则发送卡片消息。这时调用目标机器<code>/execute</code>接口来获得IP以及对应的次数，通过判断 ip 次数，发送不同的模板。</p><p>没有返回数据，则发送未连接服务器模板。有返回数据但没有大于250次的IP，返回未检测到恶意IP模板。</p><p>有返回数据且有大于250次的IP时，获取所有次数大于250次的IP以及对应的次数动态填充至 JSON 模板，然后发送。</p><p>此时用户点击红色按钮BAN，会触发<code>卡片回传交互</code>事件，此时会回传数据。接下来对回传消息体进行一些判断：</p><ol><li>判断<code>event_type</code>是否为<code>card.action.trigger</code></li><li>判断<code>action.Tag</code>是否为<code>button</code></li><li>判断<code>action.Value</code>中键<code>action</code>对应的值是否为<code>ban_ip</code></li></ol><p>如果全部满足，则将需要封禁的IP制作成请求体，对目标机器<code>POST /ban</code>进行调用。</p><p>API成功调用后，调用飞书<code>更新卡片</code>API，对卡片内容进行更新。</p><h2 id="部署">部署</h2><h3 id="申请机器人">申请机器人</h3><h4 id="app-id与app-secret获取方法"><em>app_id</em>与<em>app_secret</em>获取方法</h4><p>1.用企业账户，在开发者后台中，<strong>创建企业自建应用</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202307311843815.png" alt="image-20230731184331697"></p><p>2.找到app_id与qpp_secret</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408272029722.png" alt="image-20230731184507412"></p><p>3.添加应用能力，选择机器人</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408272029399.png" alt="image-20230731184549009"></p><p>4.添加以下权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">im:message,im:message.group_at_msg,im:message.group_at_msg:readonly,im:message.group_msg,im:message.p2p_msg,im:message.p2p_msg:readonly,im:message:readonly,im:chat:readonly,im:chat,im:message:send_as_bot</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408272029978.png" alt="image-20230731184637236"></p><p>5.订阅<strong>接收消息</strong>和<strong>卡片回传交互</strong></p><p>若要使机器人有互动对话功能，需要填写请求配置地址，并添加<strong>接收消息v2.0</strong>和<strong>消息已读v2.0</strong>事件</p><p>卡片交互需要订阅<strong>卡片回传交互</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408272032499.png" alt="image-20240827203202358"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408272032804.png" alt="image-20240827203244721"></p><h3 id="裸机部署">裸机部署</h3><p>首先需要在目标机器上执行<code>EasyBanner/pkgs/data/app_current.py</code>，保持其稳定运行。</p><p>最好将其制作成Service，保证后台持久运行。</p><p>这里提供<code>get_ip.service</code>文件供参考。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit] </span><br><span class="line">Description=Get IP Service </span><br><span class="line">After=network.target </span><br><span class="line">[Service] </span><br><span class="line">User=root </span><br><span class="line">WorkingDirectory=/root/yiiong/get_ip  # app_current.py所在目录</span><br><span class="line">Environment=&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">ExecStart=/bin/bash -c &#x27;source /root/yiiong/get_ip/venv/bin/activate &amp;&amp; exec python3 app_current.py&#x27;  # 运行Python程序，注意文件路径</span><br><span class="line">Restart=always </span><br><span class="line">[Install] </span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>或者手动运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 ../EasyBanner/pkgs/data/app_current.py</span><br></pre></td></tr></table></figure><p>然后下载依赖后，运行<code>main.go</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go mod tidy</span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure><h3 id="Docker部署">Docker部署</h3><p>目标机器的API只能裸机部署</p><p>容器启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 \</span><br><span class="line">-e APP_ID=cli_a42011585561100d \ # 填写飞书应用 AppID</span><br><span class="line">-e APP_SECRET=AYRFbDlUH8OKxRweuXM47cLLFwRpO12X \ # 填写飞书应用 AppSecret</span><br><span class="line">-e URL=http://172.20.14.2:9521 \  # 填写检测主机地址</span><br><span class="line">-e GIN_MODE=release beatrueman/easybanner:stable</span><br></pre></td></tr></table></figure><h3 id="Kubernetes部署">Kubernetes部署</h3><p>先创建<code>Secret</code>设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic easybanner-secret \</span><br><span class="line">--from-literal=App_ID=your_AddID \</span><br><span class="line">--from-literal=App_Secret=your_AppSecret \</span><br><span class="line">--from-literal=URL=your_url \</span><br><span class="line">--from-literal=GIN_MODE=release \ # 设置gin为生产模式</span><br><span class="line">--namespace=your_namespace</span><br></pre></td></tr></table></figure><p>然后<code>apply</code>…/deply目录下的<code>deployment.yaml</code>，<code>service.yaml</code>。</p><p>所有注意修改命名空间。</p><p>还有要<strong>注意部署的机器人与目标机器接口的通信问题</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply deployment.yaml</span><br><span class="line">kuectl apply service.yaml</span><br><span class="line"></span><br><span class="line"># 如果有域名需求，还可以添加ingressroute或者ingress，注意修改host</span><br><span class="line"># 这里使用ingressroute</span><br><span class="line">kubectl apply -f ingressroute.yaml</span><br></pre></td></tr></table></figure><h2 id="缺陷">缺陷</h2><ul><li>机器人可能会重复发送消息。</li><li>因为会对大日志文件利用bash进行查询，所以执行<code>GET /execute</code>速度会比较慢，测试大概会消耗20s左右。</li><li>BAN操作比较慢，需要等待一会才能更新卡片。</li></ul><h2 id="更新日志">更新日志</h2><h3 id="2024-9-15">2024/9/15</h3><p>添加了用于打包和推送镜像的<strong>Github Action</strong></p><p>使用时在Settings &gt;&gt; Secrets and varibles &gt;&gt; Actions中添加secrets</p><p><code>REGISTRY_USERNAME</code>和<code>REGISTRY_PASSWORD</code></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202409150029068.png" alt="image-20240915002948963"></p><p>如果要推送到类似Harbor的自建仓库，请添加varibles</p><p><code>IMAGE_REGISTRY_SERVICE</code>：<a href="http://xn--docker-vy7ip603bdepb.io">默认为docker.io</a></p><p><code>IMAGE_REPOSITORY</code>：默认为beatrueman/eaesybanner</p><p>推送时请指定<strong>tag</strong>，格式为<code>v1.0.0</code>，用于指定镜像版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag v1.0.0</span><br><span class="line">git push origin v1.0.0</span><br></pre></td></tr></table></figure><p>或者手动指定<strong>tag</strong></p>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Achievements </tag>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022红岩杯WriteUp</title>
      <link href="/2024/11/08/2022%E7%BA%A2%E5%B2%A9%E6%9D%AFWriteUp/"/>
      <url>/2024/11/08/2022%E7%BA%A2%E5%B2%A9%E6%9D%AFWriteUp/</url>
      
        <content type="html"><![CDATA[<h1>PWN</h1><h2 id="一口一个flag">一口一个flag</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">nc一下下</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea：</span><br><span class="line">根据提示，nc是linux的命令，所以本题需要在linux环境求解</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step：</span><br><span class="line">打开Linux的终端，nc所给的端口</span><br><span class="line">输入：nc 172.20.14.18 31751</span><br><span class="line">得到答案：</span><br><span class="line">redrock&#123;Ech0eCHo-IWaNtF10g_&#125;</span><br></pre></td></tr></table></figure><p><img src="D:/%E4%B8%8B%E8%BD%BD%E6%96%87%E6%A1%A3/%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/MobileFile/1668940725261.jpg" alt="1668940725261"></p><h2 id="猫猫flag">猫猫flag</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">nc二下下</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea:</span><br><span class="line">本题与上题类似</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step:</span><br><span class="line">nc端口后无回显，继续输入指令</span><br><span class="line">ls后出现flag</span><br><span class="line">然后cat flag</span><br><span class="line">得到答案:</span><br><span class="line">redrock&#123;SEhLlCAT_IWaNtf1a9_&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031244591.jpg" alt="1668941030223"></p><h1>Web</h1><h2 id="你是哪里的">你是哪里的</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">https://96a84eec-4f7b-45a6-a5bb-224f1064604e.ctf.redrock.team/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea:</span><br><span class="line">进入第一层网页，显示（you must be from https://redrock.team）</span><br><span class="line">没什么破绽，按下F12,F5刷新一下，点进网页</span><br><span class="line">显示（A word in the http message header is wrong,do you know?），按下F12并刷新依然没有什么破绽，于是想到用Burpsuite进行抓包</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step：</span><br><span class="line">打开burpsuite，进行抓包，根据题目的暗示（你来自哪里），联想到来自https://redrock.team</span><br><span class="line">于是添加Referer：https://redrock.team后send</span><br><span class="line">找到答案：</span><br><span class="line">redrock&#123;we1c0me t0 redr0ck ctf&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031244222.png" alt="image-20221120185713998"></p><h2 id="RemindYourHead">RemindYourHead</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">https://19ab54b4-79ea-469a-b457-f79ca700a343.ctf.redrock.team/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea：</span><br><span class="line">点击网页发现是被黑了的网站，按下F12并刷新，没有什么破绽</span><br><span class="line">于是想到抓包</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step：</span><br><span class="line">用Burpsuite抓包，直接找到答案</span><br><span class="line">得到答案：</span><br><span class="line">redrock&#123;d95c187c-df9d-463f-80e2-8eea94e73595&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031244947.png" alt="image-20221120190433399"></p><h1>Misc</h1><h2 id="签到">签到</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">微信公众号关注 &quot;重邮小帮手&quot;, 发送 &quot;红岩杯CTF&quot;, 获得 flag</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">得到答案：</span><br><span class="line">redrock&#123;020408&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031244027.png" alt="image-20221120190708903"></p><h2 id="啵啵的魔法药水">啵啵的魔法药水</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">魔法世界里的小魔女啵啵找不到她的魔法药水了，快来帮帮她ヾ(′▽‘)ﾉ 进入魔法世界需要一点点魔力呢</span><br><span class="line"></span><br><span class="line">° (๑˘ ˘๑) ♥啵啵给你的小tips：用docker run &#x27;bobo&#x27; 可以短暂的打开进入魔法世界的大门</span><br><span class="line"></span><br><span class="line">【拉取镜像的咒语：docker pull wgyao/redrock-ctf:bobo】</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea:</span><br><span class="line">根据提示，本题需要用到docker。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step：</span><br><span class="line">载后在cmd命令行里输入</span><br><span class="line">docker pull wgyao/redrock-ctf:bobo</span><br><span class="line">然后在dockers的Image里，找到wgyao/redrock-ctf后点进，发现第21行出现了答案</span><br><span class="line">然后点击右边Command</span><br><span class="line">得到答案：</span><br><span class="line">redrock&#123;Wit-Sharpening_Potion.&#125;</span><br></pre></td></tr></table></figure><p>![屏幕截图 2022-11-20 191047](C:\Users\李逸雄\Desktop\屏幕截图 2022-11-20 191047.png)</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031244798.png" alt="image-20221120191324740"></p><h2 id="流量审计">流量审计</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">点击就送flag</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea：</span><br><span class="line">下载附件，发现.pcapng类型文件需要用Wireshark打开</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step：</span><br><span class="line">用Wireshark打开，发现有线索</span><br><span class="line">下面有text/plain，然后点进</span><br><span class="line">在最后找到答案：</span><br><span class="line">redrock&#123;yyz_is_god&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031245429.png" alt="image-20221120191839016"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031245543.png" alt="image-20221120191945595"></p><h1>Crypto</h1><h2 id="来自红岩的密文1">来自红岩的密文1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">听说这是一段一直流传在红岩的密文，每一个解密出这段密文的他/她都会开启属于自己的旅程，你能否成功的解密这段密文？开启属于自己的旅程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea：</span><br><span class="line">下载附件，发现是数字，想到ASCII</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step：</span><br><span class="line">对应ASCII转码即可求解</span><br><span class="line">redrock&#123;Welc0me-T0-The-CTF-0f-redrock!!!&#125;</span><br></pre></td></tr></table></figure><h2 id="来自红岩的密文2">来自红岩的密文2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：邪恶的力量妄想夺取密文，危难关头清水拿出了一段晦涩的咒语，只要成功的解密这段咒语就能成功的阻止邪恶的Dog&amp;Cat，并且听说这段咒语是开启新冒险的钥匙之一</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea：</span><br><span class="line">下载附件，发现是一串emoji表情，在网上搜索密码类型，查到这是base100类型，进行转码，没有得到答案，继续寻找转码，多次尝试找到是base64类型转码，依然没有得到答案，继续寻找，多次尝试找到这是base32转码，最终得到答案。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step：</span><br><span class="line">多次转码，得到答案</span><br><span class="line">redrock&#123;BaSe100_ba5E64_Base32_u_find_me!&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031245055.jpg" alt="Screenshot_2022-11-15-14-37-05-840_com.android.br"></p><h2 id="你干嘛">你干嘛</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">听，各种动物的叫声</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea：</span><br><span class="line">下载附件，打开是一堆有规律的中文。在网上查找密码类型，发现“Ook”刚好可以和“你干嘛”对应</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step：</span><br><span class="line">用word文档将</span><br><span class="line">“你干嘛”换成“Ook”</span><br><span class="line">“。”换成“.”</span><br><span class="line">“？”（中文）换成“?&quot;（英文）</span><br><span class="line">“！”（中文）换成“!&quot;（英文）</span><br><span class="line">在在线Ook转换工具转换出一堆“奇怪的叫声”</span><br><span class="line">查找密码类型，发现是“兽音译者”密码类型</span><br><span class="line">进行转换，得到答案：</span><br><span class="line">redrock&#123;4re y0u Ok?&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031245879.png" alt="image-20221120193539684"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031245861.png" alt="image-20221120193745280"></p><h2 id="可惜我年轻无知">可惜我年轻无知</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">但是我是如此的年轻无知，不曾听到她的心声。 救赎之道，就在其中！ yveypbl&#123;kfu_h_kvhsq_mpfsq_dse_appjhgx_rh</span><br><span class="line">ux_xvy_rpfje_spu_dqyvv&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea:</span><br><span class="line">根据格式可知</span><br><span class="line">yveypbl=redrock</span><br><span class="line">在网络上寻找解码，找到一个网站https://quipqiup.com/</span><br><span class="line">可以进行解码，刚好与题目对应</span><br><span class="line">得到答案：</span><br><span class="line">redrock&#123;but i being young and foolish with her would not agree&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031246168.png" alt="image-20221120194443214"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031246416.png" alt="image-20221120194455674"></p><h2 id="A和B">A和B</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">最终flag字母均为小写</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea:</span><br><span class="line">下载附件，发现是一堆A和B，并且是最终答案的格式</span><br><span class="line">想到培根密码</span><br><span class="line">对照转换表进行手动转换，得到</span><br><span class="line">r&#123;zeyydyyrzzoyzczykz&#125;</span><br><span class="line">隐约看到有些规律，这串字符里包含了redrock</span><br><span class="line">这样排列</span><br><span class="line">r e d r o c k</span><br><span class="line">&#123; y y z y z z</span><br><span class="line">z y y z z y &#125;</span><br><span class="line">得到答案：</span><br><span class="line">redrock&#123;yyzyzzzyyzzy&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031246786.jpg" alt="Cache_-22db552fa8704244."><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031246106.jpg" alt="Cache_-678ef29b17e83bff."></p><h1>Reverse</h1><h2 id="just-re-it">just_re_it</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">Try to submit everything like redrock&#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea：</span><br><span class="line">先下载附件，百度搜索，reverse类型题目需要用到IDA</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step:</span><br><span class="line">直接把附件拖入IDA64中，查找字符串，得到答案</span><br><span class="line">redrock&#123;This_is_fake_flag&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031247448.png" alt="image-20221120195645245"></p><h2 id="水水爱听歌">水水爱听歌</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">你能猜中我的心思吗~ Python Message.pyc 就可以运行！</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea：</span><br><span class="line">下载附件，发现后缀是.pyc，百度搜索，发现这种文件需要反编译，在在线工具中反编译得到后缀为.py的文件，用VS打开。</span><br><span class="line">这是python代码，需要修改些东西。</span><br><span class="line">先把  清水大帅比 修改，改成A，保证可以运行</span><br><span class="line">细看代码，发现if语句与flag的输出有关</span><br><span class="line">修改A=check（flag）为A=True</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">观察此句，知道这行代码，如果flag的base64加密和zzz相等，则返回true</span><br><span class="line">所以把zzz解密就可以了</span><br><span class="line">在网上搜索，zzz后的解码类型为URL</span><br><span class="line">进行解码得到She_bid_me_to_take_love_easy_as_the_leaves_grow_on_the_tree</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031246124.png" alt="image-20221120200830741"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后运行代码，出现下面的情况</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031246455.png" alt="image-20221120201021175"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">还可以输入东西，于是输入She_bid_me_to_take_love_easy_as_the_leaves_grow_on_the_tree</span><br><span class="line">得到答案：</span><br><span class="line">redrock&#123;044d7a01a972dc5882831e89676220c2dc3a3c142e16379a76a45680137a6b55&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031247384.png" alt="image-20221120201115583"></p><h2 id="赛博丁真">赛博丁真</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">喜欢我 HeLang 吗？</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea：</span><br><span class="line">平时网上冲浪，知道本题目和何同学有关</span><br><span class="line">下载附件，发现是补充代码</span><br><span class="line">在网上搜索这段代码是何同学制作键盘时被网友发现的一段错误代码</span><br><span class="line">我尝试把错误代码补全，发现成功得到答案！</span><br><span class="line">redrock&#123;ggg_ding_zhen&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031247141.png" alt="image-20221120201454565"></p><h2 id="jmp-or-nop">jmp_or_nop</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">下载附件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea：</span><br><span class="line">下载附件后发现和反汇编有关，拖入dbg（32）中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step1:</span><br><span class="line">搜索字符串，找到相关信息，可知最终答案格式为RedRock&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031247677.png" alt="image-20221121010052260"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step2：</span><br><span class="line">观察和答案相关部分的汇编语言，可知有直接输出flag的操作，但打开程序并不显示。所以应该修改汇编指令。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031248828.png" alt="image-20221121110844796"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step3：</span><br><span class="line">可以看到这里有cmp进行了判断，再用jae指令判断是否跳跃，将其修改。</span><br><span class="line">以下同理。</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031248988.png" alt="image-20221121110348685"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step4：</span><br><span class="line">接下来就可以运行了</span><br><span class="line">最终得到答案：</span><br><span class="line">RedRock&#123;jmp_and_nop_is_really_useful&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202306031248451.png" alt="image-20221121104358090"></p>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Achievements </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红岩打印姬复活记录</title>
      <link href="/2024/11/08/%E7%BA%A2%E5%B2%A9%E6%89%93%E5%8D%B0%E5%A7%AC%E5%A4%8D%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/11/08/%E7%BA%A2%E5%B2%A9%E6%89%93%E5%8D%B0%E5%A7%AC%E5%A4%8D%E6%B4%BB%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>下面记录一下在复活网校打印机机器人-<strong>红岩打印姬</strong>时遇到的问题和解决方案</p><h2 id="做出的更新">做出的更新</h2><p>1.使用了<code>Helemet-CI</code>进行镜像打包</p><p>2.更改了Dockerfile的内容，使镜像可以快速且正确的被打包</p><p>3.由于飞书接收消息接口的json接收体发生了改变，对<code>reply.py</code>中的<code>file_name</code>、<code>file_key</code>和<code>image_key</code>三个变量的获取造成了影响，使用<code>json.loads()</code>函数解决</p><h2 id="1-读取环境变量问题">1.读取环境变量问题</h2><p>机器人通过<code>configmap</code>读取<code>app_id</code>，<code>app_secret</code>等环境变量，没有<code>configmap</code>的话机器人会报以下错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/nonebot/bot.py&quot;, line 22, in &lt;module&gt;</span><br><span class="line">    driver.register_adapter(FeishuAdapter)</span><br><span class="line">  File &quot;/usr/local/lib/python3.10/dist-packages/nonebot/internal/driver/abstract.py&quot;, line 77, in register_adapter</span><br><span class="line">    self._adapters[name] = adapter(self, **kwargs)</span><br><span class="line">  File &quot;/usr/local/lib/python3.10/dist-packages/nonebot/adapters/feishu/adapter.py&quot;, line 46, in __init__</span><br><span class="line">    self.feishu_config: Config = Config(**self.config.dict())</span><br><span class="line">  File &quot;pydantic/main.py&quot;, line 341, in pydantic.main.BaseModel.__init__</span><br><span class="line">pydantic.error_wrappers.ValidationError: 1 validation error for Config</span><br><span class="line">feishu_bots</span><br><span class="line">  value is not a valid list (type=type_error.list)</span><br></pre></td></tr></table></figure><p>提示<code>feishu_bots</code>不是一个有效列表，意味着机器人未读取到<code>configmap</code>里的环境变量</p><p>在部署时也不能直接把这些环境变量直接明文填写在<code>.env.prod</code>中</p><h2 id="2-Dockerfile的修改">2.Dockerfile的修改</h2><h3 id="2-1-apt换源问题">2.1 apt换源问题</h3><p>最开始的Dockerfile使用了<code>python:slim</code>镜像，导致在执行<code>apt-get update</code>命令时异常的慢</p><p>并且在这个镜像（debian镜像也是）中不能更改镜像源，会提示</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202310251946147.png" alt="image-20231025194635047"></p><p>于是更改为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:22.04</span><br></pre></td></tr></table></figure><p>使用<code>sed</code>命令更改镜像源为清华源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN sed -i &#x27;s/archive.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apt/sources.list   </span><br></pre></td></tr></table></figure><h3 id="2-2-pip换源问题">2.2 pip换源问题</h3><p>最开始的Dockerfile中的所有<code>pip install</code>均未指定源，经常会出现网络问题</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202310251955095.jpeg" alt="862eb61f-b7c0-481b-8f9f-6f31fc135ce3"></p><p>于是我向所有<code>pip</code>都指定了源</p><p>使用<code>pipx install nb-cli</code>经常出现网络问题</p><blockquote><p>pipx 是一个自由开源程序，允许你在隔离的虚拟环境中安装和运行 Python 应用。</p></blockquote><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202310251958674.png" alt="20231023-164641"></p><p>使用<code>pip install nb-cli -i https://pypi.tuna.tsinghua.edu.cn/simple</code>即可解决</p><h3 id="2-3-未找到nb命令">2.3 未找到nb命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/sh: 1: /root/.local/bin/nb: not found</span><br></pre></td></tr></table></figure><p>在Dockerfile中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD which nb</span><br></pre></td></tr></table></figure><p>即可显示正确的<code>nb</code>位置</p><h2 id="3-IngressRoute请求路径下划线问题">3.IngressRoute请求路径下划线问题</h2><p>在IngressRoute中，请求路径最后的下划线会影响解析</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202310252030477.png" alt="image-20231025203025401"></p><p>在本实例中，不加下划线才能被正确解析</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202310252036348.png" alt="image-20231025203617314"></p><h2 id="4-飞书接收消息接收体改变影响变量问题">4.飞书接收消息接收体改变影响变量问题</h2><p>飞书接收消息json接收体结构如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;schema&quot;: &quot;2.0&quot;,</span><br><span class="line">    &quot;header&quot;: &#123;</span><br><span class="line">        &quot;event_id&quot;: &quot;56dc6536843b7bd94680cf2af1c8791&quot;,</span><br><span class="line">        &quot;token&quot;: &quot;aJ2XlWEC5uNfiaQMzaNUCbFMeIW28828&quot;,</span><br><span class="line">        &quot;create_time&quot;: &quot;1698134093609&quot;,</span><br><span class="line">        &quot;event_type&quot;: &quot;im.message.receive_v1&quot;,</span><br><span class="line">        &quot;tenant_key&quot;: &quot;17cf1f7e2f06d758&quot;,</span><br><span class="line">        &quot;app_id&quot;: &quot;cli_a42011585561100d&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;event&quot;: &#123;</span><br><span class="line">        &quot;message&quot;: &#123;</span><br><span class="line">            &quot;chat_id&quot;: &quot;oc_8b46f745993928bcfe0f23fe30cee4d0&quot;,</span><br><span class="line">            &quot;chat_type&quot;: &quot;p2p&quot;,</span><br><span class="line">            &quot;content&quot;: &quot;&#123;\&quot;file_key\&quot;:\&quot;file_v2_718639f3-fbf7-4a12-8ff3-56ea16b1d4ag\&quot;,\&quot;file_name\&quot;:\&quot;a.pdf\&quot;&#125;&quot;,</span><br><span class="line">            &quot;create_time&quot;: &quot;1698134093362&quot;,</span><br><span class="line">            &quot;message_id&quot;: &quot;om_3fb62cafecae381509e6e36eeb2f5cc3&quot;,</span><br><span class="line">            &quot;message_type&quot;: &quot;file&quot;,</span><br><span class="line">            &quot;update_time&quot;: &quot;1698134093362&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sender&quot;: &#123;</span><br><span class="line">            &quot;sender_id&quot;: &#123;</span><br><span class="line">                &quot;open_id&quot;: &quot;ou_b7f2f10f337267948c94258ab8c684e&quot;,</span><br><span class="line">                &quot;union_id&quot;: &quot;on_01a1d695ec162830a027295516386bdc&quot;,</span><br><span class="line">                &quot;user_id&quot;: &quot;9a8cfgee&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;sender_type&quot;: &quot;user&quot;,</span><br><span class="line">            &quot;tenant_key&quot;: &quot;17cf1f7e2f06d758&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对原先<code>reply.py</code>中<code>file_name</code>、<code>file_key</code>和<code>image_key</code>三个变量的获取造成了影响</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202310252046470.png" alt="20231025-204615"></p><p>现通过<code>json.loads()</code>函数重新提取这三个变量，其他同理</p><p><code>e</code>为整个接收体的内容，<code>event</code>为event的内容，其他同理</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202310252049362.png" alt="image-20231025204912283"></p>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trouble Shooting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用通义灵码实现我的第一次开源贡献</title>
      <link href="/2024/11/08/%E5%88%A9%E7%94%A8%E9%80%9A%E4%B9%89%E7%81%B5%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%BC%80%E6%BA%90%E8%B4%A1%E7%8C%AE/"/>
      <url>/2024/11/08/%E5%88%A9%E7%94%A8%E9%80%9A%E4%B9%89%E7%81%B5%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%BC%80%E6%BA%90%E8%B4%A1%E7%8C%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="结缘开源">结缘开源</h2><p>最早了解开源是从学校的兴趣组织开始的。2023年10月21日，openSUSE亚洲峰会在我们学校召开，这次会议汇聚了许多来自openSUSE社区贡献者以及对开源感兴趣的爱好者们。我第一次知道有这么多志同道合的爱好者在进行开源贡献，他们以个人兴趣为驱动力共同维护护着一个社区。这次峰会激发了我对开源社区的兴趣，一颗种子也开始埋在我的心中——我也想要做一次开源贡献！</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408082305657.jpg" alt="img_v3_02di_f60fddbd-1c31-497d-b895-c9fa5e6a9a5g"></p><p>2024年6月24日，我上完课准备回宿舍，刚好在必经之路上看到“2024天池云原生编程挑战赛”的宣传海报。我一看居然是阿里云举办的，回到宿舍后就立马仔细查看了详细的比赛信息。”赛道3：用通义灵码,人人都是开源贡献者“很符合我的兴趣，我也特别想能有一个被Merged的PR。赛道3有很多个选题，结合我自己学习过云原生的一些知识，我最终选择了Higress开源项目，这是阿里云自己开发的API网关，它和Nginx、Traefik很类似，但是它增加了许多新的功能，并且更聚焦于云原生环境中的服务网格。尤其是它有丰富的插件，特别是与AI有关的插件，使得用户可以很轻易的拥有一个属于自己的AI。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408082319252.jpg" alt="img_v3_02di_3b8c3789-0389-410c-98bc-427de4ceec0g"></p><h2 id="参加比赛">参加比赛</h2><p>因为Higress这个开源项目是开放式赛题，浏览了当时的<code>issues</code>，因为接触过CI/CD，并且懂得Kubernetes和Docker的一些操作，所以我最终选择了这个issue：<a href="https://github.com/alibaba/higress/issues/1052">支持通过 GitHub Actions 来构建和发布 Wasm 插件镜像 · Issue #1052 · alibaba/higress</a></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408082330738.png" alt="image-20240808233008681"></p><h2 id="通义灵码体验">通义灵码体验</h2><p>虽然接触过CI/CD，但是我从来没有在Github上实现过它，也不会<code>Github Action</code>的语法格式。通义灵码给了我很大的帮助。我按照<a href="https://tongyi.aliyun.com/lingma/download?spm=a2c22.12281978.0.0.4c4478fakORPM4">通义灵码安装文档</a>将它安装到了我的VS Code中，接下来就是愉快的使用环节了。</p><p>在使用通义灵码的过程中，我先复制了一份写好的<code>Github Action Workflow</code>，利用通义灵码的<strong>解释代码</strong>和直接对话功能，我很快地了解了<code>Github Action</code>的基本语法以及格式。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408082347764.png" alt="image-20240808234747671"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408082348916.png" alt="image-20240808234857831"></p><p>然后我就开始编写<code>issue</code>所需要的<code>Github Action Workflow</code>了。</p><p>其中<strong>代码优化建议</strong>功能帮了我很大的忙，我只需要把有疑问的代码勾选，然后再执行<code>/generate optimization</code>，通义灵码就能很方便的为我指出错误，并且提出建议。在以往的话我还需要先把代码复制下来，然后再抛给AI，有时还得附带上下文。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408082358167.png" alt="image-20240808235819098"></p><h2 id="提交PR">提交PR</h2><p>写好<code>Github Action Workflow</code>，我提交了PR。但是这个PR不是一次性就被Merge的。这其中我和项目负责人进行了很多有趣的讨论。提交PR的那段时间刚好是我的考试周，每天复习之余，最上心的事情就是查看邮箱，看看负责人有没有给我留言，每次收到邮件我都会十分激动，因为他真的在看我的贡献，真的在为我的贡献提出建议！</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408090010673.jpg" alt="img_v3_02dj_4c835cf2-4167-432f-a89b-b237d7a11f3g"></p><p>为了这份脚本能够成功执行，我进行了很多次的测试。而且在测试的过程中，我甚至也找出了官方文档存在的一些问题。我还提了一个自己发现的issue！<a href="https://github.com/alibaba/higress/issues/1100">按照Wasm 插件镜像规范构建出的镜像不可用 · Issue #1100 · alibaba/higress (github.com)</a></p><p>2024年7月8日，我进行了最后一次测试。我写了十分详细的测试文档，然后提交。直到我看到负责人给我评论了&quot;LGTM(Looks Good To Me)&quot;，我高兴极了。很快他Merge了我的PR。就这样我得到了第一个属于自己的<code>Merged PR</code>。</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202408090014589.png" alt="image-20240809001447530"></p><h2 id="参赛心得">参赛心得</h2><h3 id="技术提升">技术提升</h3><p>通过这次比赛，我学会了<code>Github Action Workflow</code>的基本语法和编写格式，并且对CI/CD在企业中的应用有了更进一步的了解。</p><p>并且我还上手了阿里云开发的新一代API网关Higress，体验了它丰富的功能，感受到了它在云原生环境下的强大实力</p><h3 id="开源氛围">开源氛围</h3><p>Higress是一个活跃的开源社区，在这个社区中大家都积极的分享自己的知识和idea，乐于寻找bug。这种互帮互助，乐于分享的活跃氛围大大激发了我的开源兴趣。</p><h3 id="个人体会">个人体会</h3><p>这次比赛不仅提升了我的技术，还让我学会了如何沟通、如何解决问题等等。我收获很多，相信在以后我会对开源社区做更多高质量的贡献，争取在多几个PR~</p><h2 id="致谢">致谢</h2><p>十分感谢<strong>阿里云</strong>以及<strong>天池</strong>为我们广大开源爱好者搭建了一个广阔无垠的舞台，让我们有机会将梦想转化为现实，将创意付诸实践。</p><p>同时也要感谢项目的相关工作人员，无论是对于技术上的指导和建议，还是比赛资料的统计以及奖品的组织发放，大家都辛苦了！</p><p>未来的路还很长，但我相信，在阿里云与天池的陪伴下，我们将携手共进，共创辉煌。</p>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Achievements </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iManager-您的私人镜像管家</title>
      <link href="/2024/11/08/iManager-%E6%82%A8%E7%9A%84%E7%A7%81%E4%BA%BA%E9%95%9C%E5%83%8F%E7%AE%A1%E5%AE%B6/"/>
      <url>/2024/11/08/iManager-%E6%82%A8%E7%9A%84%E7%A7%81%E4%BA%BA%E9%95%9C%E5%83%8F%E7%AE%A1%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<p>尽管Docker官方提供了公共的镜像仓库DockerHub，但从安全性和稳定性等方面考虑，部署私有镜像仓库是非常有必要的。Harbor是一个由VMware公司开源的企业级的Docker Registry管理项目，是我们搭建私有镜像仓库的不二之选。</p><p>而自动化一直是运维工作中的重中之重。</p><p>Yiiong希望你能够将Harbor与飞书机器人联系起来，方便管理员统一管理镜像，使管理员随时都可以知晓仓库镜像的变动信息，管理员动动手指就可以对仓库里的镜像进行操作等。</p><h2 id="前置准备">前置准备</h2><ul><li><p>建议使用服务器搭建Harbor仓库，并且配置好https</p></li><li><p>申请一个飞书企业账号</p></li><li><p><s>可能需要一个域名？</s></p></li></ul><h2 id="任务">任务</h2><h3 id="友善的用户交互">友善的用户交互</h3><p>用户肯定需要知道你的机器人都可以干些什么事情吧</p><p>用户向机器人发送<code>帮助</code>，机器人返回可以实现的功能列表</p><p>当用户发送了一些乱七八糟的信息时，机器人需要做出一定的回复，比如<code>我听不懂捏</code></p><h3 id="Level-0-通知">Level 0 通知</h3><p>当镜像状态发生改变时，机器人向管理员发起通知</p><p>通知内容包括：</p><ol><li>镜像状态（Push or Pull or Delete）</li><li>镜像名称以及标签</li><li>镜像状态改变的日期</li><li>镜像状态改变者</li></ol><h3 id="Level-1-简单查询">Level 1 简单查询</h3><p>管理员向机器人发送<code>查询项目</code>，机器人返回所有项目的名称、所属者以及访问级别</p><p>管理员向机器人发送<code>查询仓库</code>，机器人返回所有仓库的名称、创建时间以及更新时间</p><h3 id="Level-2-镜像管理">Level 2 镜像管理</h3><p>在我们的团队开发过程中，难免会出现多次推送镜像但镜像测试不通过的情况，</p><p>Yiiong希望当镜像被以Push状态推送时，通知内容中新增加一个超链接按钮，点击这个按钮即可删除这个镜像</p><p>另一种方式是，向机器人发送<code>删除镜像：镜像名</code>，即可删除某个镜像</p><h3 id="Level-3-用户管理">Level 3 用户管理</h3><p>我们的整个仓库不可能只有一个管理员用户，管理员经常需要为不同的成员创建不同的用户</p><p>Yiiong希望管理员向机器人发送<code>创建用户：用户名-密码-邮箱</code>即可创建一个新用户</p><p>并且可以将特定用户以开发者身份加入到特定项目的成员中</p><h3 id="Level-4-打包">Level 4 打包</h3><p>编写Dockerfile，将你的所有文件用Docker打包制作成镜像，使其他用户填入一些必要的信息就可以愉快地使用你的作品辣！</p><h2 id="加分项">加分项</h2><ol><li>发挥你的奇思妙想，实现一些意想不到的功能</li><li>使用Kubernetes完成必要的内网穿透</li><li>使用UptimeKuma监控你的仓库，当出现问题时通过机器人返回一些必要信息</li><li>飞书开放平台提供了一种美观的”卡片式“消息，使用它的话答辩的时候一定很潇洒啊</li></ol>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Achievements </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>higress-wasm-plugin-github action</title>
      <link href="/2024/11/08/wasm-plugin-github%20action/"/>
      <url>/2024/11/08/wasm-plugin-github%20action/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/higress/pull/1069">feat:add build-and-push-wasm-plugin-image.yaml by Beatrueman · Pull Request #1069 · alibaba/higress</a></p><h3 id="Ⅰ-Describe-what-this-PR-did">Ⅰ. Describe what this PR did</h3><p>功能：添加了利用 GitHub Actions 来自动完成相应的镜像构建和发布工作的Workflow。支持通过push tag和手动触发两种方式。同时也遵循使用oras打包工具。<br>特点：完全按照<a href="https://higress.io/zh-cn/docs/user/wasm-image-spec/">Wasm 插件镜像规范</a>进行镜像打包。</p><p>更新：</p><ol><li>添加了查找文件的逻辑，会在插件目录中查找<code>spec.yaml</code>、<code>README.md</code>和<code>README-&#123;lang&#125;.md</code>三个文件，有则在打包推送镜像时设置相应的<code>media type</code>。</li><li>修改了review后存在的问题。</li><li>修改了<code>builder</code>容器的启动命令为 <code>docker run -itd --name builder xxx /bin/bash</code>，之前使用<code>sleep 99999</code>是希望容器保持后台持续运行，这样只适合测试容器，不适合在生产环境中使用。</li><li>重新提交<code>PR</code>是因为错误地提交了一些没用的<code>commit</code>，不太会删除，担心破坏仓库并且为了保持<code>PR</code>整洁所以重新提交。</li></ol><h3 id="Ⅱ-Does-this-pull-request-fix-one-issue">Ⅱ. Does this pull request fix one issue?</h3><p>fixes <a href="https://github.com/alibaba/higress/issues/1052">#1052</a></p><h3 id="Ⅳ-Describe-how-to-verify-it">Ⅳ. Describe how to verify it</h3><p>1.准备工作<br>添加Repository Secrets和 Repository variables。<br><img src="https://gitee.com/beatrueman/images/raw/master/img/202406291116573.png" alt="img"><br><img src="https://camo.githubusercontent.com/c70982b37d47a9898639e98f34d2db7c51a199e9dacf1b9f8118192c683f1a7f/68747470733a2f2f67697465652e636f6d2f626561747275656d616e2f696d616765732f7261772f6d61737465722f696d672f3230323430363237313230303530352e706e67" alt="img"><br>2.通过<code>push tag</code>触发，先查找相关文件，然后将特定的插件打包成镜像并推送至指定仓库。<br><img src="https://gitee.com/beatrueman/images/raw/master/img/202406291116729.png" alt="image"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406291201172.png" alt="image-20240629120147125"><img src="https://gitee.com/beatrueman/images/raw/master/img/202406291251252.png" alt="image-20240629125144171"><br><img src="https://gitee.com/beatrueman/images/raw/master/img/202406291250306.png" alt="image-20240629125028239"><br>3.人工触发，指定插件名和版本号<br><img src="https://gitee.com/beatrueman/images/raw/master/img/202406291116732.png" alt="51e1fc7ab267c66492ecbcfb43cd23d0"><img src="https://gitee.com/beatrueman/images/raw/master/img/202406291116270.png" alt="image"></p><h3 id="Ⅴ-Special-notes-for-reviews">Ⅴ. Special notes for reviews</h3><p>这是我第一次参与开源贡献，希望能有所帮助！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Build and Push Wasm Plugin Image</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    tags:</span><br><span class="line">    - &quot;wasm-go-*-v*.*.*&quot; # 匹配 wasm-go-&#123;pluginName&#125;-vX.Y.Z 格式的标签</span><br><span class="line">  workflow_dispatch:</span><br><span class="line">    inputs:</span><br><span class="line">      plugin_name:</span><br><span class="line">        description: &#x27;Name of the plugin&#x27;</span><br><span class="line">        required: true</span><br><span class="line">        type: string</span><br><span class="line">      version:</span><br><span class="line">        description: &#x27;Version of the plugin (optional, without leading v)&#x27;</span><br><span class="line">        required: false</span><br><span class="line">        type: string</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build-and-push-image:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    environment:</span><br><span class="line">      name: image-registry-msg</span><br><span class="line">    env:</span><br><span class="line">      IMAGE_REGISTRY_SERVICE: $&#123;&#123; vars.IMAGE_REGISTRY_SERVICE || &#x27;higress-registry.cn-hangzhou.cr.aliyuncs.com&#x27; &#125;&#125;</span><br><span class="line">      IMAGE_REPOSITORY: $&#123;&#123; vars.IMAGE_REPOSITORY || &#x27;plugins&#x27; &#125;&#125;</span><br><span class="line">      GO_VERSION: 1.19</span><br><span class="line">      TINYGO_VERSION: 0.25.0</span><br><span class="line">      ORAS_VERSION: 1.0.0</span><br><span class="line">    steps:</span><br><span class="line">      - name: Set plugin_name and version from inputs or ref_name</span><br><span class="line">        id: set_vars</span><br><span class="line">        run: |</span><br><span class="line">          if [[ &quot;$&#123;&#123; github.event_name &#125;&#125;&quot; == &quot;workflow_dispatch&quot; ]]; then</span><br><span class="line">            plugin_name=&quot;$&#123;&#123; github.event.inputs.plugin_name &#125;&#125;&quot;</span><br><span class="line">            version=&quot;$&#123;&#123; github.event.inputs.version &#125;&#125;&quot;</span><br><span class="line">          else</span><br><span class="line">            ref_name=$&#123;&#123; github.ref_name &#125;&#125;</span><br><span class="line">            plugin_name=$&#123;ref_name#*-*-&#125; # 删除插件名前面的字段(wasm-go-)</span><br><span class="line">            plugin_name=$&#123;plugin_name%-*&#125; # 删除插件名后面的字段(-vX.Y.Z)</span><br><span class="line">            version=$(echo &quot;$ref_name&quot; | awk -F&#x27;v&#x27; &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">          fi</span><br><span class="line"></span><br><span class="line">          echo &quot;PLUGIN_NAME=$plugin_name&quot; &gt;&gt; $GITHUB_ENV</span><br><span class="line">          echo &quot;VERSION=$version&quot; &gt;&gt; $GITHUB_ENV</span><br><span class="line"></span><br><span class="line">      - name: Checkout code</span><br><span class="line">        uses: actions/checkout@v3</span><br><span class="line">      </span><br><span class="line">      - name: File Check</span><br><span class="line">        run: | </span><br><span class="line">          workspace=$&#123;&#123; github.workspace &#125;&#125;/plugins/wasm-go/extensions/$&#123;PLUGIN_NAME&#125;</span><br><span class="line">          push_command=&quot;./plugin.tar.gz:application/vnd.oci.image.layer.v1.tar+gzip&quot;</span><br><span class="line">          </span><br><span class="line">          # 查找spec.yaml</span><br><span class="line">          if [ -f &quot;$&#123;workspace&#125;/spec.yaml&quot; ]; then</span><br><span class="line">            echo &quot;spec.yaml exists&quot;</span><br><span class="line">            push_command=&quot;$push_command ./spec.yaml:application/vnd.module.wasm.spec.v1+yaml&quot;</span><br><span class="line">          fi</span><br><span class="line"></span><br><span class="line">          # 查找README.md</span><br><span class="line">          case &quot;$(ls $&#123;workspace&#125;/README*.md 2&gt;/dev/null)&quot; in</span><br><span class="line">            *&quot;README.md&quot;*)</span><br><span class="line">              echo &quot;README.md exists&quot;</span><br><span class="line">              push_command=&quot;$push_command ./README.md:application/vnd.module.wasm.doc.v1+markdown&quot;</span><br><span class="line">              ;;</span><br><span class="line">          esac</span><br><span class="line">          </span><br><span class="line">          # 查找README_&#123;lang&#125;.md</span><br><span class="line">          for file in $&#123;workspace&#125;/README_*.md; do</span><br><span class="line">            if [ -f &quot;$file&quot; ]; then</span><br><span class="line">              file_name=$(basename $file)</span><br><span class="line">              echo &quot;$file_name exists&quot;</span><br><span class="line">              lang=$(basename $file | sed &#x27;s/README_//; s/.md//&#x27;)</span><br><span class="line">              push_command=&quot;$push_command ./$file_name:application/vnd.module.wasm.doc.v1.$lang+markdown&quot;</span><br><span class="line">            fi</span><br><span class="line">          done</span><br><span class="line"></span><br><span class="line">          echo &quot;PUSH_COMMAND=\&quot;$push_command\&quot;&quot; &gt;&gt; $GITHUB_ENV</span><br><span class="line">        </span><br><span class="line">      - name: Run a wasm-go-builder</span><br><span class="line">        env: </span><br><span class="line">          PLUGIN_NAME: $&#123;&#123; env.PLUGIN_NAME &#125;&#125;</span><br><span class="line">          BUILDER_IMAGE: higress-registry.cn-hangzhou.cr.aliyuncs.com/plugins/wasm-go-builder:go$&#123;&#123; env.GO_VERSION &#125;&#125;-tinygo$&#123;&#123; env.TINYGO_VERSION &#125;&#125;-oras$&#123;&#123; env.ORAS_VERSION &#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          docker run -itd --name builder -v $&#123;&#123; github.workspace &#125;&#125;:/workspace -e PLUGIN_NAME=$&#123;&#123; env.PLUGIN_NAME &#125;&#125; --rm $&#123;&#123; env.BUILDER_IMAGE &#125;&#125; /bin/bash</span><br><span class="line"></span><br><span class="line">      - name: Build Image and Push</span><br><span class="line">        run: |</span><br><span class="line">          </span><br><span class="line">          push_command=$&#123;&#123; env.PUSH_COMMAND &#125;&#125;</span><br><span class="line">          push_command=$&#123;push_command#\&quot;&#125;</span><br><span class="line">          push_command=$&#123;push_command%\&quot;&#125; # 删除PUSH_COMMAND中的双引号，确保oras push正常解析</span><br><span class="line"></span><br><span class="line">          command=&quot;</span><br><span class="line">          cd /workspace/plugins/wasm-go/extensions/$&#123;PLUGIN_NAME&#125;</span><br><span class="line">          go mod tidy</span><br><span class="line">          tinygo build -o ./plugin.wasm -scheduler=none -target=wasi ./main.go</span><br><span class="line">          tar czvf plugin.tar.gz /workspace/plugins/wasm-go/extensions/$&#123;PLUGIN_NAME&#125;/plugin.wasm</span><br><span class="line">          echo $&#123;&#123; secrets.REGISTRY_PASSWORD &#125;&#125; | oras login -u $&#123;&#123; secrets.REGISTRY_USERNAME &#125;&#125; --password-stdin $&#123;&#123; env.IMAGE_REGISTRY_SERVICE &#125;&#125;</span><br><span class="line">          oras push $&#123;IMAGE_REGISTRY_SERVICE&#125;/$&#123;IMAGE_REPOSITORY&#125;:$&#123;VERSION&#125; $&#123;push_command&#125;</span><br><span class="line">          &quot;</span><br><span class="line">          docker exec builder bash -c &quot;$command&quot;</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Achievements </tag>
            
            <tag> CI/CD </tag>
            
            <tag> Github Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Jenkins+Git+SonarQube+Draft+Buildah+Helm的CI/CD流</title>
      <link href="/2024/11/08/%E5%9F%BA%E4%BA%8EJenkins+Git+SonarQube+Draft+Buildah+Helm%E7%9A%84CICD%E6%B5%81/"/>
      <url>/2024/11/08/%E5%9F%BA%E4%BA%8EJenkins+Git+SonarQube+Draft+Buildah+Helm%E7%9A%84CICD%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="构建部署工具及镜像作用介绍">构建部署工具及镜像作用介绍</h2><h3 id="工具">工具</h3><p><a href="https://www.jenkins.io/zh/">Jenkins</a>：通过Pipeline实现CI/CD流</p><p><a href="https://www.sonarsource.com/products/sonarqube/">Sonar</a>：进行代码检查</p><p><a href="https://github.com/Azure/draft">draft</a>：根据项目自动生成Dockerfile与Helm Chart</p><p><a href="https://buildah.io/">Buildah</a>：打包、推送镜像</p><p><a href="https://helm.sh/">Helm</a>：部署Chart到Kubernetes集群</p><h3 id="镜像">镜像</h3><p><code>beatrueman/builder:1.0</code>：整合了<code>draft</code>与<code>buildah</code>，负责镜像构建与镜像推送</p><p><code>beatrueman/deployer:1.0</code>：整合了<code>Helm</code>，用于部署Chart到Kubernetes</p><p><code>sonarsource/sonar-scanner-cli:latest</code>：用于执行代码检查</p><p><code>jenkins/inbound-agent:3206.vb_15dcf73f6a_9-2</code>：它是 Jenkins Pipeline 中的一种代理机制，允许在 Jenkins 中动态创建代理节点以执行特定的构建任务。</p><h2 id="整体流程">整体流程</h2><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406072221097.png" alt="image-20240607222125043"></p><ol><li>开发人员推送代码到Git仓库，自动触发Jenkins CI/CD流</li><li>SonarQube进行代码检查</li><li>查找Dockerfile，如果没有则通过Draft自动生成Dockerfile和Helm Chart</li><li>使用buildah进行镜像打包与镜像推送到Harbor仓库</li><li>使用Helm将Chart部署在Kubernetes集群上，并把打包好的chart包推送至Harbor</li></ol><h2 id="参数">参数</h2><p>参数化构建</p><table><thead><tr><th>变量名</th><th>表示值</th><th>可选项</th></tr></thead><tbody><tr><td>HARBOR_REGISTRY</td><td>Harbor仓库名</td><td></td></tr><tr><td>PROJECT_NAME</td><td>项目名称</td><td>必须小写</td></tr><tr><td>ENTRYPOINT</td><td>项目入口文件（仅用于Python）</td><td><a href="http://app.xn--pymain-q06l.py">app.py或main.py</a></td></tr><tr><td>PORT</td><td>项目暴露入口</td><td></td></tr><tr><td>IMAGE_NAME</td><td>镜像名称</td><td></td></tr><tr><td>TAG</td><td>镜像标签</td><td></td></tr><tr><td>SONAR_PROJECT_NAME</td><td>sonar代码检查项目名称</td><td></td></tr></tbody></table><h2 id="准备">准备</h2><h3 id="插件下载">插件下载</h3><p>在<strong>插件管理</strong>中搜索并下载以下插件</p><p>Kubernetes：<a href="https://plugins.jenkins.io/kubernetes">Kubernetes版本4238.v41b_3ef14a_5d8</a></p><p>SonarQube Scanner for Jenkins：<a href="https://plugins.jenkins.io/sonar">SonarQube Scanner for Jenkins版本</a></p><h3 id="添加凭据">添加凭据</h3><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406072350161.png" alt="image-20240607235051117"></p><ol><li>SonarQube凭据保存的内容为在SonarQube中生成的全局令牌</li><li>Harbor-Secret凭据保存Harbor的用户名和密码</li><li>kubeconfig保存最后一步生成的kubeconfig</li></ol><h3 id="Kubernetes集群连接">Kubernetes集群连接</h3><p>以使用Kubernerts部署的Jenkins为例（部署方法请自行查询）</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406072336721.png" alt="image-20240607233606595"></p><p>1.在<strong>系统管理</strong> &gt;&gt; <strong>Clouds</strong>中新增一个cloud</p><p>2.主要填入以下配置</p><ul><li>名称</li><li>Kubernetes地址：<code>https://&lt;your_ip&gt;:6443</code></li><li>Kubernetes命名空间（需要与jenkins部署在同一个命名空间）</li><li>Jenkins地址：Jenkins在K8s部署，填入<code>http://ClusterIP:Port</code> <code>(http://10.96.3.38:8080）</code>。若不在K8s部署，需要将<code>/root/.kube/config</code>base64编码后保存为凭据，然后再填入jenkins的暴露地址。</li><li>Jenkins通道：填入<code>10.96.1.180:50000</code>，注意一定不要加http</li></ul><p>将cloud名称填入<code>cloud &quot;&quot;</code></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406080018275.png" alt="image-20240608001827248"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406072346547.png" alt="20240607-234551"></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406072346575.png" alt="image-20240607234620509"></p><p>可以点击<strong>连接测试</strong>检查是否可以连接集群</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406072346531.png" alt="image-20240607234655491"></p><h3 id="SonarQube准备">SonarQube准备</h3><p>1.手工新建一个项目</p><p>2.新建一个<strong>全局令牌</strong></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406072321325.png" alt="image-20240607232105268"></p><p>3.将该令牌生成的token添加进Jenkins的全局凭据中</p><p>4.在<strong>系统配置</strong>中，填入Sonar的服务地址与凭据</p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406072356233.png" alt="20240607-235555"></p><h3 id="使用受限的kubeconfig">使用受限的kubeconfig</h3><p>使用该工具<a href="https://gitlab.mikumikumi.xyz/base/kubeconfig-generator.git">kubeconfig-generator</a>，生成一个受限制的kubeconfig</p><ol><li>新建一个命名空间，用于最终项目的部署</li><li>在<code> kubeconfig-generator.py</code>中，指定<code>NAMESPACE</code> 、<code>CLUSTER_SERVER</code>、<code>SA_NAME</code></li></ol><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406080014299.png" alt="image-20240607235927663"></p><p>3.将生成的<code>kubeconfig</code>下载，以<code>secret file</code>形式添加进Jnekins凭据</p><p>4.因为此时的config是受限的，需要生成一个<code>rolebinding</code>，用于jenkins命名空间下的default用户控制test命名空间下的一些操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: jenkins-rolebinding</span><br><span class="line">  namespace: test # 控制test命名空间</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: default</span><br><span class="line">  namespace: jenkins # 这里假设Jenkins服务账户位于jenkins命名空间</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: edit # 或者你可以定义一个自定义的Role，只包含所需的最小权限</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><h2 id="完整Jenkinsfile">完整Jenkinsfile</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        kubernetes &#123;</span><br><span class="line">            cloud &quot;Redrock-Cloud&quot;</span><br><span class="line">            yaml &quot;&quot;&quot;</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    component: jenkins-agent</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: sonar-scanner</span><br><span class="line">      image: sonarsource/sonar-scanner-cli:latest</span><br><span class="line">      command:</span><br><span class="line">        - cat</span><br><span class="line">      tty: true</span><br><span class="line">    - name: builder</span><br><span class="line">      image: beatrueman/builder:1.0</span><br><span class="line">      securityContext:</span><br><span class="line">        privileged: true</span><br><span class="line">      command:</span><br><span class="line">        - cat</span><br><span class="line">      tty: true</span><br><span class="line">    - name: deployer</span><br><span class="line">      image: beatrueman/deployer:1.0</span><br><span class="line">      command:</span><br><span class="line">        - cat</span><br><span class="line">      tty: true</span><br><span class="line">    - name: jnlp</span><br><span class="line">      image: jenkins/inbound-agent:3206.vb_15dcf73f6a_9-2</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          memory: &quot;1Gi&quot;</span><br><span class="line">          cpu: &quot;200m&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // environment &#123;</span><br><span class="line">    //     HARBOR_REGISTRY = &#x27;&#x27;</span><br><span class="line">    //     PROJECT_NAME = &#x27;myapp&#x27; // 项目名称，必须小写</span><br><span class="line">    //     ENTRYPOINT = &#x27;main.py&#x27; // 项目入口文件，app.py或main.py</span><br><span class="line">    //     PORT = &#x27;6666&#x27; // 项目暴露的端口</span><br><span class="line">    //     IMAGE_NAME = &#x27;yicloud&#x27; // 镜像名称</span><br><span class="line">    //     TAG = &#x27;v1&#x27; // 镜像标签</span><br><span class="line">    //     SONAR_PROJECT_NAME = &#x27;Python&#x27; // sonar项目名称</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;git clone&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;1.正在克隆代码......&quot;</span><br><span class="line">                git url: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&#x27;SonarQube code checking&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                container(&#x27;sonar-scanner&#x27;) &#123;</span><br><span class="line">                    echo &#x27;2.正在进行代码检查......&#x27;</span><br><span class="line">                    echo &#x27;代码检查结果请在面板查看！&#x27;</span><br><span class="line">                    withSonarQubeEnv(&#x27;SonarQube&#x27;) &#123;</span><br><span class="line">                        sh &#x27;&#x27;&#x27;sonar-scanner \</span><br><span class="line">                            -Dsonar.projectKey=$&#123;SONAR_PROJECT_NAME&#125; \</span><br><span class="line">                            -Dsonar.projectName=$&#123;SONAR_PROJECT_NAME&#125; \</span><br><span class="line">                            -Dsonar.sources=&quot;/home/jenkins/agent/workspace/$&#123;JOB_NAME&#125;&quot; \</span><br><span class="line">                            -Dsonar.projectVersion=1.0 \</span><br><span class="line">                            -Dsonar.sourceEncoding=UTF-8</span><br><span class="line">                        &#x27;&#x27;&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&#x27;Image build&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    echo &#x27;3.正在制作镜像......&#x27;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        def result = sh(script: &quot;ls -al | grep Dockerfile&quot;, returnStatus: true)</span><br><span class="line">                        if (result == 0) &#123;</span><br><span class="line">                            echo &quot;找到 Dockerfile，开始构建镜像&quot;</span><br><span class="line">                            container(&#x27;builder&#x27;) &#123;</span><br><span class="line">                                sh &#x27;&#x27;&#x27;</span><br><span class="line">                                    draft create -a myapp --variable PORT=$&#123;PORT&#125; \</span><br><span class="line">                                        --variable APPNAME=$&#123;PROJECT_NAME&#125; \</span><br><span class="line">                                        --variable SERVICEPORT=8088 \</span><br><span class="line">                                        --variable NAMESPACE=test \</span><br><span class="line">                                        --variable IMAGENAME=$&#123;HARBOR_REGISTRY&#125;/library/$&#123;IMAGE_NAME&#125; \</span><br><span class="line">                                        --variable IMAGETAG=$&#123;TAG&#125; \</span><br><span class="line">                                        --variable ENTRYPOINT=$&#123;ENTRYPOINT&#125; \</span><br><span class="line">                                        --variable VERSION=3 \</span><br><span class="line">                                        --deploy-type helm \</span><br><span class="line">                                        --deployment-only</span><br><span class="line">                                    rm &quot;/home/jenkins/agent/workspace/$&#123;JOB_NAME&#125;/charts/templates/namespace.yaml&quot;</span><br><span class="line">                                    buildah bud -t $&#123;HARBOR_REGISTRY&#125;/library/$&#123;IMAGE_NAME&#125;:$&#123;TAG&#125; .</span><br><span class="line">                                &#x27;&#x27;&#x27;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            echo &quot;未找到 Dockerfile，将生成 Dockerfile&quot;</span><br><span class="line">                            container(&#x27;builder&#x27;) &#123;</span><br><span class="line">                                def jobNameLower = &quot;$&#123;JOB_NAME&#125;&quot;.toLowerCase()</span><br><span class="line">                                sh &#x27;&#x27;&#x27;</span><br><span class="line">                                    draft create -a myapp --variable PORT=$&#123;PORT&#125; \</span><br><span class="line">                                        --variable APPNAME=$&#123;PROJECT_NAME&#125; \</span><br><span class="line">                                        --variable SERVICEPORT=8088 \</span><br><span class="line">                                        --variable NAMESPACE=test \</span><br><span class="line">                                        --variable IMAGENAME=$&#123;HARBOR_REGISTRY&#125;/library/$&#123;IMAGE_NAME&#125; \</span><br><span class="line">                                        --variable IMAGETAG=$&#123;TAG&#125; \</span><br><span class="line">                                        --variable ENTRYPOINT=$&#123;ENTRYPOINT&#125; \</span><br><span class="line">                                        --variable VERSION=3 \</span><br><span class="line">                                        --deploy-type helm</span><br><span class="line">                                    rm &quot;/home/jenkins/agent/workspace/$&#123;JOB_NAME&#125;/charts/templates/namespace.yaml&quot;</span><br><span class="line">                                    buildah bud -t $&#123;HARBOR_REGISTRY&#125;/library/$&#123;IMAGE_NAME&#125;:$&#123;TAG&#125; .</span><br><span class="line">                                &#x27;&#x27;&#x27;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (err) &#123;</span><br><span class="line">                        echo &quot;查找 Dockerfile 发生错误: $&#123;err&#125;&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&#x27;Image push&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;3. Pushing image&quot;</span><br><span class="line">                container(&#x27;builder&#x27;) &#123;</span><br><span class="line">                    script &#123;</span><br><span class="line">                        withCredentials([usernamePassword(credentialsId: &#x27;Redrock-Harbor-Secret&#x27;, passwordVariable: &#x27;passwd&#x27;, usernameVariable: &#x27;username&#x27;)]) &#123;</span><br><span class="line">                            sh &quot;buildah login -u $&#123;username&#125; -p $&#123;passwd&#125; $&#123;env.HARBOR_REGISTRY&#125;&quot;</span><br><span class="line">                            sh &quot;buildah images&quot;</span><br><span class="line">                            sh &quot;buildah push $&#123;HARBOR_REGISTRY&#125;/library/$&#123;IMAGE_NAME&#125;:$&#123;TAG&#125;&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stage(&#x27;Deploy to Kubernetes&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;5.即将把服务部署在Kubernetes集群上......&quot;</span><br><span class="line">                container(&#x27;deployer&#x27;) &#123;</span><br><span class="line">                    script &#123;</span><br><span class="line">                        // 使用受限制的kubeconfig</span><br><span class="line">                        def kubeConfigCreds = credentials(&#x27;kubeconfig&#x27;)</span><br><span class="line">                        // 写入临时kubeconfig文件</span><br><span class="line">                        sh &#x27;echo &quot;$&#123;kubeConfigCreds&#125;&quot; | base64 --decode &gt; /tmp/kubeconfig.yaml&#x27;</span><br><span class="line">                        sh &#x27;ls&#x27;</span><br><span class="line"></span><br><span class="line">            // 部署并获取返回码，如果成功部署则打包chart并上传至Harbor仓库</span><br><span class="line">                        def chartYamlContent = readFile &quot;charts/Chart.yaml&quot; // 读取Chart.yaml</span><br><span class="line">                        def chartYaml = readYaml text: chartYamlContent</span><br><span class="line">                        def chartVersion = chartYaml.version // 获取Chart的version</span><br><span class="line">                        def packageName = &quot;$&#123;PROJECT_NAME&#125;-$&#123;chartVersion&#125;.tgz&quot; // 打包后的Chart名</span><br><span class="line">                        </span><br><span class="line">                        def helmDeployResult = sh(script: &quot;helm install $&#123;PROJECT_NAME&#125; -n test --kubeconfig /tmp/kubeconfig.yaml charts&quot;, returnStatus: true)</span><br><span class="line">                if(helmDeployResult == 0) &#123;</span><br><span class="line">                    echo &#x27;部署成功！&#x27;</span><br><span class="line">                    echo &#x27;正在打包Chart，并上传至Harbor仓库&#x27;</span><br><span class="line">                    </span><br><span class="line">                    sh &quot;helm package charts&quot;</span><br><span class="line">                    withCredentials([usernamePassword(credentialsId: &#x27;Redrock-Harbor-Secret&#x27;, passwordVariable: &#x27;passwd&#x27;, usernameVariable: &#x27;username&#x27;)]) &#123;</span><br><span class="line">                        sh &quot;helm registry login $&#123;env.HARBOR_REGISTRY&#125; -u $&#123;username&#125; -p $&#123;passwd&#125;&quot;</span><br><span class="line">                        sh &quot;helm push $&#123;packageName&#125; oci://$&#123;HARBOR_REGISTRY&#125;/library&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    error &quot;Chart部署失败，Helm返回码: $&#123;helmDeployResult&#125;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406080026680.png" alt="image-20240608002622612"></p><h2 id="安全警示">安全警示</h2><p>根据<a href="https://github.com/containers/buildah/issues/5332">buildah image v1.34: Error: open /usr/lib/containers/storage/overlay-images/images.lock: permission denied · Issue #5332 · containers/buildah (github.com)</a></p><p>builder容器不得不开启<strong>privileged</strong>，否则无法进行正常的打包与推送镜像。</p><p>原因与解决可参考：<a href="https://opensource.com/article/19/3/tips-tricks-rootless-buildah">https://opensource.com/article/19/3/tips-tricks-rootless-buildah</a></p><p><img src="https://gitee.com/beatrueman/images/raw/master/img/202406080047843.png" alt="image-20240608004704783"></p>]]></content>
      
      
      <categories>
          
          <category> Blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Achievements </tag>
            
            <tag> CI/CD </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
